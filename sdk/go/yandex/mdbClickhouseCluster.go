// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package yandex

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a ClickHouse cluster within the Yandex.Cloud. For more information, see
// [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts).
//
// ## Example Usage
//
// Example of creating a Single Node ClickHouse.
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-yandex/sdk/go/yandex"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		fooVpcNetwork, err := yandex.NewVpcNetwork(ctx, "fooVpcNetwork", nil)
// 		if err != nil {
// 			return err
// 		}
// 		fooVpcSubnet, err := yandex.NewVpcSubnet(ctx, "fooVpcSubnet", &yandex.VpcSubnetArgs{
// 			NetworkId: fooVpcNetwork.ID(),
// 			V4CidrBlocks: pulumi.StringArray{
// 				pulumi.String("10.5.0.0/24"),
// 			},
// 			Zone: pulumi.String("ru-central1-a"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = yandex.NewMdbClickhouseCluster(ctx, "fooMdbClickhouseCluster", &yandex.MdbClickhouseClusterArgs{
// 			Clickhouse: &yandex.MdbClickhouseClusterClickhouseArgs{
// 				Config: &yandex.MdbClickhouseClusterClickhouseConfigArgs{
// 					BackgroundPoolSize:         pulumi.Int(16),
// 					BackgroundSchedulePoolSize: pulumi.Int(16),
// 					Compression: pulumi.MapArray{
// 						pulumi.Map{
// 							"method":           pulumi.String("LZ4"),
// 							"minPartSize":      pulumi.Float64(1024),
// 							"minPartSizeRatio": pulumi.Float64(0.5),
// 						},
// 						pulumi.Map{
// 							"method":           pulumi.String("ZSTD"),
// 							"minPartSize":      pulumi.Float64(2048),
// 							"minPartSizeRatio": pulumi.Float64(0.7),
// 						},
// 					},
// 					GeobaseUri: pulumi.String(""),
// 					GraphiteRollup: pulumi.Array{
// 						pulumi.Map{
// 							"name": pulumi.String("rollup1"),
// 							"pattern": pulumi.MapArray{
// 								pulumi.Map{
// 									"function": pulumi.String("func1"),
// 									"regexp":   pulumi.String("abc"),
// 									"retention": pulumi.Float64MapArray{
// 										pulumi.Float64Map{
// 											"age":       pulumi.Float64(1000),
// 											"precision": pulumi.Float64(3),
// 										},
// 									},
// 								},
// 							},
// 						},
// 						pulumi.Map{
// 							"name": pulumi.String("rollup2"),
// 							"pattern": pulumi.MapArray{
// 								pulumi.Map{
// 									"function": pulumi.String("func2"),
// 									"retention": pulumi.Float64MapArray{
// 										pulumi.Float64Map{
// 											"age":       pulumi.Float64(2000),
// 											"precision": pulumi.Float64(5),
// 										},
// 									},
// 								},
// 							},
// 						},
// 					},
// 					Kafka: &yandex.MdbClickhouseClusterClickhouseConfigKafkaArgs{
// 						SaslMechanism:    pulumi.String("SASL_MECHANISM_GSSAPI"),
// 						SaslPassword:     pulumi.String("pass1"),
// 						SaslUsername:     pulumi.String("user1"),
// 						SecurityProtocol: pulumi.String("SECURITY_PROTOCOL_PLAINTEXT"),
// 					},
// 					KafkaTopic: pulumi.Array{
// 						pulumi.Map{
// 							"name": pulumi.String("topic1"),
// 							"settings": pulumi.StringMap{
// 								"saslMechanism":    pulumi.String("SASL_MECHANISM_SCRAM_SHA_256"),
// 								"saslPassword":     pulumi.String("pass2"),
// 								"saslUsername":     pulumi.String("user2"),
// 								"securityProtocol": pulumi.String("SECURITY_PROTOCOL_SSL"),
// 							},
// 						},
// 						pulumi.Map{
// 							"name": pulumi.String("topic2"),
// 							"settings": pulumi.StringMap{
// 								"saslMechanism":    pulumi.String("SASL_MECHANISM_PLAIN"),
// 								"securityProtocol": pulumi.String("SECURITY_PROTOCOL_SASL_PLAINTEXT"),
// 							},
// 						},
// 					},
// 					KeepAliveTimeout:       pulumi.Int(3000),
// 					LogLevel:               pulumi.String("TRACE"),
// 					MarkCacheSize:          pulumi.Int(5368709120),
// 					MaxConcurrentQueries:   pulumi.Int(50),
// 					MaxConnections:         pulumi.Int(100),
// 					MaxPartitionSizeToDrop: pulumi.Int(53687091200),
// 					MaxTableSizeToDrop:     pulumi.Int(53687091200),
// 					MergeTree: &yandex.MdbClickhouseClusterClickhouseConfigMergeTreeArgs{
// 						MaxBytesToMergeAtMinSpaceInPool:                pulumi.Int(1048576),
// 						MaxReplicatedMergesInQueue:                     pulumi.Int(16),
// 						NumberOfFreeEntriesInPoolToLowerMaxSizeOfMerge: pulumi.Int(8),
// 						PartsToDelayInsert:                             pulumi.Int(150),
// 						PartsToThrowInsert:                             pulumi.Int(300),
// 						ReplicatedDeduplicationWindow:                  pulumi.Int(100),
// 						ReplicatedDeduplicationWindowSeconds:           pulumi.Int(604800),
// 					},
// 					MetricLogEnabled:            pulumi.Bool(true),
// 					MetricLogRetentionSize:      pulumi.Int(536870912),
// 					MetricLogRetentionTime:      pulumi.Int(2592000),
// 					PartLogRetentionSize:        pulumi.Int(536870912),
// 					PartLogRetentionTime:        pulumi.Int(2592000),
// 					QueryLogRetentionSize:       pulumi.Int(1073741824),
// 					QueryLogRetentionTime:       pulumi.Int(2592000),
// 					QueryThreadLogEnabled:       pulumi.Bool(true),
// 					QueryThreadLogRetentionSize: pulumi.Int(536870912),
// 					QueryThreadLogRetentionTime: pulumi.Int(2592000),
// 					Rabbitmq: &yandex.MdbClickhouseClusterClickhouseConfigRabbitmqArgs{
// 						Password: pulumi.String("rabbit_pass"),
// 						Username: pulumi.String("rabbit_user"),
// 					},
// 					TextLogEnabled:        pulumi.Bool(true),
// 					TextLogLevel:          pulumi.String("TRACE"),
// 					TextLogRetentionSize:  pulumi.Int(536870912),
// 					TextLogRetentionTime:  pulumi.Int(2592000),
// 					Timezone:              pulumi.String("UTC"),
// 					TraceLogEnabled:       pulumi.Bool(true),
// 					TraceLogRetentionSize: pulumi.Int(536870912),
// 					TraceLogRetentionTime: pulumi.Int(2592000),
// 					UncompressedCacheSize: pulumi.Int(8589934592),
// 				},
// 				Resources: &yandex.MdbClickhouseClusterClickhouseResourcesArgs{
// 					DiskSize:         pulumi.Int(32),
// 					DiskTypeId:       pulumi.String("network-ssd"),
// 					ResourcePresetId: pulumi.String("s2.micro"),
// 				},
// 			},
// 			CloudStorage: &yandex.MdbClickhouseClusterCloudStorageArgs{
// 				Enabled: pulumi.Bool(false),
// 			},
// 			Databases: yandex.MdbClickhouseClusterDatabaseArray{
// 				&yandex.MdbClickhouseClusterDatabaseArgs{
// 					Name: pulumi.String("db_name"),
// 				},
// 			},
// 			Environment: pulumi.String("PRESTABLE"),
// 			FormatSchemas: yandex.MdbClickhouseClusterFormatSchemaArray{
// 				&yandex.MdbClickhouseClusterFormatSchemaArgs{
// 					Name: pulumi.String("test_schema"),
// 					Type: pulumi.String("FORMAT_SCHEMA_TYPE_CAPNPROTO"),
// 					Uri:  pulumi.String("https://storage.yandexcloud.net/ch-data/schema.proto"),
// 				},
// 			},
// 			Hosts: yandex.MdbClickhouseClusterHostArray{
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					SubnetId: fooVpcSubnet.ID(),
// 					Type:     pulumi.String("CLICKHOUSE"),
// 					Zone:     pulumi.String("ru-central1-a"),
// 				},
// 			},
// 			MlModels: yandex.MdbClickhouseClusterMlModelArray{
// 				&yandex.MdbClickhouseClusterMlModelArgs{
// 					Name: pulumi.String("test_model"),
// 					Type: pulumi.String("ML_MODEL_TYPE_CATBOOST"),
// 					Uri:  pulumi.String("https://storage.yandexcloud.net/ch-data/train.csv"),
// 				},
// 			},
// 			NetworkId:        fooVpcNetwork.ID(),
// 			ServiceAccountId: pulumi.String("your_service_account_id"),
// 			Users: yandex.MdbClickhouseClusterUserArray{
// 				&yandex.MdbClickhouseClusterUserArgs{
// 					Name:     pulumi.String("user"),
// 					Password: pulumi.String("your_password"),
// 					Permissions: yandex.MdbClickhouseClusterUserPermissionArray{
// 						&yandex.MdbClickhouseClusterUserPermissionArgs{
// 							DatabaseName: pulumi.String("db_name"),
// 						},
// 					},
// 					Quotas: yandex.MdbClickhouseClusterUserQuotaArray{
// 						&yandex.MdbClickhouseClusterUserQuotaArgs{
// 							Errors:           pulumi.Int(1000),
// 							IntervalDuration: pulumi.Int(3600000),
// 							Queries:          pulumi.Int(10000),
// 						},
// 						&yandex.MdbClickhouseClusterUserQuotaArgs{
// 							Error:            pulumi.Float64(5000),
// 							IntervalDuration: pulumi.Int(79800000),
// 							Queries:          pulumi.Int(50000),
// 						},
// 					},
// 					Settings: &yandex.MdbClickhouseClusterUserSettingsArgs{
// 						MaxMemoryUsageForUser:              pulumi.Int(1000000000),
// 						OutputFormatJsonQuote64bitIntegers: pulumi.Bool(true),
// 						ReadOverflowMode:                   pulumi.String("throw"),
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// Example of creating a HA ClickHouse Cluster.
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-yandex/sdk/go/yandex"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		fooVpcNetwork, err := yandex.NewVpcNetwork(ctx, "fooVpcNetwork", nil)
// 		if err != nil {
// 			return err
// 		}
// 		fooVpcSubnet, err := yandex.NewVpcSubnet(ctx, "fooVpcSubnet", &yandex.VpcSubnetArgs{
// 			NetworkId: fooVpcNetwork.ID(),
// 			V4CidrBlocks: pulumi.StringArray{
// 				pulumi.String("10.1.0.0/24"),
// 			},
// 			Zone: pulumi.String("ru-central1-a"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		bar, err := yandex.NewVpcSubnet(ctx, "bar", &yandex.VpcSubnetArgs{
// 			NetworkId: fooVpcNetwork.ID(),
// 			V4CidrBlocks: pulumi.StringArray{
// 				pulumi.String("10.2.0.0/24"),
// 			},
// 			Zone: pulumi.String("ru-central1-b"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		baz, err := yandex.NewVpcSubnet(ctx, "baz", &yandex.VpcSubnetArgs{
// 			NetworkId: fooVpcNetwork.ID(),
// 			V4CidrBlocks: pulumi.StringArray{
// 				pulumi.String("10.3.0.0/24"),
// 			},
// 			Zone: pulumi.String("ru-central1-c"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = yandex.NewMdbClickhouseCluster(ctx, "fooMdbClickhouseCluster", &yandex.MdbClickhouseClusterArgs{
// 			Clickhouse: &yandex.MdbClickhouseClusterClickhouseArgs{
// 				Resources: &yandex.MdbClickhouseClusterClickhouseResourcesArgs{
// 					DiskSize:         pulumi.Int(16),
// 					DiskTypeId:       pulumi.String("network-ssd"),
// 					ResourcePresetId: pulumi.String("s2.micro"),
// 				},
// 			},
// 			CloudStorage: &yandex.MdbClickhouseClusterCloudStorageArgs{
// 				Enabled: pulumi.Bool(false),
// 			},
// 			Databases: yandex.MdbClickhouseClusterDatabaseArray{
// 				&yandex.MdbClickhouseClusterDatabaseArgs{
// 					Name: pulumi.String("db_name"),
// 				},
// 			},
// 			Environment: pulumi.String("PRESTABLE"),
// 			Hosts: yandex.MdbClickhouseClusterHostArray{
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					SubnetId: fooVpcSubnet.ID(),
// 					Type:     pulumi.String("CLICKHOUSE"),
// 					Zone:     pulumi.String("ru-central1-a"),
// 				},
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					SubnetId: bar.ID(),
// 					Type:     pulumi.String("CLICKHOUSE"),
// 					Zone:     pulumi.String("ru-central1-b"),
// 				},
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					SubnetId: fooVpcSubnet.ID(),
// 					Type:     pulumi.String("ZOOKEEPER"),
// 					Zone:     pulumi.String("ru-central1-a"),
// 				},
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					SubnetId: bar.ID(),
// 					Type:     pulumi.String("ZOOKEEPER"),
// 					Zone:     pulumi.String("ru-central1-b"),
// 				},
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					SubnetId: baz.ID(),
// 					Type:     pulumi.String("ZOOKEEPER"),
// 					Zone:     pulumi.String("ru-central1-c"),
// 				},
// 			},
// 			NetworkId: fooVpcNetwork.ID(),
// 			Users: yandex.MdbClickhouseClusterUserArray{
// 				&yandex.MdbClickhouseClusterUserArgs{
// 					Name:     pulumi.String("user"),
// 					Password: pulumi.String("password"),
// 					Permissions: yandex.MdbClickhouseClusterUserPermissionArray{
// 						&yandex.MdbClickhouseClusterUserPermissionArgs{
// 							DatabaseName: pulumi.String("db_name"),
// 						},
// 					},
// 					Quotas: yandex.MdbClickhouseClusterUserQuotaArray{
// 						&yandex.MdbClickhouseClusterUserQuotaArgs{
// 							Errors:           pulumi.Int(1000),
// 							IntervalDuration: pulumi.Int(3600000),
// 							Queries:          pulumi.Int(10000),
// 						},
// 						&yandex.MdbClickhouseClusterUserQuotaArgs{
// 							Error:            pulumi.Float64(5000),
// 							IntervalDuration: pulumi.Int(79800000),
// 							Queries:          pulumi.Int(50000),
// 						},
// 					},
// 					Settings: &yandex.MdbClickhouseClusterUserSettingsArgs{
// 						MaxMemoryUsageForUser:              pulumi.Int(1000000000),
// 						OutputFormatJsonQuote64bitIntegers: pulumi.Bool(true),
// 						ReadOverflowMode:                   pulumi.String("throw"),
// 					},
// 				},
// 			},
// 			Zookeeper: &yandex.MdbClickhouseClusterZookeeperArgs{
// 				Resources: &yandex.MdbClickhouseClusterZookeeperResourcesArgs{
// 					DiskSize:         pulumi.Int(10),
// 					DiskTypeId:       pulumi.String("network-ssd"),
// 					ResourcePresetId: pulumi.String("s2.micro"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// Example of creating a sharded ClickHouse Cluster.
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-yandex/sdk/go/yandex"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		fooVpcNetwork, err := yandex.NewVpcNetwork(ctx, "fooVpcNetwork", nil)
// 		if err != nil {
// 			return err
// 		}
// 		fooVpcSubnet, err := yandex.NewVpcSubnet(ctx, "fooVpcSubnet", &yandex.VpcSubnetArgs{
// 			NetworkId: fooVpcNetwork.ID(),
// 			V4CidrBlocks: pulumi.StringArray{
// 				pulumi.String("10.1.0.0/24"),
// 			},
// 			Zone: pulumi.String("ru-central1-a"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		bar, err := yandex.NewVpcSubnet(ctx, "bar", &yandex.VpcSubnetArgs{
// 			NetworkId: fooVpcNetwork.ID(),
// 			V4CidrBlocks: pulumi.StringArray{
// 				pulumi.String("10.2.0.0/24"),
// 			},
// 			Zone: pulumi.String("ru-central1-b"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		baz, err := yandex.NewVpcSubnet(ctx, "baz", &yandex.VpcSubnetArgs{
// 			NetworkId: fooVpcNetwork.ID(),
// 			V4CidrBlocks: pulumi.StringArray{
// 				pulumi.String("10.3.0.0/24"),
// 			},
// 			Zone: pulumi.String("ru-central1-c"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = yandex.NewMdbClickhouseCluster(ctx, "fooMdbClickhouseCluster", &yandex.MdbClickhouseClusterArgs{
// 			Clickhouse: &yandex.MdbClickhouseClusterClickhouseArgs{
// 				Resources: &yandex.MdbClickhouseClusterClickhouseResourcesArgs{
// 					DiskSize:         pulumi.Int(16),
// 					DiskTypeId:       pulumi.String("network-ssd"),
// 					ResourcePresetId: pulumi.String("s2.micro"),
// 				},
// 			},
// 			CloudStorage: &yandex.MdbClickhouseClusterCloudStorageArgs{
// 				Enabled: pulumi.Bool(false),
// 			},
// 			Databases: yandex.MdbClickhouseClusterDatabaseArray{
// 				&yandex.MdbClickhouseClusterDatabaseArgs{
// 					Name: pulumi.String("db_name"),
// 				},
// 			},
// 			Environment: pulumi.String("PRODUCTION"),
// 			Hosts: yandex.MdbClickhouseClusterHostArray{
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					ShardName: pulumi.String("shard1"),
// 					SubnetId:  fooVpcSubnet.ID(),
// 					Type:      pulumi.String("CLICKHOUSE"),
// 					Zone:      pulumi.String("ru-central1-a"),
// 				},
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					ShardName: pulumi.String("shard1"),
// 					SubnetId:  bar.ID(),
// 					Type:      pulumi.String("CLICKHOUSE"),
// 					Zone:      pulumi.String("ru-central1-b"),
// 				},
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					ShardName: pulumi.String("shard2"),
// 					SubnetId:  bar.ID(),
// 					Type:      pulumi.String("CLICKHOUSE"),
// 					Zone:      pulumi.String("ru-central1-b"),
// 				},
// 				&yandex.MdbClickhouseClusterHostArgs{
// 					ShardName: pulumi.String("shard2"),
// 					SubnetId:  baz.ID(),
// 					Type:      pulumi.String("CLICKHOUSE"),
// 					Zone:      pulumi.String("ru-central1-c"),
// 				},
// 			},
// 			NetworkId: fooVpcNetwork.ID(),
// 			ShardGroups: yandex.MdbClickhouseClusterShardGroupArray{
// 				&yandex.MdbClickhouseClusterShardGroupArgs{
// 					Description: pulumi.String("Cluster configuration that contain only shard1"),
// 					Name:        pulumi.String("single_shard_group"),
// 					ShardNames: pulumi.StringArray{
// 						pulumi.String("shard1"),
// 					},
// 				},
// 			},
// 			Users: yandex.MdbClickhouseClusterUserArray{
// 				&yandex.MdbClickhouseClusterUserArgs{
// 					Name:     pulumi.String("user"),
// 					Password: pulumi.String("password"),
// 					Permissions: yandex.MdbClickhouseClusterUserPermissionArray{
// 						&yandex.MdbClickhouseClusterUserPermissionArgs{
// 							DatabaseName: pulumi.String("db_name"),
// 						},
// 					},
// 					Quotas: yandex.MdbClickhouseClusterUserQuotaArray{
// 						&yandex.MdbClickhouseClusterUserQuotaArgs{
// 							Errors:           pulumi.Int(1000),
// 							IntervalDuration: pulumi.Int(3600000),
// 							Queries:          pulumi.Int(10000),
// 						},
// 						&yandex.MdbClickhouseClusterUserQuotaArgs{
// 							Error:            pulumi.Float64(5000),
// 							IntervalDuration: pulumi.Int(79800000),
// 							Queries:          pulumi.Int(50000),
// 						},
// 					},
// 					Settings: &yandex.MdbClickhouseClusterUserSettingsArgs{
// 						MaxMemoryUsageForUser:              pulumi.Int(1000000000),
// 						OutputFormatJsonQuote64bitIntegers: pulumi.Bool(true),
// 						ReadOverflowMode:                   pulumi.String("throw"),
// 					},
// 				},
// 			},
// 			Zookeeper: &yandex.MdbClickhouseClusterZookeeperArgs{
// 				Resources: &yandex.MdbClickhouseClusterZookeeperResourcesArgs{
// 					DiskSize:         pulumi.Int(10),
// 					DiskTypeId:       pulumi.String("network-ssd"),
// 					ResourcePresetId: pulumi.String("s2.micro"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// A cluster can be imported using the `id` of the resource, e.g.
//
// ```sh
//  $ pulumi import yandex:index/mdbClickhouseCluster:MdbClickhouseCluster foo cluster_id
// ```
type MdbClickhouseCluster struct {
	pulumi.CustomResourceState

	// Access policy to the ClickHouse cluster. The structure is documented below.
	Access MdbClickhouseClusterAccessOutput `pulumi:"access"`
	// A password used to authorize as user `admin` when `sqlUserManagement` enabled.
	AdminPassword pulumi.StringPtrOutput `pulumi:"adminPassword"`
	// Time to start the daily backup, in the UTC timezone. The structure is documented below.
	BackupWindowStart MdbClickhouseClusterBackupWindowStartOutput `pulumi:"backupWindowStart"`
	// Configuration of the ClickHouse subcluster. The structure is documented below.
	Clickhouse   MdbClickhouseClusterClickhouseOutput      `pulumi:"clickhouse"`
	CloudStorage MdbClickhouseClusterCloudStoragePtrOutput `pulumi:"cloudStorage"`
	// Whether to copy schema on new ClickHouse hosts.
	CopySchemaOnNewHosts pulumi.BoolPtrOutput `pulumi:"copySchemaOnNewHosts"`
	// Timestamp of cluster creation.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// A database of the ClickHouse cluster. The structure is documented below.
	Databases MdbClickhouseClusterDatabaseArrayOutput `pulumi:"databases"`
	// Description of the shard group.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Deployment environment of the ClickHouse cluster. Can be either `PRESTABLE` or `PRODUCTION`.
	Environment pulumi.StringOutput `pulumi:"environment"`
	// The ID of the folder that the resource belongs to. If it
	// is not provided, the default provider folder is used.
	FolderId pulumi.StringOutput `pulumi:"folderId"`
	// A set of protobuf or capnproto format schemas. The structure is documented below.
	FormatSchemas MdbClickhouseClusterFormatSchemaArrayOutput `pulumi:"formatSchemas"`
	// Aggregated health of the cluster. Can be either `ALIVE`, `DEGRADED`, `DEAD` or `HEALTH_UNKNOWN`.
	// For more information see `health` field of JSON representation in [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/api-ref/Cluster/).
	Health pulumi.StringOutput `pulumi:"health"`
	// A host of the ClickHouse cluster. The structure is documented below.
	Hosts MdbClickhouseClusterHostArrayOutput `pulumi:"hosts"`
	// A set of key/value label pairs to assign to the ClickHouse cluster.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// A group of machine learning models. The structure is documented below
	MlModels MdbClickhouseClusterMlModelArrayOutput `pulumi:"mlModels"`
	// Graphite rollup configuration name.
	Name pulumi.StringOutput `pulumi:"name"`
	// ID of the network, to which the ClickHouse cluster belongs.
	NetworkId pulumi.StringOutput `pulumi:"networkId"`
	// A set of ids of security groups assigned to hosts of the cluster.
	SecurityGroupIds pulumi.StringArrayOutput `pulumi:"securityGroupIds"`
	// ID of the service account used for access to Yandex Object Storage.
	ServiceAccountId pulumi.StringOutput `pulumi:"serviceAccountId"`
	// A group of clickhouse shards. The structure is documented below.
	ShardGroups MdbClickhouseClusterShardGroupArrayOutput `pulumi:"shardGroups"`
	// Grants `admin` user database management permission.
	SqlDatabaseManagement pulumi.BoolOutput `pulumi:"sqlDatabaseManagement"`
	// Enables `admin` user with user management permission.
	SqlUserManagement pulumi.BoolOutput `pulumi:"sqlUserManagement"`
	// Status of the cluster. Can be either `CREATING`, `STARTING`, `RUNNING`, `UPDATING`, `STOPPING`, `STOPPED`, `ERROR` or `STATUS_UNKNOWN`.
	// For more information see `status` field of JSON representation in [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/api-ref/Cluster/).
	Status pulumi.StringOutput `pulumi:"status"`
	// A user of the ClickHouse cluster. The structure is documented below.
	Users MdbClickhouseClusterUserArrayOutput `pulumi:"users"`
	// Version of the ClickHouse server software.
	Version pulumi.StringOutput `pulumi:"version"`
	// Configuration of the ZooKeeper subcluster. The structure is documented below.
	Zookeeper MdbClickhouseClusterZookeeperOutput `pulumi:"zookeeper"`
}

// NewMdbClickhouseCluster registers a new resource with the given unique name, arguments, and options.
func NewMdbClickhouseCluster(ctx *pulumi.Context,
	name string, args *MdbClickhouseClusterArgs, opts ...pulumi.ResourceOption) (*MdbClickhouseCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Clickhouse == nil {
		return nil, errors.New("invalid value for required argument 'Clickhouse'")
	}
	if args.Environment == nil {
		return nil, errors.New("invalid value for required argument 'Environment'")
	}
	if args.Hosts == nil {
		return nil, errors.New("invalid value for required argument 'Hosts'")
	}
	if args.NetworkId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkId'")
	}
	var resource MdbClickhouseCluster
	err := ctx.RegisterResource("yandex:index/mdbClickhouseCluster:MdbClickhouseCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMdbClickhouseCluster gets an existing MdbClickhouseCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMdbClickhouseCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MdbClickhouseClusterState, opts ...pulumi.ResourceOption) (*MdbClickhouseCluster, error) {
	var resource MdbClickhouseCluster
	err := ctx.ReadResource("yandex:index/mdbClickhouseCluster:MdbClickhouseCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MdbClickhouseCluster resources.
type mdbClickhouseClusterState struct {
	// Access policy to the ClickHouse cluster. The structure is documented below.
	Access *MdbClickhouseClusterAccess `pulumi:"access"`
	// A password used to authorize as user `admin` when `sqlUserManagement` enabled.
	AdminPassword *string `pulumi:"adminPassword"`
	// Time to start the daily backup, in the UTC timezone. The structure is documented below.
	BackupWindowStart *MdbClickhouseClusterBackupWindowStart `pulumi:"backupWindowStart"`
	// Configuration of the ClickHouse subcluster. The structure is documented below.
	Clickhouse   *MdbClickhouseClusterClickhouse   `pulumi:"clickhouse"`
	CloudStorage *MdbClickhouseClusterCloudStorage `pulumi:"cloudStorage"`
	// Whether to copy schema on new ClickHouse hosts.
	CopySchemaOnNewHosts *bool `pulumi:"copySchemaOnNewHosts"`
	// Timestamp of cluster creation.
	CreatedAt *string `pulumi:"createdAt"`
	// A database of the ClickHouse cluster. The structure is documented below.
	Databases []MdbClickhouseClusterDatabase `pulumi:"databases"`
	// Description of the shard group.
	Description *string `pulumi:"description"`
	// Deployment environment of the ClickHouse cluster. Can be either `PRESTABLE` or `PRODUCTION`.
	Environment *string `pulumi:"environment"`
	// The ID of the folder that the resource belongs to. If it
	// is not provided, the default provider folder is used.
	FolderId *string `pulumi:"folderId"`
	// A set of protobuf or capnproto format schemas. The structure is documented below.
	FormatSchemas []MdbClickhouseClusterFormatSchema `pulumi:"formatSchemas"`
	// Aggregated health of the cluster. Can be either `ALIVE`, `DEGRADED`, `DEAD` or `HEALTH_UNKNOWN`.
	// For more information see `health` field of JSON representation in [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/api-ref/Cluster/).
	Health *string `pulumi:"health"`
	// A host of the ClickHouse cluster. The structure is documented below.
	Hosts []MdbClickhouseClusterHost `pulumi:"hosts"`
	// A set of key/value label pairs to assign to the ClickHouse cluster.
	Labels map[string]string `pulumi:"labels"`
	// A group of machine learning models. The structure is documented below
	MlModels []MdbClickhouseClusterMlModel `pulumi:"mlModels"`
	// Graphite rollup configuration name.
	Name *string `pulumi:"name"`
	// ID of the network, to which the ClickHouse cluster belongs.
	NetworkId *string `pulumi:"networkId"`
	// A set of ids of security groups assigned to hosts of the cluster.
	SecurityGroupIds []string `pulumi:"securityGroupIds"`
	// ID of the service account used for access to Yandex Object Storage.
	ServiceAccountId *string `pulumi:"serviceAccountId"`
	// A group of clickhouse shards. The structure is documented below.
	ShardGroups []MdbClickhouseClusterShardGroup `pulumi:"shardGroups"`
	// Grants `admin` user database management permission.
	SqlDatabaseManagement *bool `pulumi:"sqlDatabaseManagement"`
	// Enables `admin` user with user management permission.
	SqlUserManagement *bool `pulumi:"sqlUserManagement"`
	// Status of the cluster. Can be either `CREATING`, `STARTING`, `RUNNING`, `UPDATING`, `STOPPING`, `STOPPED`, `ERROR` or `STATUS_UNKNOWN`.
	// For more information see `status` field of JSON representation in [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/api-ref/Cluster/).
	Status *string `pulumi:"status"`
	// A user of the ClickHouse cluster. The structure is documented below.
	Users []MdbClickhouseClusterUser `pulumi:"users"`
	// Version of the ClickHouse server software.
	Version *string `pulumi:"version"`
	// Configuration of the ZooKeeper subcluster. The structure is documented below.
	Zookeeper *MdbClickhouseClusterZookeeper `pulumi:"zookeeper"`
}

type MdbClickhouseClusterState struct {
	// Access policy to the ClickHouse cluster. The structure is documented below.
	Access MdbClickhouseClusterAccessPtrInput
	// A password used to authorize as user `admin` when `sqlUserManagement` enabled.
	AdminPassword pulumi.StringPtrInput
	// Time to start the daily backup, in the UTC timezone. The structure is documented below.
	BackupWindowStart MdbClickhouseClusterBackupWindowStartPtrInput
	// Configuration of the ClickHouse subcluster. The structure is documented below.
	Clickhouse   MdbClickhouseClusterClickhousePtrInput
	CloudStorage MdbClickhouseClusterCloudStoragePtrInput
	// Whether to copy schema on new ClickHouse hosts.
	CopySchemaOnNewHosts pulumi.BoolPtrInput
	// Timestamp of cluster creation.
	CreatedAt pulumi.StringPtrInput
	// A database of the ClickHouse cluster. The structure is documented below.
	Databases MdbClickhouseClusterDatabaseArrayInput
	// Description of the shard group.
	Description pulumi.StringPtrInput
	// Deployment environment of the ClickHouse cluster. Can be either `PRESTABLE` or `PRODUCTION`.
	Environment pulumi.StringPtrInput
	// The ID of the folder that the resource belongs to. If it
	// is not provided, the default provider folder is used.
	FolderId pulumi.StringPtrInput
	// A set of protobuf or capnproto format schemas. The structure is documented below.
	FormatSchemas MdbClickhouseClusterFormatSchemaArrayInput
	// Aggregated health of the cluster. Can be either `ALIVE`, `DEGRADED`, `DEAD` or `HEALTH_UNKNOWN`.
	// For more information see `health` field of JSON representation in [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/api-ref/Cluster/).
	Health pulumi.StringPtrInput
	// A host of the ClickHouse cluster. The structure is documented below.
	Hosts MdbClickhouseClusterHostArrayInput
	// A set of key/value label pairs to assign to the ClickHouse cluster.
	Labels pulumi.StringMapInput
	// A group of machine learning models. The structure is documented below
	MlModels MdbClickhouseClusterMlModelArrayInput
	// Graphite rollup configuration name.
	Name pulumi.StringPtrInput
	// ID of the network, to which the ClickHouse cluster belongs.
	NetworkId pulumi.StringPtrInput
	// A set of ids of security groups assigned to hosts of the cluster.
	SecurityGroupIds pulumi.StringArrayInput
	// ID of the service account used for access to Yandex Object Storage.
	ServiceAccountId pulumi.StringPtrInput
	// A group of clickhouse shards. The structure is documented below.
	ShardGroups MdbClickhouseClusterShardGroupArrayInput
	// Grants `admin` user database management permission.
	SqlDatabaseManagement pulumi.BoolPtrInput
	// Enables `admin` user with user management permission.
	SqlUserManagement pulumi.BoolPtrInput
	// Status of the cluster. Can be either `CREATING`, `STARTING`, `RUNNING`, `UPDATING`, `STOPPING`, `STOPPED`, `ERROR` or `STATUS_UNKNOWN`.
	// For more information see `status` field of JSON representation in [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/api-ref/Cluster/).
	Status pulumi.StringPtrInput
	// A user of the ClickHouse cluster. The structure is documented below.
	Users MdbClickhouseClusterUserArrayInput
	// Version of the ClickHouse server software.
	Version pulumi.StringPtrInput
	// Configuration of the ZooKeeper subcluster. The structure is documented below.
	Zookeeper MdbClickhouseClusterZookeeperPtrInput
}

func (MdbClickhouseClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*mdbClickhouseClusterState)(nil)).Elem()
}

type mdbClickhouseClusterArgs struct {
	// Access policy to the ClickHouse cluster. The structure is documented below.
	Access *MdbClickhouseClusterAccess `pulumi:"access"`
	// A password used to authorize as user `admin` when `sqlUserManagement` enabled.
	AdminPassword *string `pulumi:"adminPassword"`
	// Time to start the daily backup, in the UTC timezone. The structure is documented below.
	BackupWindowStart *MdbClickhouseClusterBackupWindowStart `pulumi:"backupWindowStart"`
	// Configuration of the ClickHouse subcluster. The structure is documented below.
	Clickhouse   MdbClickhouseClusterClickhouse    `pulumi:"clickhouse"`
	CloudStorage *MdbClickhouseClusterCloudStorage `pulumi:"cloudStorage"`
	// Whether to copy schema on new ClickHouse hosts.
	CopySchemaOnNewHosts *bool `pulumi:"copySchemaOnNewHosts"`
	// A database of the ClickHouse cluster. The structure is documented below.
	Databases []MdbClickhouseClusterDatabase `pulumi:"databases"`
	// Description of the shard group.
	Description *string `pulumi:"description"`
	// Deployment environment of the ClickHouse cluster. Can be either `PRESTABLE` or `PRODUCTION`.
	Environment string `pulumi:"environment"`
	// The ID of the folder that the resource belongs to. If it
	// is not provided, the default provider folder is used.
	FolderId *string `pulumi:"folderId"`
	// A set of protobuf or capnproto format schemas. The structure is documented below.
	FormatSchemas []MdbClickhouseClusterFormatSchema `pulumi:"formatSchemas"`
	// A host of the ClickHouse cluster. The structure is documented below.
	Hosts []MdbClickhouseClusterHost `pulumi:"hosts"`
	// A set of key/value label pairs to assign to the ClickHouse cluster.
	Labels map[string]string `pulumi:"labels"`
	// A group of machine learning models. The structure is documented below
	MlModels []MdbClickhouseClusterMlModel `pulumi:"mlModels"`
	// Graphite rollup configuration name.
	Name *string `pulumi:"name"`
	// ID of the network, to which the ClickHouse cluster belongs.
	NetworkId string `pulumi:"networkId"`
	// A set of ids of security groups assigned to hosts of the cluster.
	SecurityGroupIds []string `pulumi:"securityGroupIds"`
	// ID of the service account used for access to Yandex Object Storage.
	ServiceAccountId *string `pulumi:"serviceAccountId"`
	// A group of clickhouse shards. The structure is documented below.
	ShardGroups []MdbClickhouseClusterShardGroup `pulumi:"shardGroups"`
	// Grants `admin` user database management permission.
	SqlDatabaseManagement *bool `pulumi:"sqlDatabaseManagement"`
	// Enables `admin` user with user management permission.
	SqlUserManagement *bool `pulumi:"sqlUserManagement"`
	// A user of the ClickHouse cluster. The structure is documented below.
	Users []MdbClickhouseClusterUser `pulumi:"users"`
	// Version of the ClickHouse server software.
	Version *string `pulumi:"version"`
	// Configuration of the ZooKeeper subcluster. The structure is documented below.
	Zookeeper *MdbClickhouseClusterZookeeper `pulumi:"zookeeper"`
}

// The set of arguments for constructing a MdbClickhouseCluster resource.
type MdbClickhouseClusterArgs struct {
	// Access policy to the ClickHouse cluster. The structure is documented below.
	Access MdbClickhouseClusterAccessPtrInput
	// A password used to authorize as user `admin` when `sqlUserManagement` enabled.
	AdminPassword pulumi.StringPtrInput
	// Time to start the daily backup, in the UTC timezone. The structure is documented below.
	BackupWindowStart MdbClickhouseClusterBackupWindowStartPtrInput
	// Configuration of the ClickHouse subcluster. The structure is documented below.
	Clickhouse   MdbClickhouseClusterClickhouseInput
	CloudStorage MdbClickhouseClusterCloudStoragePtrInput
	// Whether to copy schema on new ClickHouse hosts.
	CopySchemaOnNewHosts pulumi.BoolPtrInput
	// A database of the ClickHouse cluster. The structure is documented below.
	Databases MdbClickhouseClusterDatabaseArrayInput
	// Description of the shard group.
	Description pulumi.StringPtrInput
	// Deployment environment of the ClickHouse cluster. Can be either `PRESTABLE` or `PRODUCTION`.
	Environment pulumi.StringInput
	// The ID of the folder that the resource belongs to. If it
	// is not provided, the default provider folder is used.
	FolderId pulumi.StringPtrInput
	// A set of protobuf or capnproto format schemas. The structure is documented below.
	FormatSchemas MdbClickhouseClusterFormatSchemaArrayInput
	// A host of the ClickHouse cluster. The structure is documented below.
	Hosts MdbClickhouseClusterHostArrayInput
	// A set of key/value label pairs to assign to the ClickHouse cluster.
	Labels pulumi.StringMapInput
	// A group of machine learning models. The structure is documented below
	MlModels MdbClickhouseClusterMlModelArrayInput
	// Graphite rollup configuration name.
	Name pulumi.StringPtrInput
	// ID of the network, to which the ClickHouse cluster belongs.
	NetworkId pulumi.StringInput
	// A set of ids of security groups assigned to hosts of the cluster.
	SecurityGroupIds pulumi.StringArrayInput
	// ID of the service account used for access to Yandex Object Storage.
	ServiceAccountId pulumi.StringPtrInput
	// A group of clickhouse shards. The structure is documented below.
	ShardGroups MdbClickhouseClusterShardGroupArrayInput
	// Grants `admin` user database management permission.
	SqlDatabaseManagement pulumi.BoolPtrInput
	// Enables `admin` user with user management permission.
	SqlUserManagement pulumi.BoolPtrInput
	// A user of the ClickHouse cluster. The structure is documented below.
	Users MdbClickhouseClusterUserArrayInput
	// Version of the ClickHouse server software.
	Version pulumi.StringPtrInput
	// Configuration of the ZooKeeper subcluster. The structure is documented below.
	Zookeeper MdbClickhouseClusterZookeeperPtrInput
}

func (MdbClickhouseClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*mdbClickhouseClusterArgs)(nil)).Elem()
}

type MdbClickhouseClusterInput interface {
	pulumi.Input

	ToMdbClickhouseClusterOutput() MdbClickhouseClusterOutput
	ToMdbClickhouseClusterOutputWithContext(ctx context.Context) MdbClickhouseClusterOutput
}

func (*MdbClickhouseCluster) ElementType() reflect.Type {
	return reflect.TypeOf((*MdbClickhouseCluster)(nil))
}

func (i *MdbClickhouseCluster) ToMdbClickhouseClusterOutput() MdbClickhouseClusterOutput {
	return i.ToMdbClickhouseClusterOutputWithContext(context.Background())
}

func (i *MdbClickhouseCluster) ToMdbClickhouseClusterOutputWithContext(ctx context.Context) MdbClickhouseClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MdbClickhouseClusterOutput)
}

func (i *MdbClickhouseCluster) ToMdbClickhouseClusterPtrOutput() MdbClickhouseClusterPtrOutput {
	return i.ToMdbClickhouseClusterPtrOutputWithContext(context.Background())
}

func (i *MdbClickhouseCluster) ToMdbClickhouseClusterPtrOutputWithContext(ctx context.Context) MdbClickhouseClusterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MdbClickhouseClusterPtrOutput)
}

type MdbClickhouseClusterPtrInput interface {
	pulumi.Input

	ToMdbClickhouseClusterPtrOutput() MdbClickhouseClusterPtrOutput
	ToMdbClickhouseClusterPtrOutputWithContext(ctx context.Context) MdbClickhouseClusterPtrOutput
}

type mdbClickhouseClusterPtrType MdbClickhouseClusterArgs

func (*mdbClickhouseClusterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MdbClickhouseCluster)(nil))
}

func (i *mdbClickhouseClusterPtrType) ToMdbClickhouseClusterPtrOutput() MdbClickhouseClusterPtrOutput {
	return i.ToMdbClickhouseClusterPtrOutputWithContext(context.Background())
}

func (i *mdbClickhouseClusterPtrType) ToMdbClickhouseClusterPtrOutputWithContext(ctx context.Context) MdbClickhouseClusterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MdbClickhouseClusterPtrOutput)
}

// MdbClickhouseClusterArrayInput is an input type that accepts MdbClickhouseClusterArray and MdbClickhouseClusterArrayOutput values.
// You can construct a concrete instance of `MdbClickhouseClusterArrayInput` via:
//
//          MdbClickhouseClusterArray{ MdbClickhouseClusterArgs{...} }
type MdbClickhouseClusterArrayInput interface {
	pulumi.Input

	ToMdbClickhouseClusterArrayOutput() MdbClickhouseClusterArrayOutput
	ToMdbClickhouseClusterArrayOutputWithContext(context.Context) MdbClickhouseClusterArrayOutput
}

type MdbClickhouseClusterArray []MdbClickhouseClusterInput

func (MdbClickhouseClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*MdbClickhouseCluster)(nil))
}

func (i MdbClickhouseClusterArray) ToMdbClickhouseClusterArrayOutput() MdbClickhouseClusterArrayOutput {
	return i.ToMdbClickhouseClusterArrayOutputWithContext(context.Background())
}

func (i MdbClickhouseClusterArray) ToMdbClickhouseClusterArrayOutputWithContext(ctx context.Context) MdbClickhouseClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MdbClickhouseClusterArrayOutput)
}

// MdbClickhouseClusterMapInput is an input type that accepts MdbClickhouseClusterMap and MdbClickhouseClusterMapOutput values.
// You can construct a concrete instance of `MdbClickhouseClusterMapInput` via:
//
//          MdbClickhouseClusterMap{ "key": MdbClickhouseClusterArgs{...} }
type MdbClickhouseClusterMapInput interface {
	pulumi.Input

	ToMdbClickhouseClusterMapOutput() MdbClickhouseClusterMapOutput
	ToMdbClickhouseClusterMapOutputWithContext(context.Context) MdbClickhouseClusterMapOutput
}

type MdbClickhouseClusterMap map[string]MdbClickhouseClusterInput

func (MdbClickhouseClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*MdbClickhouseCluster)(nil))
}

func (i MdbClickhouseClusterMap) ToMdbClickhouseClusterMapOutput() MdbClickhouseClusterMapOutput {
	return i.ToMdbClickhouseClusterMapOutputWithContext(context.Background())
}

func (i MdbClickhouseClusterMap) ToMdbClickhouseClusterMapOutputWithContext(ctx context.Context) MdbClickhouseClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MdbClickhouseClusterMapOutput)
}

type MdbClickhouseClusterOutput struct {
	*pulumi.OutputState
}

func (MdbClickhouseClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MdbClickhouseCluster)(nil))
}

func (o MdbClickhouseClusterOutput) ToMdbClickhouseClusterOutput() MdbClickhouseClusterOutput {
	return o
}

func (o MdbClickhouseClusterOutput) ToMdbClickhouseClusterOutputWithContext(ctx context.Context) MdbClickhouseClusterOutput {
	return o
}

func (o MdbClickhouseClusterOutput) ToMdbClickhouseClusterPtrOutput() MdbClickhouseClusterPtrOutput {
	return o.ToMdbClickhouseClusterPtrOutputWithContext(context.Background())
}

func (o MdbClickhouseClusterOutput) ToMdbClickhouseClusterPtrOutputWithContext(ctx context.Context) MdbClickhouseClusterPtrOutput {
	return o.ApplyT(func(v MdbClickhouseCluster) *MdbClickhouseCluster {
		return &v
	}).(MdbClickhouseClusterPtrOutput)
}

type MdbClickhouseClusterPtrOutput struct {
	*pulumi.OutputState
}

func (MdbClickhouseClusterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MdbClickhouseCluster)(nil))
}

func (o MdbClickhouseClusterPtrOutput) ToMdbClickhouseClusterPtrOutput() MdbClickhouseClusterPtrOutput {
	return o
}

func (o MdbClickhouseClusterPtrOutput) ToMdbClickhouseClusterPtrOutputWithContext(ctx context.Context) MdbClickhouseClusterPtrOutput {
	return o
}

type MdbClickhouseClusterArrayOutput struct{ *pulumi.OutputState }

func (MdbClickhouseClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MdbClickhouseCluster)(nil))
}

func (o MdbClickhouseClusterArrayOutput) ToMdbClickhouseClusterArrayOutput() MdbClickhouseClusterArrayOutput {
	return o
}

func (o MdbClickhouseClusterArrayOutput) ToMdbClickhouseClusterArrayOutputWithContext(ctx context.Context) MdbClickhouseClusterArrayOutput {
	return o
}

func (o MdbClickhouseClusterArrayOutput) Index(i pulumi.IntInput) MdbClickhouseClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MdbClickhouseCluster {
		return vs[0].([]MdbClickhouseCluster)[vs[1].(int)]
	}).(MdbClickhouseClusterOutput)
}

type MdbClickhouseClusterMapOutput struct{ *pulumi.OutputState }

func (MdbClickhouseClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]MdbClickhouseCluster)(nil))
}

func (o MdbClickhouseClusterMapOutput) ToMdbClickhouseClusterMapOutput() MdbClickhouseClusterMapOutput {
	return o
}

func (o MdbClickhouseClusterMapOutput) ToMdbClickhouseClusterMapOutputWithContext(ctx context.Context) MdbClickhouseClusterMapOutput {
	return o
}

func (o MdbClickhouseClusterMapOutput) MapIndex(k pulumi.StringInput) MdbClickhouseClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) MdbClickhouseCluster {
		return vs[0].(map[string]MdbClickhouseCluster)[vs[1].(string)]
	}).(MdbClickhouseClusterOutput)
}

func init() {
	pulumi.RegisterOutputType(MdbClickhouseClusterOutput{})
	pulumi.RegisterOutputType(MdbClickhouseClusterPtrOutput{})
	pulumi.RegisterOutputType(MdbClickhouseClusterArrayOutput{})
	pulumi.RegisterOutputType(MdbClickhouseClusterMapOutput{})
}
