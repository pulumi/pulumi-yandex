# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AlbBackendGroupGrpcBackend',
    'AlbBackendGroupGrpcBackendHealthcheck',
    'AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck',
    'AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck',
    'AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck',
    'AlbBackendGroupGrpcBackendLoadBalancingConfig',
    'AlbBackendGroupGrpcBackendTls',
    'AlbBackendGroupGrpcBackendTlsValidationContext',
    'AlbBackendGroupHttpBackend',
    'AlbBackendGroupHttpBackendHealthcheck',
    'AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck',
    'AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck',
    'AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck',
    'AlbBackendGroupHttpBackendLoadBalancingConfig',
    'AlbBackendGroupHttpBackendTls',
    'AlbBackendGroupHttpBackendTlsValidationContext',
    'AlbBackendGroupStreamBackend',
    'AlbBackendGroupStreamBackendHealthcheck',
    'AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck',
    'AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck',
    'AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck',
    'AlbBackendGroupStreamBackendLoadBalancingConfig',
    'AlbBackendGroupStreamBackendTls',
    'AlbBackendGroupStreamBackendTlsValidationContext',
    'AlbLoadBalancerAllocationPolicy',
    'AlbLoadBalancerAllocationPolicyLocation',
    'AlbLoadBalancerListener',
    'AlbLoadBalancerListenerEndpoint',
    'AlbLoadBalancerListenerEndpointAddress',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv4Address',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv6Address',
    'AlbLoadBalancerListenerEndpointAddressInternalIpv4Address',
    'AlbLoadBalancerListenerHttp',
    'AlbLoadBalancerListenerHttpHandler',
    'AlbLoadBalancerListenerHttpHandlerHttp2Options',
    'AlbLoadBalancerListenerHttpRedirects',
    'AlbLoadBalancerListenerStream',
    'AlbLoadBalancerListenerStreamHandler',
    'AlbLoadBalancerListenerTls',
    'AlbLoadBalancerListenerTlsDefaultHandler',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options',
    'AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler',
    'AlbLoadBalancerListenerTlsSniHandler',
    'AlbLoadBalancerListenerTlsSniHandlerHandler',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler',
    'AlbTargetGroupTarget',
    'AlbVirtualHostModifyRequestHeader',
    'AlbVirtualHostModifyResponseHeader',
    'AlbVirtualHostRoute',
    'AlbVirtualHostRouteGrpcRoute',
    'AlbVirtualHostRouteGrpcRouteGrpcMatch',
    'AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteAction',
    'AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction',
    'AlbVirtualHostRouteHttpRoute',
    'AlbVirtualHostRouteHttpRouteDirectResponseAction',
    'AlbVirtualHostRouteHttpRouteHttpMatch',
    'AlbVirtualHostRouteHttpRouteHttpMatchPath',
    'AlbVirtualHostRouteHttpRouteHttpRouteAction',
    'AlbVirtualHostRouteHttpRouteRedirectAction',
    'CdnOriginGroupOrigin',
    'CdnResourceOptions',
    'CdnResourceSslCertificate',
    'ComputeDiskDiskPlacementPolicy',
    'ComputeInstanceBootDisk',
    'ComputeInstanceBootDiskInitializeParams',
    'ComputeInstanceGroupAllocationPolicy',
    'ComputeInstanceGroupApplicationLoadBalancer',
    'ComputeInstanceGroupDeployPolicy',
    'ComputeInstanceGroupHealthCheck',
    'ComputeInstanceGroupHealthCheckHttpOption',
    'ComputeInstanceGroupHealthCheckTcpOptions',
    'ComputeInstanceGroupInstance',
    'ComputeInstanceGroupInstanceNetworkInterface',
    'ComputeInstanceGroupInstanceTemplate',
    'ComputeInstanceGroupInstanceTemplateBootDisk',
    'ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams',
    'ComputeInstanceGroupInstanceTemplateNetworkInterface',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord',
    'ComputeInstanceGroupInstanceTemplateNetworkSetting',
    'ComputeInstanceGroupInstanceTemplatePlacementPolicy',
    'ComputeInstanceGroupInstanceTemplateResources',
    'ComputeInstanceGroupInstanceTemplateSchedulingPolicy',
    'ComputeInstanceGroupInstanceTemplateSecondaryDisk',
    'ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams',
    'ComputeInstanceGroupLoadBalancer',
    'ComputeInstanceGroupScalePolicy',
    'ComputeInstanceGroupScalePolicyAutoScale',
    'ComputeInstanceGroupScalePolicyAutoScaleCustomRule',
    'ComputeInstanceGroupScalePolicyFixedScale',
    'ComputeInstanceGroupScalePolicyTestAutoScale',
    'ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule',
    'ComputeInstanceNetworkInterface',
    'ComputeInstanceNetworkInterfaceDnsRecord',
    'ComputeInstanceNetworkInterfaceIpv6DnsRecord',
    'ComputeInstanceNetworkInterfaceNatDnsRecord',
    'ComputeInstancePlacementPolicy',
    'ComputeInstanceResources',
    'ComputeInstanceSchedulingPolicy',
    'ComputeInstanceSecondaryDisk',
    'DataprocClusterClusterConfig',
    'DataprocClusterClusterConfigHadoop',
    'DataprocClusterClusterConfigSubclusterSpec',
    'DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig',
    'DataprocClusterClusterConfigSubclusterSpecResources',
    'DatatransferEndpointSettings',
    'DatatransferEndpointSettingsMysqlSource',
    'DatatransferEndpointSettingsMysqlSourceConnection',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremise',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsMysqlSourceObjectTransferSettings',
    'DatatransferEndpointSettingsMysqlSourcePassword',
    'DatatransferEndpointSettingsMysqlTarget',
    'DatatransferEndpointSettingsMysqlTargetConnection',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremise',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsMysqlTargetPassword',
    'DatatransferEndpointSettingsPostgresSource',
    'DatatransferEndpointSettingsPostgresSourceConnection',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremise',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsPostgresSourceObjectTransferSettings',
    'DatatransferEndpointSettingsPostgresSourcePassword',
    'DatatransferEndpointSettingsPostgresTarget',
    'DatatransferEndpointSettingsPostgresTargetConnection',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremise',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsPostgresTargetPassword',
    'FunctionContent',
    'FunctionPackage',
    'FunctionScalingPolicyPolicy',
    'FunctionTriggerDlq',
    'FunctionTriggerFunction',
    'FunctionTriggerIot',
    'FunctionTriggerLogGroup',
    'FunctionTriggerLogging',
    'FunctionTriggerMessageQueue',
    'FunctionTriggerObjectStorage',
    'FunctionTriggerTimer',
    'KubernetesClusterKmsProvider',
    'KubernetesClusterMaster',
    'KubernetesClusterMasterMaintenancePolicy',
    'KubernetesClusterMasterMaintenancePolicyMaintenanceWindow',
    'KubernetesClusterMasterRegional',
    'KubernetesClusterMasterRegionalLocation',
    'KubernetesClusterMasterVersionInfo',
    'KubernetesClusterMasterZonal',
    'KubernetesClusterNetworkImplementation',
    'KubernetesClusterNetworkImplementationCilium',
    'KubernetesNodeGroupAllocationPolicy',
    'KubernetesNodeGroupAllocationPolicyLocation',
    'KubernetesNodeGroupDeployPolicy',
    'KubernetesNodeGroupInstanceTemplate',
    'KubernetesNodeGroupInstanceTemplateBootDisk',
    'KubernetesNodeGroupInstanceTemplateContainerRuntime',
    'KubernetesNodeGroupInstanceTemplateNetworkInterface',
    'KubernetesNodeGroupInstanceTemplatePlacementPolicy',
    'KubernetesNodeGroupInstanceTemplateResources',
    'KubernetesNodeGroupInstanceTemplateSchedulingPolicy',
    'KubernetesNodeGroupMaintenancePolicy',
    'KubernetesNodeGroupMaintenancePolicyMaintenanceWindow',
    'KubernetesNodeGroupScalePolicy',
    'KubernetesNodeGroupScalePolicyAutoScale',
    'KubernetesNodeGroupScalePolicyFixedScale',
    'KubernetesNodeGroupVersionInfo',
    'LbNetworkLoadBalancerAttachedTargetGroup',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheck',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions',
    'LbNetworkLoadBalancerListener',
    'LbNetworkLoadBalancerListenerExternalAddressSpec',
    'LbNetworkLoadBalancerListenerInternalAddressSpec',
    'LbTargetGroupTarget',
    'MdbClickhouseClusterAccess',
    'MdbClickhouseClusterBackupWindowStart',
    'MdbClickhouseClusterClickhouse',
    'MdbClickhouseClusterClickhouseConfig',
    'MdbClickhouseClusterClickhouseConfigCompression',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollup',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention',
    'MdbClickhouseClusterClickhouseConfigKafka',
    'MdbClickhouseClusterClickhouseConfigKafkaTopic',
    'MdbClickhouseClusterClickhouseConfigKafkaTopicSettings',
    'MdbClickhouseClusterClickhouseConfigMergeTree',
    'MdbClickhouseClusterClickhouseConfigRabbitmq',
    'MdbClickhouseClusterClickhouseResources',
    'MdbClickhouseClusterCloudStorage',
    'MdbClickhouseClusterDatabase',
    'MdbClickhouseClusterFormatSchema',
    'MdbClickhouseClusterHost',
    'MdbClickhouseClusterMaintenanceWindow',
    'MdbClickhouseClusterMlModel',
    'MdbClickhouseClusterShardGroup',
    'MdbClickhouseClusterUser',
    'MdbClickhouseClusterUserPermission',
    'MdbClickhouseClusterUserQuota',
    'MdbClickhouseClusterUserSettings',
    'MdbClickhouseClusterZookeeper',
    'MdbClickhouseClusterZookeeperResources',
    'MdbElasticSearchClusterConfig',
    'MdbElasticSearchClusterConfigDataNode',
    'MdbElasticSearchClusterConfigDataNodeResources',
    'MdbElasticSearchClusterConfigMasterNode',
    'MdbElasticSearchClusterConfigMasterNodeResources',
    'MdbElasticSearchClusterHost',
    'MdbElasticSearchClusterMaintenanceWindow',
    'MdbGreenplumClusterAccess',
    'MdbGreenplumClusterBackupWindowStart',
    'MdbGreenplumClusterMasterHost',
    'MdbGreenplumClusterMasterSubcluster',
    'MdbGreenplumClusterMasterSubclusterResources',
    'MdbGreenplumClusterSegmentHost',
    'MdbGreenplumClusterSegmentSubcluster',
    'MdbGreenplumClusterSegmentSubclusterResources',
    'MdbKafkaClusterConfig',
    'MdbKafkaClusterConfigKafka',
    'MdbKafkaClusterConfigKafkaKafkaConfig',
    'MdbKafkaClusterConfigKafkaResources',
    'MdbKafkaClusterConfigZookeeper',
    'MdbKafkaClusterConfigZookeeperResources',
    'MdbKafkaClusterHost',
    'MdbKafkaClusterMaintenanceWindow',
    'MdbKafkaClusterTopic',
    'MdbKafkaClusterTopicTopicConfig',
    'MdbKafkaClusterUser',
    'MdbKafkaClusterUserPermission',
    'MdbKafkaTopicTopicConfig',
    'MdbMongodbClusterClusterConfig',
    'MdbMongodbClusterClusterConfigAccess',
    'MdbMongodbClusterClusterConfigBackupWindowStart',
    'MdbMongodbClusterDatabase',
    'MdbMongodbClusterHost',
    'MdbMongodbClusterMaintenanceWindow',
    'MdbMongodbClusterResources',
    'MdbMongodbClusterUser',
    'MdbMongodbClusterUserPermission',
    'MdbMysqlClusterAccess',
    'MdbMysqlClusterBackupWindowStart',
    'MdbMysqlClusterDatabase',
    'MdbMysqlClusterHost',
    'MdbMysqlClusterMaintenanceWindow',
    'MdbMysqlClusterResources',
    'MdbMysqlClusterRestore',
    'MdbMysqlClusterUser',
    'MdbMysqlClusterUserConnectionLimits',
    'MdbMysqlClusterUserPermission',
    'MdbRedisClusterConfig',
    'MdbRedisClusterHost',
    'MdbRedisClusterMaintenanceWindow',
    'MdbRedisClusterResources',
    'MdbSqlServerClusterBackupWindowStart',
    'MdbSqlServerClusterDatabase',
    'MdbSqlServerClusterHost',
    'MdbSqlServerClusterResources',
    'MdbSqlServerClusterUser',
    'MdbSqlServerClusterUserPermission',
    'OrganizationmanagerSamlFederationSecuritySettings',
    'ServerlessContainerImage',
    'StorageBucketCorsRule',
    'StorageBucketGrant',
    'StorageBucketLifecycleRule',
    'StorageBucketLifecycleRuleExpiration',
    'StorageBucketLifecycleRuleNoncurrentVersionExpiration',
    'StorageBucketLifecycleRuleNoncurrentVersionTransition',
    'StorageBucketLifecycleRuleTransition',
    'StorageBucketLogging',
    'StorageBucketServerSideEncryptionConfiguration',
    'StorageBucketServerSideEncryptionConfigurationRule',
    'StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault',
    'StorageBucketVersioning',
    'StorageBucketWebsite',
    'VpcAddressExternalIpv4Address',
    'VpcDefaultSecurityGroupEgress',
    'VpcDefaultSecurityGroupIngress',
    'VpcRouteTableStaticRoute',
    'VpcSecurityGroupEgress',
    'VpcSecurityGroupIngress',
    'VpcSubnetDhcpOptions',
    'YdbDatabaseDedicatedLocation',
    'YdbDatabaseDedicatedLocationRegion',
    'YdbDatabaseDedicatedScalePolicy',
    'YdbDatabaseDedicatedScalePolicyFixedScale',
    'YdbDatabaseDedicatedStorageConfig',
    'GetAlbBackendGroupGrpcBackendResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult',
    'GetAlbBackendGroupGrpcBackendTlsResult',
    'GetAlbBackendGroupGrpcBackendTlsValidationContextResult',
    'GetAlbBackendGroupHttpBackendResult',
    'GetAlbBackendGroupHttpBackendHealthcheckResult',
    'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult',
    'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult',
    'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult',
    'GetAlbBackendGroupHttpBackendLoadBalancingConfigResult',
    'GetAlbBackendGroupHttpBackendTlsResult',
    'GetAlbBackendGroupHttpBackendTlsValidationContextResult',
    'GetAlbBackendGroupStreamBackendResult',
    'GetAlbBackendGroupStreamBackendHealthcheckResult',
    'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult',
    'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult',
    'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult',
    'GetAlbBackendGroupStreamBackendLoadBalancingConfigResult',
    'GetAlbBackendGroupStreamBackendTlsResult',
    'GetAlbBackendGroupStreamBackendTlsValidationContextResult',
    'GetAlbLoadBalancerAllocationPolicyResult',
    'GetAlbLoadBalancerAllocationPolicyLocationResult',
    'GetAlbLoadBalancerListenerResult',
    'GetAlbLoadBalancerListenerEndpointResult',
    'GetAlbLoadBalancerListenerEndpointAddressResult',
    'GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult',
    'GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult',
    'GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult',
    'GetAlbLoadBalancerListenerHttpResult',
    'GetAlbLoadBalancerListenerHttpHandlerResult',
    'GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult',
    'GetAlbLoadBalancerListenerHttpRedirectResult',
    'GetAlbLoadBalancerListenerStreamResult',
    'GetAlbLoadBalancerListenerStreamHandlerResult',
    'GetAlbLoadBalancerListenerTlResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult',
    'GetAlbTargetGroupTargetResult',
    'GetAlbVirtualHostModifyRequestHeaderResult',
    'GetAlbVirtualHostModifyResponseHeaderResult',
    'GetAlbVirtualHostRouteResult',
    'GetAlbVirtualHostRouteGrpcRouteResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult',
    'GetAlbVirtualHostRouteHttpRouteResult',
    'GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult',
    'GetAlbVirtualHostRouteHttpRouteHttpMatchResult',
    'GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult',
    'GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult',
    'GetAlbVirtualHostRouteHttpRouteRedirectActionResult',
    'GetCdnOriginGroupOriginResult',
    'GetCdnResourceOptionsResult',
    'GetCdnResourceSslCertificateResult',
    'GetComputeDiskDiskPlacementPolicyResult',
    'GetComputeInstanceBootDiskResult',
    'GetComputeInstanceBootDiskInitializeParamResult',
    'GetComputeInstanceGroupAllocationPolicyResult',
    'GetComputeInstanceGroupApplicationBalancerStateResult',
    'GetComputeInstanceGroupApplicationLoadBalancerResult',
    'GetComputeInstanceGroupDeployPolicyResult',
    'GetComputeInstanceGroupHealthCheckResult',
    'GetComputeInstanceGroupHealthCheckHttpOptionResult',
    'GetComputeInstanceGroupHealthCheckTcpOptionResult',
    'GetComputeInstanceGroupInstanceResult',
    'GetComputeInstanceGroupInstanceNetworkInterfaceResult',
    'GetComputeInstanceGroupInstanceTemplateResult',
    'GetComputeInstanceGroupInstanceTemplateBootDiskResult',
    'GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkSettingResult',
    'GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult',
    'GetComputeInstanceGroupInstanceTemplateResourceResult',
    'GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult',
    'GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult',
    'GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult',
    'GetComputeInstanceGroupLoadBalancerResult',
    'GetComputeInstanceGroupLoadBalancerStateResult',
    'GetComputeInstanceGroupScalePolicyResult',
    'GetComputeInstanceGroupScalePolicyAutoScaleResult',
    'GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult',
    'GetComputeInstanceGroupScalePolicyFixedScaleResult',
    'GetComputeInstanceGroupScalePolicyTestAutoScaleResult',
    'GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult',
    'GetComputeInstanceNetworkInterfaceResult',
    'GetComputeInstanceNetworkInterfaceDnsRecordResult',
    'GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult',
    'GetComputeInstanceNetworkInterfaceNatDnsRecordResult',
    'GetComputeInstancePlacementPolicyResult',
    'GetComputeInstanceResourceResult',
    'GetComputeInstanceSchedulingPolicyResult',
    'GetComputeInstanceSecondaryDiskResult',
    'GetDataprocClusterClusterConfigResult',
    'GetDataprocClusterClusterConfigHadoopResult',
    'GetDataprocClusterClusterConfigSubclusterSpecResult',
    'GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult',
    'GetDataprocClusterClusterConfigSubclusterSpecResourceResult',
    'GetFunctionScalingPolicyPolicyResult',
    'GetFunctionTriggerDlqResult',
    'GetFunctionTriggerFunctionResult',
    'GetFunctionTriggerIotResult',
    'GetFunctionTriggerLogGroupResult',
    'GetFunctionTriggerLoggingResult',
    'GetFunctionTriggerMessageQueueResult',
    'GetFunctionTriggerObjectStorageResult',
    'GetFunctionTriggerTimerResult',
    'GetIamPolicyBindingResult',
    'GetKubernetesClusterKmsProviderResult',
    'GetKubernetesClusterMasterResult',
    'GetKubernetesClusterMasterMaintenancePolicyResult',
    'GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult',
    'GetKubernetesClusterMasterRegionalResult',
    'GetKubernetesClusterMasterVersionInfoResult',
    'GetKubernetesClusterMasterZonalResult',
    'GetKubernetesClusterNetworkImplementationResult',
    'GetKubernetesClusterNetworkImplementationCiliaResult',
    'GetKubernetesNodeGroupAllocationPolicyResult',
    'GetKubernetesNodeGroupAllocationPolicyLocationResult',
    'GetKubernetesNodeGroupDeployPolicyResult',
    'GetKubernetesNodeGroupInstanceTemplateResult',
    'GetKubernetesNodeGroupInstanceTemplateBootDiskResult',
    'GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult',
    'GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult',
    'GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult',
    'GetKubernetesNodeGroupInstanceTemplateResourceResult',
    'GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult',
    'GetKubernetesNodeGroupMaintenancePolicyResult',
    'GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult',
    'GetKubernetesNodeGroupScalePolicyResult',
    'GetKubernetesNodeGroupScalePolicyAutoScaleResult',
    'GetKubernetesNodeGroupScalePolicyFixedScaleResult',
    'GetKubernetesNodeGroupVersionInfoResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult',
    'GetLbNetworkLoadBalancerListenerResult',
    'GetLbNetworkLoadBalancerListenerExternalAddressSpecResult',
    'GetLbNetworkLoadBalancerListenerInternalAddressSpecResult',
    'GetLbTargetGroupTargetResult',
    'GetMdbClickhouseClusterAccessResult',
    'GetMdbClickhouseClusterBackupWindowStartResult',
    'GetMdbClickhouseClusterClickhouseResult',
    'GetMdbClickhouseClusterClickhouseConfigResult',
    'GetMdbClickhouseClusterClickhouseConfigCompressionResult',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult',
    'GetMdbClickhouseClusterClickhouseConfigKafkaResult',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult',
    'GetMdbClickhouseClusterClickhouseConfigMergeTreeResult',
    'GetMdbClickhouseClusterClickhouseConfigRabbitmqResult',
    'GetMdbClickhouseClusterClickhouseResourceResult',
    'GetMdbClickhouseClusterCloudStorageResult',
    'GetMdbClickhouseClusterDatabaseResult',
    'GetMdbClickhouseClusterFormatSchemaResult',
    'GetMdbClickhouseClusterHostResult',
    'GetMdbClickhouseClusterMaintenanceWindowResult',
    'GetMdbClickhouseClusterMlModelResult',
    'GetMdbClickhouseClusterShardGroupResult',
    'GetMdbClickhouseClusterUserResult',
    'GetMdbClickhouseClusterUserPermissionResult',
    'GetMdbClickhouseClusterUserQuotaResult',
    'GetMdbClickhouseClusterUserSettingsResult',
    'GetMdbClickhouseClusterZookeeperResult',
    'GetMdbClickhouseClusterZookeeperResourceResult',
    'GetMdbElasticSearchClusterConfigResult',
    'GetMdbElasticSearchClusterConfigDataNodeResult',
    'GetMdbElasticSearchClusterConfigDataNodeResourceResult',
    'GetMdbElasticSearchClusterConfigMasterNodeResult',
    'GetMdbElasticSearchClusterConfigMasterNodeResourceResult',
    'GetMdbElasticSearchClusterHostResult',
    'GetMdbElasticSearchClusterMaintenanceWindowResult',
    'GetMdbGreenplumClusterAccessResult',
    'GetMdbGreenplumClusterBackupWindowStartResult',
    'GetMdbGreenplumClusterMasterHostResult',
    'GetMdbGreenplumClusterMasterSubclusterResult',
    'GetMdbGreenplumClusterMasterSubclusterResourceResult',
    'GetMdbGreenplumClusterSegmentHostResult',
    'GetMdbGreenplumClusterSegmentSubclusterResult',
    'GetMdbGreenplumClusterSegmentSubclusterResourceResult',
    'GetMdbKafkaClusterConfigResult',
    'GetMdbKafkaClusterConfigKafkaResult',
    'GetMdbKafkaClusterConfigKafkaKafkaConfigResult',
    'GetMdbKafkaClusterConfigKafkaResourcesResult',
    'GetMdbKafkaClusterConfigZookeeperResult',
    'GetMdbKafkaClusterConfigZookeeperResourcesResult',
    'GetMdbKafkaClusterHostResult',
    'GetMdbKafkaClusterMaintenanceWindowResult',
    'GetMdbKafkaClusterTopicResult',
    'GetMdbKafkaClusterTopicTopicConfigResult',
    'GetMdbKafkaClusterUserResult',
    'GetMdbKafkaClusterUserPermissionResult',
    'GetMdbKafkaTopicTopicConfigResult',
    'GetMdbMongodbClusterClusterConfigResult',
    'GetMdbMongodbClusterClusterConfigAccessResult',
    'GetMdbMongodbClusterClusterConfigBackupWindowStartResult',
    'GetMdbMongodbClusterDatabaseResult',
    'GetMdbMongodbClusterHostResult',
    'GetMdbMongodbClusterMaintenanceWindowResult',
    'GetMdbMongodbClusterResourceResult',
    'GetMdbMongodbClusterUserResult',
    'GetMdbMongodbClusterUserPermissionResult',
    'GetMdbMysqlClusterAccessResult',
    'GetMdbMysqlClusterBackupWindowStartResult',
    'GetMdbMysqlClusterDatabaseResult',
    'GetMdbMysqlClusterHostResult',
    'GetMdbMysqlClusterMaintenanceWindowResult',
    'GetMdbMysqlClusterResourceResult',
    'GetMdbMysqlClusterUserResult',
    'GetMdbMysqlClusterUserConnectionLimitResult',
    'GetMdbMysqlClusterUserPermissionResult',
    'GetMdbPostgresqlClusterConfigResult',
    'GetMdbPostgresqlClusterConfigAccessResult',
    'GetMdbPostgresqlClusterConfigBackupWindowStartResult',
    'GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult',
    'GetMdbPostgresqlClusterConfigPoolerConfigResult',
    'GetMdbPostgresqlClusterConfigResourceResult',
    'GetMdbPostgresqlClusterDatabaseResult',
    'GetMdbPostgresqlClusterDatabaseExtensionResult',
    'GetMdbPostgresqlClusterHostResult',
    'GetMdbPostgresqlClusterMaintenanceWindowResult',
    'GetMdbPostgresqlClusterUserResult',
    'GetMdbPostgresqlClusterUserPermissionResult',
    'GetMdbRedisClusterConfigResult',
    'GetMdbRedisClusterHostResult',
    'GetMdbRedisClusterMaintenanceWindowResult',
    'GetMdbRedisClusterResourceResult',
    'GetMdbSqlserverClusterBackupWindowStartResult',
    'GetMdbSqlserverClusterDatabaseResult',
    'GetMdbSqlserverClusterHostResult',
    'GetMdbSqlserverClusterResourceResult',
    'GetMdbSqlserverClusterUserResult',
    'GetMdbSqlserverClusterUserPermissionResult',
    'GetServerlessContainerImageResult',
    'GetVpcAddressExternalIpv4AddressResult',
    'GetVpcRouteTableStaticRouteResult',
    'GetVpcSecurityGroupEgressResult',
    'GetVpcSecurityGroupIngressResult',
    'GetVpcSubnetDhcpOptionResult',
    'GetYdbDatabaseDedicatedLocationResult',
    'GetYdbDatabaseDedicatedLocationRegionResult',
    'GetYdbDatabaseDedicatedLocationZoneResult',
    'GetYdbDatabaseDedicatedScalePolicyResult',
    'GetYdbDatabaseDedicatedScalePolicyFixedScaleResult',
    'GetYdbDatabaseDedicatedStorageConfigResult',
]

@pulumi.output_type
class AlbBackendGroupGrpcBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupIds":
            suggest = "target_group_ids"
        elif key == "loadBalancingConfig":
            suggest = "load_balancing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 target_group_ids: Sequence[str],
                 healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheck'] = None,
                 load_balancing_config: Optional['outputs.AlbBackendGroupGrpcBackendLoadBalancingConfig'] = None,
                 port: Optional[int] = None,
                 tls: Optional['outputs.AlbBackendGroupGrpcBackendTls'] = None,
                 weight: Optional[int] = None):
        """
        :param str name: Name of the backend.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'AlbBackendGroupGrpcBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param 'AlbBackendGroupGrpcBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param int port: Port for incoming traffic.
        :param 'AlbBackendGroupGrpcBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheck']:
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional['outputs.AlbBackendGroupGrpcBackendLoadBalancingConfig']:
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbBackendGroupGrpcBackendTls']:
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcHealthcheck":
            suggest = "grpc_healthcheck"
        elif key == "healthcheckPort":
            suggest = "healthcheck_port"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpHealthcheck":
            suggest = "http_healthcheck"
        elif key == "intervalJitterPercent":
            suggest = "interval_jitter_percent"
        elif key == "streamHealthcheck":
            suggest = "stream_healthcheck"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: str,
                 timeout: str,
                 grpc_healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck'] = None,
                 healthcheck_port: Optional[int] = None,
                 healthy_threshold: Optional[int] = None,
                 http_healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck'] = None,
                 interval_jitter_percent: Optional[float] = None,
                 stream_healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck'] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param str interval: Interval between health checks.
        :param str timeout: Time to wait for a health check response.
        :param 'AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck']:
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[int]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck']:
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[float]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck']:
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: Optional[str] = None):
        """
        :param str service_name: Service name for grpc.health.v1.HealthCheckRequest message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck(dict):
    def __init__(__self__, *,
                 path: str,
                 host: Optional[str] = None,
                 http2: Optional[bool] = None):
        """
        :param str path: HTTP path.
        :param str host: "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http2(self) -> Optional[bool]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck(dict):
    def __init__(__self__, *,
                 receive: Optional[str] = None,
                 send: Optional[str] = None):
        """
        :param str receive: Text to search in reply.
        :param str send: Message to send. If empty, it's a connect-only health check.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> Optional[str]:
        """
        Text to search in reply.
        """
        return pulumi.get(self, "receive")

    @property
    @pulumi.getter
    def send(self) -> Optional[str]:
        """
        Message to send. If empty, it's a connect-only health check.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class AlbBackendGroupGrpcBackendLoadBalancingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localityAwareRoutingPercent":
            suggest = "locality_aware_routing_percent"
        elif key == "panicThreshold":
            suggest = "panic_threshold"
        elif key == "strictLocality":
            suggest = "strict_locality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendLoadBalancingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendLoadBalancingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendLoadBalancingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[int] = None,
                 panic_threshold: Optional[int] = None,
                 strict_locality: Optional[bool] = None):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[int]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[int]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[bool]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class AlbBackendGroupGrpcBackendTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationContext":
            suggest = "validation_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sni: Optional[str] = None,
                 validation_context: Optional['outputs.AlbBackendGroupGrpcBackendTlsValidationContext'] = None):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional['outputs.AlbBackendGroupGrpcBackendTlsValidationContext']:
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class AlbBackendGroupGrpcBackendTlsValidationContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaBytes":
            suggest = "trusted_ca_bytes"
        elif key == "trustedCaId":
            suggest = "trusted_ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendTlsValidationContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendTlsValidationContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendTlsValidationContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[str] = None,
                 trusted_ca_id: Optional[str] = None):
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[str]:
        return pulumi.get(self, "trusted_ca_bytes")

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[str]:
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class AlbBackendGroupHttpBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupIds":
            suggest = "target_group_ids"
        elif key == "loadBalancingConfig":
            suggest = "load_balancing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 target_group_ids: Sequence[str],
                 healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheck'] = None,
                 http2: Optional[bool] = None,
                 load_balancing_config: Optional['outputs.AlbBackendGroupHttpBackendLoadBalancingConfig'] = None,
                 port: Optional[int] = None,
                 tls: Optional['outputs.AlbBackendGroupHttpBackendTls'] = None,
                 weight: Optional[int] = None):
        """
        :param str name: Name of the backend.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'AlbBackendGroupHttpBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param bool http2: If set, health checks will use HTTP2.
        :param 'AlbBackendGroupHttpBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param int port: Port for incoming traffic.
        :param 'AlbBackendGroupHttpBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheck']:
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter
    def http2(self) -> Optional[bool]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional['outputs.AlbBackendGroupHttpBackendLoadBalancingConfig']:
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbBackendGroupHttpBackendTls']:
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcHealthcheck":
            suggest = "grpc_healthcheck"
        elif key == "healthcheckPort":
            suggest = "healthcheck_port"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpHealthcheck":
            suggest = "http_healthcheck"
        elif key == "intervalJitterPercent":
            suggest = "interval_jitter_percent"
        elif key == "streamHealthcheck":
            suggest = "stream_healthcheck"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: str,
                 timeout: str,
                 grpc_healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck'] = None,
                 healthcheck_port: Optional[int] = None,
                 healthy_threshold: Optional[int] = None,
                 http_healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck'] = None,
                 interval_jitter_percent: Optional[float] = None,
                 stream_healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck'] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param str interval: Interval between health checks.
        :param str timeout: Time to wait for a health check response.
        :param 'AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck']:
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[int]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck']:
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[float]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck']:
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: Optional[str] = None):
        """
        :param str service_name: Service name for grpc.health.v1.HealthCheckRequest message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck(dict):
    def __init__(__self__, *,
                 path: str,
                 host: Optional[str] = None,
                 http2: Optional[bool] = None):
        """
        :param str path: HTTP path.
        :param str host: "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http2(self) -> Optional[bool]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck(dict):
    def __init__(__self__, *,
                 receive: Optional[str] = None,
                 send: Optional[str] = None):
        """
        :param str receive: Text to search in reply.
        :param str send: Message to send. If empty, it's a connect-only health check.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> Optional[str]:
        """
        Text to search in reply.
        """
        return pulumi.get(self, "receive")

    @property
    @pulumi.getter
    def send(self) -> Optional[str]:
        """
        Message to send. If empty, it's a connect-only health check.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class AlbBackendGroupHttpBackendLoadBalancingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localityAwareRoutingPercent":
            suggest = "locality_aware_routing_percent"
        elif key == "panicThreshold":
            suggest = "panic_threshold"
        elif key == "strictLocality":
            suggest = "strict_locality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendLoadBalancingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendLoadBalancingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendLoadBalancingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[int] = None,
                 panic_threshold: Optional[int] = None,
                 strict_locality: Optional[bool] = None):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[int]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[int]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[bool]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class AlbBackendGroupHttpBackendTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationContext":
            suggest = "validation_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sni: Optional[str] = None,
                 validation_context: Optional['outputs.AlbBackendGroupHttpBackendTlsValidationContext'] = None):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional['outputs.AlbBackendGroupHttpBackendTlsValidationContext']:
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class AlbBackendGroupHttpBackendTlsValidationContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaBytes":
            suggest = "trusted_ca_bytes"
        elif key == "trustedCaId":
            suggest = "trusted_ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendTlsValidationContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendTlsValidationContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendTlsValidationContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[str] = None,
                 trusted_ca_id: Optional[str] = None):
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[str]:
        return pulumi.get(self, "trusted_ca_bytes")

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[str]:
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class AlbBackendGroupStreamBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupIds":
            suggest = "target_group_ids"
        elif key == "loadBalancingConfig":
            suggest = "load_balancing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 target_group_ids: Sequence[str],
                 healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheck'] = None,
                 load_balancing_config: Optional['outputs.AlbBackendGroupStreamBackendLoadBalancingConfig'] = None,
                 port: Optional[int] = None,
                 tls: Optional['outputs.AlbBackendGroupStreamBackendTls'] = None,
                 weight: Optional[int] = None):
        """
        :param str name: Name of the backend.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'AlbBackendGroupStreamBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param 'AlbBackendGroupStreamBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param int port: Port for incoming traffic.
        :param 'AlbBackendGroupStreamBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheck']:
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional['outputs.AlbBackendGroupStreamBackendLoadBalancingConfig']:
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbBackendGroupStreamBackendTls']:
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcHealthcheck":
            suggest = "grpc_healthcheck"
        elif key == "healthcheckPort":
            suggest = "healthcheck_port"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpHealthcheck":
            suggest = "http_healthcheck"
        elif key == "intervalJitterPercent":
            suggest = "interval_jitter_percent"
        elif key == "streamHealthcheck":
            suggest = "stream_healthcheck"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: str,
                 timeout: str,
                 grpc_healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck'] = None,
                 healthcheck_port: Optional[int] = None,
                 healthy_threshold: Optional[int] = None,
                 http_healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck'] = None,
                 interval_jitter_percent: Optional[float] = None,
                 stream_healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck'] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param str interval: Interval between health checks.
        :param str timeout: Time to wait for a health check response.
        :param 'AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck']:
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[int]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck']:
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[float]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck']:
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: Optional[str] = None):
        """
        :param str service_name: Service name for grpc.health.v1.HealthCheckRequest message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck(dict):
    def __init__(__self__, *,
                 path: str,
                 host: Optional[str] = None,
                 http2: Optional[bool] = None):
        """
        :param str path: HTTP path.
        :param str host: "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http2(self) -> Optional[bool]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck(dict):
    def __init__(__self__, *,
                 receive: Optional[str] = None,
                 send: Optional[str] = None):
        """
        :param str receive: Text to search in reply.
        :param str send: Message to send. If empty, it's a connect-only health check.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> Optional[str]:
        """
        Text to search in reply.
        """
        return pulumi.get(self, "receive")

    @property
    @pulumi.getter
    def send(self) -> Optional[str]:
        """
        Message to send. If empty, it's a connect-only health check.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class AlbBackendGroupStreamBackendLoadBalancingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localityAwareRoutingPercent":
            suggest = "locality_aware_routing_percent"
        elif key == "panicThreshold":
            suggest = "panic_threshold"
        elif key == "strictLocality":
            suggest = "strict_locality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendLoadBalancingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendLoadBalancingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendLoadBalancingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[int] = None,
                 panic_threshold: Optional[int] = None,
                 strict_locality: Optional[bool] = None):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[int]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[int]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[bool]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class AlbBackendGroupStreamBackendTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationContext":
            suggest = "validation_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sni: Optional[str] = None,
                 validation_context: Optional['outputs.AlbBackendGroupStreamBackendTlsValidationContext'] = None):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - (Optional) Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - (Optional) PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional['outputs.AlbBackendGroupStreamBackendTlsValidationContext']:
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class AlbBackendGroupStreamBackendTlsValidationContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaBytes":
            suggest = "trusted_ca_bytes"
        elif key == "trustedCaId":
            suggest = "trusted_ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendTlsValidationContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendTlsValidationContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendTlsValidationContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[str] = None,
                 trusted_ca_id: Optional[str] = None):
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[str]:
        return pulumi.get(self, "trusted_ca_bytes")

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[str]:
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class AlbLoadBalancerAllocationPolicy(dict):
    def __init__(__self__, *,
                 locations: Sequence['outputs.AlbLoadBalancerAllocationPolicyLocation']):
        """
        :param Sequence['AlbLoadBalancerAllocationPolicyLocationArgs'] locations: Unique set of locations. The structure is documented below.
        """
        pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.AlbLoadBalancerAllocationPolicyLocation']:
        """
        Unique set of locations. The structure is documented below.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class AlbLoadBalancerAllocationPolicyLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "disableTraffic":
            suggest = "disable_traffic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerAllocationPolicyLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerAllocationPolicyLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerAllocationPolicyLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 zone_id: str,
                 disable_traffic: Optional[bool] = None):
        """
        :param str subnet_id: Provided by the client or computed automatically.
        :param str zone_id: ID of the zone that location is located at.
        :param bool disable_traffic: If set, will disable all L7 instances in the zone for request handling.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if disable_traffic is not None:
            pulumi.set(__self__, "disable_traffic", disable_traffic)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        ID of the zone that location is located at.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="disableTraffic")
    def disable_traffic(self) -> Optional[bool]:
        """
        If set, will disable all L7 instances in the zone for request handling.
        """
        return pulumi.get(self, "disable_traffic")


@pulumi.output_type
class AlbLoadBalancerListener(dict):
    def __init__(__self__, *,
                 name: str,
                 endpoints: Optional[Sequence['outputs.AlbLoadBalancerListenerEndpoint']] = None,
                 http: Optional['outputs.AlbLoadBalancerListenerHttp'] = None,
                 stream: Optional['outputs.AlbLoadBalancerListenerStream'] = None,
                 tls: Optional['outputs.AlbLoadBalancerListenerTls'] = None):
        """
        :param str name: name of SNI match.
        :param Sequence['AlbLoadBalancerListenerEndpointArgs'] endpoints: Network endpoints (addresses and ports) of the listener. The structure is documented below.
        :param 'AlbLoadBalancerListenerHttpArgs' http: HTTP listener resource. The structure is documented below.
        :param 'AlbLoadBalancerListenerStreamArgs' stream: Stream listener resource. The structure is documented below.
        :param 'AlbLoadBalancerListenerTlsArgs' tls: TLS listener resource. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of SNI match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AlbLoadBalancerListenerEndpoint']]:
        """
        Network endpoints (addresses and ports) of the listener. The structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.AlbLoadBalancerListenerHttp']:
        """
        HTTP listener resource. The structure is documented below.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def stream(self) -> Optional['outputs.AlbLoadBalancerListenerStream']:
        """
        Stream listener resource. The structure is documented below.
        """
        return pulumi.get(self, "stream")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbLoadBalancerListenerTls']:
        """
        TLS listener resource. The structure is documented below.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class AlbLoadBalancerListenerEndpoint(dict):
    def __init__(__self__, *,
                 addresses: Sequence['outputs.AlbLoadBalancerListenerEndpointAddress'],
                 ports: Sequence[int]):
        """
        :param Sequence['AlbLoadBalancerListenerEndpointAddressArgs'] addresses: Provided by the client or computed automatically.
        :param Sequence[int] ports: One or more ports to listen on.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence['outputs.AlbLoadBalancerListenerEndpointAddress']:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        One or more ports to listen on.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIpv4Address":
            suggest = "external_ipv4_address"
        elif key == "externalIpv6Address":
            suggest = "external_ipv6_address"
        elif key == "internalIpv4Address":
            suggest = "internal_ipv4_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerEndpointAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerEndpointAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerEndpointAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_ipv4_address: Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv4Address'] = None,
                 external_ipv6_address: Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv6Address'] = None,
                 internal_ipv4_address: Optional['outputs.AlbLoadBalancerListenerEndpointAddressInternalIpv4Address'] = None):
        """
        :param 'AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs' external_ipv4_address: External IPv4 address. The structure is documented below.
        :param 'AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs' external_ipv6_address: External IPv6 address. The structure is documented below.
        :param 'AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs' internal_ipv4_address: Internal IPv4 address. The structure is documented below.
        """
        if external_ipv4_address is not None:
            pulumi.set(__self__, "external_ipv4_address", external_ipv4_address)
        if external_ipv6_address is not None:
            pulumi.set(__self__, "external_ipv6_address", external_ipv6_address)
        if internal_ipv4_address is not None:
            pulumi.set(__self__, "internal_ipv4_address", internal_ipv4_address)

    @property
    @pulumi.getter(name="externalIpv4Address")
    def external_ipv4_address(self) -> Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv4Address']:
        """
        External IPv4 address. The structure is documented below.
        """
        return pulumi.get(self, "external_ipv4_address")

    @property
    @pulumi.getter(name="externalIpv6Address")
    def external_ipv6_address(self) -> Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv6Address']:
        """
        External IPv6 address. The structure is documented below.
        """
        return pulumi.get(self, "external_ipv6_address")

    @property
    @pulumi.getter(name="internalIpv4Address")
    def internal_ipv4_address(self) -> Optional['outputs.AlbLoadBalancerListenerEndpointAddressInternalIpv4Address']:
        """
        Internal IPv4 address. The structure is documented below.
        """
        return pulumi.get(self, "internal_ipv4_address")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddressExternalIpv4Address(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None):
        """
        :param str address: Provided by the client or computed automatically.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddressExternalIpv6Address(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None):
        """
        :param str address: Provided by the client or computed automatically.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddressInternalIpv4Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerEndpointAddressInternalIpv4Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerEndpointAddressInternalIpv4Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerEndpointAddressInternalIpv4Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str address: Provided by the client or computed automatically.
        :param str subnet_id: Provided by the client or computed automatically.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AlbLoadBalancerListenerHttp(dict):
    def __init__(__self__, *,
                 handler: Optional['outputs.AlbLoadBalancerListenerHttpHandler'] = None,
                 redirects: Optional['outputs.AlbLoadBalancerListenerHttpRedirects'] = None):
        """
        :param 'AlbLoadBalancerListenerHttpHandlerArgs' handler: HTTP handler that sets plaintext HTTP router. The structure is documented below.
        :param 'AlbLoadBalancerListenerHttpRedirectsArgs' redirects: Shortcut for adding http > https redirects. The structure is documented below.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def handler(self) -> Optional['outputs.AlbLoadBalancerListenerHttpHandler']:
        """
        HTTP handler that sets plaintext HTTP router. The structure is documented below.
        """
        return pulumi.get(self, "handler")

    @property
    @pulumi.getter
    def redirects(self) -> Optional['outputs.AlbLoadBalancerListenerHttpRedirects']:
        """
        Shortcut for adding http > https redirects. The structure is documented below.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class AlbLoadBalancerListenerHttpHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowHttp10":
            suggest = "allow_http10"
        elif key == "http2Options":
            suggest = "http2_options"
        elif key == "httpRouterId":
            suggest = "http_router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerHttpHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerHttpHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerHttpHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_http10: Optional[bool] = None,
                 http2_options: Optional['outputs.AlbLoadBalancerListenerHttpHandlerHttp2Options'] = None,
                 http_router_id: Optional[str] = None):
        """
        :param bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        :param 'AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs' http2_options: If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        :param str http_router_id: HTTP router id.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional['outputs.AlbLoadBalancerListenerHttpHandlerHttp2Options']:
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        return pulumi.get(self, "http2_options")

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[str]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")


@pulumi.output_type
class AlbLoadBalancerListenerHttpHandlerHttp2Options(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentStreams":
            suggest = "max_concurrent_streams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerHttpHandlerHttp2Options. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerHttpHandlerHttp2Options.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerHttpHandlerHttp2Options.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_streams: Optional[int] = None):
        """
        :param int max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[int]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class AlbLoadBalancerListenerHttpRedirects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpToHttps":
            suggest = "http_to_https"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerHttpRedirects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerHttpRedirects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerHttpRedirects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_to_https: Optional[bool] = None):
        if http_to_https is not None:
            pulumi.set(__self__, "http_to_https", http_to_https)

    @property
    @pulumi.getter(name="httpToHttps")
    def http_to_https(self) -> Optional[bool]:
        return pulumi.get(self, "http_to_https")


@pulumi.output_type
class AlbLoadBalancerListenerStream(dict):
    def __init__(__self__, *,
                 handler: Optional['outputs.AlbLoadBalancerListenerStreamHandler'] = None):
        """
        :param 'AlbLoadBalancerListenerStreamHandlerArgs' handler: HTTP handler that sets plaintext HTTP router. The structure is documented below.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)

    @property
    @pulumi.getter
    def handler(self) -> Optional['outputs.AlbLoadBalancerListenerStreamHandler']:
        """
        HTTP handler that sets plaintext HTTP router. The structure is documented below.
        """
        return pulumi.get(self, "handler")


@pulumi.output_type
class AlbLoadBalancerListenerStreamHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerStreamHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerStreamHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerStreamHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: Optional[str] = None):
        """
        :param str backend_group_id: Backend group id.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[str]:
        """
        Backend group id.
        """
        return pulumi.get(self, "backend_group_id")


@pulumi.output_type
class AlbLoadBalancerListenerTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultHandler":
            suggest = "default_handler"
        elif key == "sniHandlers":
            suggest = "sni_handlers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_handler: 'outputs.AlbLoadBalancerListenerTlsDefaultHandler',
                 sni_handlers: Optional[Sequence['outputs.AlbLoadBalancerListenerTlsSniHandler']] = None):
        """
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerArgs' default_handler: TLS handler resource. The structure is documented below.
        :param Sequence['AlbLoadBalancerListenerTlsSniHandlerArgs'] sni_handlers: SNI match resource. The structure is documented below.
        """
        pulumi.set(__self__, "default_handler", default_handler)
        if sni_handlers is not None:
            pulumi.set(__self__, "sni_handlers", sni_handlers)

    @property
    @pulumi.getter(name="defaultHandler")
    def default_handler(self) -> 'outputs.AlbLoadBalancerListenerTlsDefaultHandler':
        """
        TLS handler resource. The structure is documented below.
        """
        return pulumi.get(self, "default_handler")

    @property
    @pulumi.getter(name="sniHandlers")
    def sni_handlers(self) -> Optional[Sequence['outputs.AlbLoadBalancerListenerTlsSniHandler']]:
        """
        SNI match resource. The structure is documented below.
        """
        return pulumi.get(self, "sni_handlers")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateIds":
            suggest = "certificate_ids"
        elif key == "httpHandler":
            suggest = "http_handler"
        elif key == "streamHandler":
            suggest = "stream_handler"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_ids: Sequence[str],
                 http_handler: Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler'] = None,
                 stream_handler: Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler'] = None):
        """
        :param Sequence[str] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated
               with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs' http_handler: HTTP handler resource. The structure is documented below.
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs' stream_handler: Stream handler resource. The structure is documented below.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handler is not None:
            pulumi.set(__self__, "http_handler", http_handler)
        if stream_handler is not None:
            pulumi.set(__self__, "stream_handler", stream_handler)

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[str]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated
        with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        """
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter(name="httpHandler")
    def http_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler']:
        """
        HTTP handler resource. The structure is documented below.
        """
        return pulumi.get(self, "http_handler")

    @property
    @pulumi.getter(name="streamHandler")
    def stream_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler']:
        """
        Stream handler resource. The structure is documented below.
        """
        return pulumi.get(self, "stream_handler")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowHttp10":
            suggest = "allow_http10"
        elif key == "http2Options":
            suggest = "http2_options"
        elif key == "httpRouterId":
            suggest = "http_router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_http10: Optional[bool] = None,
                 http2_options: Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options'] = None,
                 http_router_id: Optional[str] = None):
        """
        :param bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs' http2_options: If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        :param str http_router_id: HTTP router id.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options']:
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        return pulumi.get(self, "http2_options")

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[str]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentStreams":
            suggest = "max_concurrent_streams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_streams: Optional[int] = None):
        """
        :param int max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[int]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: Optional[str] = None):
        """
        :param str backend_group_id: Backend group id.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[str]:
        """
        Backend group id.
        """
        return pulumi.get(self, "backend_group_id")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverNames":
            suggest = "server_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 handler: 'outputs.AlbLoadBalancerListenerTlsSniHandlerHandler',
                 name: str,
                 server_names: Sequence[str]):
        """
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerArgs' handler: HTTP handler that sets plaintext HTTP router. The structure is documented below.
        :param str name: name of SNI match.
        :param Sequence[str] server_names: A set of server names.
        """
        pulumi.set(__self__, "handler", handler)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_names", server_names)

    @property
    @pulumi.getter
    def handler(self) -> 'outputs.AlbLoadBalancerListenerTlsSniHandlerHandler':
        """
        HTTP handler that sets plaintext HTTP router. The structure is documented below.
        """
        return pulumi.get(self, "handler")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of SNI match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverNames")
    def server_names(self) -> Sequence[str]:
        """
        A set of server names.
        """
        return pulumi.get(self, "server_names")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateIds":
            suggest = "certificate_ids"
        elif key == "httpHandler":
            suggest = "http_handler"
        elif key == "streamHandler":
            suggest = "stream_handler"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_ids: Sequence[str],
                 http_handler: Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler'] = None,
                 stream_handler: Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler'] = None):
        """
        :param Sequence[str] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated
               with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs' http_handler: HTTP handler resource. The structure is documented below.
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs' stream_handler: Stream handler resource. The structure is documented below.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handler is not None:
            pulumi.set(__self__, "http_handler", http_handler)
        if stream_handler is not None:
            pulumi.set(__self__, "stream_handler", stream_handler)

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[str]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated
        with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        """
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter(name="httpHandler")
    def http_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler']:
        """
        HTTP handler resource. The structure is documented below.
        """
        return pulumi.get(self, "http_handler")

    @property
    @pulumi.getter(name="streamHandler")
    def stream_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler']:
        """
        Stream handler resource. The structure is documented below.
        """
        return pulumi.get(self, "stream_handler")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowHttp10":
            suggest = "allow_http10"
        elif key == "http2Options":
            suggest = "http2_options"
        elif key == "httpRouterId":
            suggest = "http_router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_http10: Optional[bool] = None,
                 http2_options: Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options'] = None,
                 http_router_id: Optional[str] = None):
        """
        :param bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs' http2_options: If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        :param str http_router_id: HTTP router id.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options']:
        """
        If set, will enable HTTP2 protocol for the handler. The structure is documented below.
        """
        return pulumi.get(self, "http2_options")

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[str]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentStreams":
            suggest = "max_concurrent_streams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_streams: Optional[int] = None):
        """
        :param int max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[int]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: Optional[str] = None):
        """
        :param str backend_group_id: Backend group id.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[str]:
        """
        Backend group id.
        """
        return pulumi.get(self, "backend_group_id")


@pulumi.output_type
class AlbTargetGroupTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "privateIpv4Address":
            suggest = "private_ipv4_address"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbTargetGroupTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbTargetGroupTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbTargetGroupTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 private_ipv4_address: Optional[bool] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str ip_address: IP address of the target.
        :param str subnet_id: ID of the subnet that targets are connected to.
               All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if private_ipv4_address is not None:
            pulumi.set(__self__, "private_ipv4_address", private_ipv4_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP address of the target.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="privateIpv4Address")
    def private_ipv4_address(self) -> Optional[bool]:
        return pulumi.get(self, "private_ipv4_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        ID of the subnet that targets are connected to.
        All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AlbVirtualHostModifyRequestHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 append: Optional[str] = None,
                 remove: Optional[bool] = None,
                 replace: Optional[str] = None):
        """
        :param str name: name of the route.
        :param str append: Append string to the header value.
        :param bool remove: If set, remove the header.
        :param str replace: New value for a header. Header values support the following 
               [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "name", name)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of the route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def append(self) -> Optional[str]:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @property
    @pulumi.getter
    def remove(self) -> Optional[bool]:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def replace(self) -> Optional[str]:
        """
        New value for a header. Header values support the following 
        [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class AlbVirtualHostModifyResponseHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 append: Optional[str] = None,
                 remove: Optional[bool] = None,
                 replace: Optional[str] = None):
        """
        :param str name: name of the route.
        :param str append: Append string to the header value.
        :param bool remove: If set, remove the header.
        :param str replace: New value for a header. Header values support the following 
               [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "name", name)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of the route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def append(self) -> Optional[str]:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @property
    @pulumi.getter
    def remove(self) -> Optional[bool]:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def replace(self) -> Optional[str]:
        """
        New value for a header. Header values support the following 
        [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class AlbVirtualHostRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcRoute":
            suggest = "grpc_route"
        elif key == "httpRoute":
            suggest = "http_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_route: Optional['outputs.AlbVirtualHostRouteGrpcRoute'] = None,
                 http_route: Optional['outputs.AlbVirtualHostRouteHttpRoute'] = None,
                 name: Optional[str] = None):
        """
        :param 'AlbVirtualHostRouteGrpcRouteArgs' grpc_route: GRPC route resource. The structure is documented below.
        :param 'AlbVirtualHostRouteHttpRouteArgs' http_route: HTTP route resource. The structure is documented below.
        :param str name: name of the route.
        """
        if grpc_route is not None:
            pulumi.set(__self__, "grpc_route", grpc_route)
        if http_route is not None:
            pulumi.set(__self__, "http_route", http_route)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="grpcRoute")
    def grpc_route(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRoute']:
        """
        GRPC route resource. The structure is documented below.
        """
        return pulumi.get(self, "grpc_route")

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> Optional['outputs.AlbVirtualHostRouteHttpRoute']:
        """
        HTTP route resource. The structure is documented below.
        """
        return pulumi.get(self, "http_route")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        name of the route.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcMatches":
            suggest = "grpc_matches"
        elif key == "grpcRouteAction":
            suggest = "grpc_route_action"
        elif key == "grpcStatusResponseAction":
            suggest = "grpc_status_response_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteGrpcRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteGrpcRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteGrpcRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_matches: Optional[Sequence['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatch']] = None,
                 grpc_route_action: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteAction'] = None,
                 grpc_status_response_action: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction'] = None):
        """
        :param Sequence['AlbVirtualHostRouteGrpcRouteGrpcMatchArgs'] grpc_matches: Checks "/" prefix by default. The structure is documented below.
        :param 'AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs' grpc_route_action: GRPC route action resource. The structure is documented below.
        :param 'AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs' grpc_status_response_action: GRPC status response action resource. The structure is documented below.
        """
        if grpc_matches is not None:
            pulumi.set(__self__, "grpc_matches", grpc_matches)
        if grpc_route_action is not None:
            pulumi.set(__self__, "grpc_route_action", grpc_route_action)
        if grpc_status_response_action is not None:
            pulumi.set(__self__, "grpc_status_response_action", grpc_status_response_action)

    @property
    @pulumi.getter(name="grpcMatches")
    def grpc_matches(self) -> Optional[Sequence['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatch']]:
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        return pulumi.get(self, "grpc_matches")

    @property
    @pulumi.getter(name="grpcRouteAction")
    def grpc_route_action(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteAction']:
        """
        GRPC route action resource. The structure is documented below.
        """
        return pulumi.get(self, "grpc_route_action")

    @property
    @pulumi.getter(name="grpcStatusResponseAction")
    def grpc_status_response_action(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction']:
        """
        GRPC status response action resource. The structure is documented below.
        """
        return pulumi.get(self, "grpc_status_response_action")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcMatch(dict):
    def __init__(__self__, *,
                 fqmn: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn'] = None):
        """
        :param 'AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs' fqmn: If not set, all services/methods are assumed. The structure is documented below.
        """
        if fqmn is not None:
            pulumi.set(__self__, "fqmn", fqmn)

    @property
    @pulumi.getter
    def fqmn(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn']:
        """
        If not set, all services/methods are assumed. The structure is documented below.
        """
        return pulumi.get(self, "fqmn")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        :param str exact: Match exactly.
        :param str prefix: Match prefix.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"
        elif key == "autoHostRewrite":
            suggest = "auto_host_rewrite"
        elif key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "maxTimeout":
            suggest = "max_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteGrpcRouteGrpcRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: str,
                 auto_host_rewrite: Optional[bool] = None,
                 host_rewrite: Optional[str] = None,
                 idle_timeout: Optional[str] = None,
                 max_timeout: Optional[str] = None):
        """
        :param str backend_group_id: Backend group to route requests.
        :param bool auto_host_rewrite: If set, will automatically rewrite host.
        :param str host_rewrite: Host rewrite specifier.
        :param str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the
               route. It is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout
               to the maximum time the stream is allowed to be alive. If not specified, there is no
               per-route idle timeout.
        :param str max_timeout: Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 
               60 seconds.
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        if auto_host_rewrite is not None:
            pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_timeout is not None:
            pulumi.set(__self__, "max_timeout", max_timeout)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> Optional[bool]:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[str]:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the
        route. It is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout
        to the maximum time the stream is allowed to be alive. If not specified, there is no
        per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="maxTimeout")
    def max_timeout(self) -> Optional[str]:
        """
        Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 
        60 seconds.
        """
        return pulumi.get(self, "max_timeout")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction(dict):
    def __init__(__self__, *,
                 status: Optional[str] = None):
        """
        :param str status: The status of the response. Supported values are: ok, invalid_argumet, not_found, 
               permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the response. Supported values are: ok, invalid_argumet, not_found, 
        permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AlbVirtualHostRouteHttpRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directResponseAction":
            suggest = "direct_response_action"
        elif key == "httpMatches":
            suggest = "http_matches"
        elif key == "httpRouteAction":
            suggest = "http_route_action"
        elif key == "redirectAction":
            suggest = "redirect_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direct_response_action: Optional['outputs.AlbVirtualHostRouteHttpRouteDirectResponseAction'] = None,
                 http_matches: Optional[Sequence['outputs.AlbVirtualHostRouteHttpRouteHttpMatch']] = None,
                 http_route_action: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteAction'] = None,
                 redirect_action: Optional['outputs.AlbVirtualHostRouteHttpRouteRedirectAction'] = None):
        """
        :param 'AlbVirtualHostRouteHttpRouteDirectResponseActionArgs' direct_response_action: Direct response action resource. The structure is documented below.
        :param Sequence['AlbVirtualHostRouteHttpRouteHttpMatchArgs'] http_matches: Checks "/" prefix by default. The structure is documented below.
        :param 'AlbVirtualHostRouteHttpRouteHttpRouteActionArgs' http_route_action: HTTP route action resource. The structure is documented below.
        :param 'AlbVirtualHostRouteHttpRouteRedirectActionArgs' redirect_action: Redirect action resource. The structure is documented below.
        """
        if direct_response_action is not None:
            pulumi.set(__self__, "direct_response_action", direct_response_action)
        if http_matches is not None:
            pulumi.set(__self__, "http_matches", http_matches)
        if http_route_action is not None:
            pulumi.set(__self__, "http_route_action", http_route_action)
        if redirect_action is not None:
            pulumi.set(__self__, "redirect_action", redirect_action)

    @property
    @pulumi.getter(name="directResponseAction")
    def direct_response_action(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteDirectResponseAction']:
        """
        Direct response action resource. The structure is documented below.
        """
        return pulumi.get(self, "direct_response_action")

    @property
    @pulumi.getter(name="httpMatches")
    def http_matches(self) -> Optional[Sequence['outputs.AlbVirtualHostRouteHttpRouteHttpMatch']]:
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        return pulumi.get(self, "http_matches")

    @property
    @pulumi.getter(name="httpRouteAction")
    def http_route_action(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteAction']:
        """
        HTTP route action resource. The structure is documented below.
        """
        return pulumi.get(self, "http_route_action")

    @property
    @pulumi.getter(name="redirectAction")
    def redirect_action(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteRedirectAction']:
        """
        Redirect action resource. The structure is documented below.
        """
        return pulumi.get(self, "redirect_action")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteDirectResponseAction(dict):
    def __init__(__self__, *,
                 body: Optional[str] = None,
                 status: Optional[int] = None):
        """
        :param str body: Response body text.
        :param int status: The status of the response. Supported values are: ok, invalid_argumet, not_found, 
               permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        Response body text.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def status(self) -> Optional[int]:
        """
        The status of the response. Supported values are: ok, invalid_argumet, not_found, 
        permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteHttpMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteHttpMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteHttpMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence[str]] = None,
                 path: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpMatchPath'] = None):
        """
        :param Sequence[str] http_methods: List of methods(strings).
        :param 'AlbVirtualHostRouteHttpRouteHttpMatchPathArgs' path: If not set, '/' is assumed. The structure is documented below.
        """
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence[str]]:
        """
        List of methods(strings).
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpMatchPath']:
        """
        If not set, '/' is assumed. The structure is documented below.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpMatchPath(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        :param str exact: Match exactly.
        :param str prefix: Match prefix.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"
        elif key == "autoHostRewrite":
            suggest = "auto_host_rewrite"
        elif key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "prefixRewrite":
            suggest = "prefix_rewrite"
        elif key == "upgradeTypes":
            suggest = "upgrade_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteHttpRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: str,
                 auto_host_rewrite: Optional[bool] = None,
                 host_rewrite: Optional[str] = None,
                 idle_timeout: Optional[str] = None,
                 prefix_rewrite: Optional[str] = None,
                 timeout: Optional[str] = None,
                 upgrade_types: Optional[Sequence[str]] = None):
        """
        :param str backend_group_id: Backend group to route requests.
        :param bool auto_host_rewrite: If set, will automatically rewrite host.
        :param str host_rewrite: Host rewrite specifier.
        :param str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the
               route. It is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout
               to the maximum time the stream is allowed to be alive. If not specified, there is no
               per-route idle timeout.
        :param str prefix_rewrite: If not empty, matched path prefix will be replaced by this value.
        :param str timeout: Specifies the request timeout (overall time request processing is allowed to take) for the 
               route. If not set, default is 60 seconds.
        :param Sequence[str] upgrade_types: List of upgrade types. Only specified upgrade types will be allowed. For example, 
               "websocket".
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        if auto_host_rewrite is not None:
            pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if prefix_rewrite is not None:
            pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if upgrade_types is not None:
            pulumi.set(__self__, "upgrade_types", upgrade_types)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> Optional[bool]:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[str]:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[str]:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the
        route. It is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout
        to the maximum time the stream is allowed to be alive. If not specified, there is no
        per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> Optional[str]:
        """
        If not empty, matched path prefix will be replaced by this value.
        """
        return pulumi.get(self, "prefix_rewrite")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Specifies the request timeout (overall time request processing is allowed to take) for the 
        route. If not set, default is 60 seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="upgradeTypes")
    def upgrade_types(self) -> Optional[Sequence[str]]:
        """
        List of upgrade types. Only specified upgrade types will be allowed. For example, 
        "websocket".
        """
        return pulumi.get(self, "upgrade_types")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeQuery":
            suggest = "remove_query"
        elif key == "replaceHost":
            suggest = "replace_host"
        elif key == "replacePath":
            suggest = "replace_path"
        elif key == "replacePort":
            suggest = "replace_port"
        elif key == "replacePrefix":
            suggest = "replace_prefix"
        elif key == "replaceScheme":
            suggest = "replace_scheme"
        elif key == "responseCode":
            suggest = "response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remove_query: Optional[bool] = None,
                 replace_host: Optional[str] = None,
                 replace_path: Optional[str] = None,
                 replace_port: Optional[int] = None,
                 replace_prefix: Optional[str] = None,
                 replace_scheme: Optional[str] = None,
                 response_code: Optional[str] = None):
        """
        :param str replace_host: Replaces hostname.
        :param str replace_path: Replace path.
        :param int replace_port: Replaces port.
        :param str replace_prefix: Replace only matched prefix. Example:<br/> match:{ prefix_match: "/some" } <br/> 
               redirect: { replace_prefix: "/other" } <br/> will redirect "/something" to "/otherthing".
        :param str replace_scheme: Replaces scheme. If the original scheme is `http` or `https`, will also remove the 
               80 or 443 port, if present.
        :param str response_code: The HTTP status code to use in the redirect response. Supported values are: 
               moved_permanently, found, see_other, temporary_redirect, permanent_redirect.
        """
        if remove_query is not None:
            pulumi.set(__self__, "remove_query", remove_query)
        if replace_host is not None:
            pulumi.set(__self__, "replace_host", replace_host)
        if replace_path is not None:
            pulumi.set(__self__, "replace_path", replace_path)
        if replace_port is not None:
            pulumi.set(__self__, "replace_port", replace_port)
        if replace_prefix is not None:
            pulumi.set(__self__, "replace_prefix", replace_prefix)
        if replace_scheme is not None:
            pulumi.set(__self__, "replace_scheme", replace_scheme)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)

    @property
    @pulumi.getter(name="removeQuery")
    def remove_query(self) -> Optional[bool]:
        return pulumi.get(self, "remove_query")

    @property
    @pulumi.getter(name="replaceHost")
    def replace_host(self) -> Optional[str]:
        """
        Replaces hostname.
        """
        return pulumi.get(self, "replace_host")

    @property
    @pulumi.getter(name="replacePath")
    def replace_path(self) -> Optional[str]:
        """
        Replace path.
        """
        return pulumi.get(self, "replace_path")

    @property
    @pulumi.getter(name="replacePort")
    def replace_port(self) -> Optional[int]:
        """
        Replaces port.
        """
        return pulumi.get(self, "replace_port")

    @property
    @pulumi.getter(name="replacePrefix")
    def replace_prefix(self) -> Optional[str]:
        """
        Replace only matched prefix. Example:<br/> match:{ prefix_match: "/some" } <br/> 
        redirect: { replace_prefix: "/other" } <br/> will redirect "/something" to "/otherthing".
        """
        return pulumi.get(self, "replace_prefix")

    @property
    @pulumi.getter(name="replaceScheme")
    def replace_scheme(self) -> Optional[str]:
        """
        Replaces scheme. If the original scheme is `http` or `https`, will also remove the 
        80 or 443 port, if present.
        """
        return pulumi.get(self, "replace_scheme")

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[str]:
        """
        The HTTP status code to use in the redirect response. Supported values are: 
        moved_permanently, found, see_other, temporary_redirect, permanent_redirect.
        """
        return pulumi.get(self, "response_code")


@pulumi.output_type
class CdnOriginGroupOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originGroupId":
            suggest = "origin_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnOriginGroupOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnOriginGroupOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnOriginGroupOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: str,
                 backup: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 origin_group_id: Optional[int] = None):
        pulumi.set(__self__, "source", source)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if origin_group_id is not None:
            pulumi.set(__self__, "origin_group_id", origin_group_id)

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def backup(self) -> Optional[bool]:
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="originGroupId")
    def origin_group_id(self) -> Optional[int]:
        return pulumi.get(self, "origin_group_id")


@pulumi.output_type
class CdnResourceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHttpMethods":
            suggest = "allowed_http_methods"
        elif key == "browserCacheSettings":
            suggest = "browser_cache_settings"
        elif key == "cacheHttpHeaders":
            suggest = "cache_http_headers"
        elif key == "customHostHeader":
            suggest = "custom_host_header"
        elif key == "customServerName":
            suggest = "custom_server_name"
        elif key == "disableCache":
            suggest = "disable_cache"
        elif key == "disableProxyForceRanges":
            suggest = "disable_proxy_force_ranges"
        elif key == "edgeCacheSettings":
            suggest = "edge_cache_settings"
        elif key == "fetchedCompressed":
            suggest = "fetched_compressed"
        elif key == "forwardHostHeader":
            suggest = "forward_host_header"
        elif key == "gzipOn":
            suggest = "gzip_on"
        elif key == "ignoreCookie":
            suggest = "ignore_cookie"
        elif key == "ignoreQueryParams":
            suggest = "ignore_query_params"
        elif key == "proxyCacheMethodsSet":
            suggest = "proxy_cache_methods_set"
        elif key == "queryParamsBlacklists":
            suggest = "query_params_blacklists"
        elif key == "queryParamsWhitelists":
            suggest = "query_params_whitelists"
        elif key == "redirectHttpToHttps":
            suggest = "redirect_http_to_https"
        elif key == "redirectHttpsToHttp":
            suggest = "redirect_https_to_http"
        elif key == "staticRequestHeaders":
            suggest = "static_request_headers"
        elif key == "staticResponseHeaders":
            suggest = "static_response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnResourceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnResourceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnResourceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_http_methods: Optional[Sequence[str]] = None,
                 browser_cache_settings: Optional[int] = None,
                 cache_http_headers: Optional[Sequence[str]] = None,
                 cors: Optional[Sequence[str]] = None,
                 custom_host_header: Optional[str] = None,
                 custom_server_name: Optional[str] = None,
                 disable_cache: Optional[bool] = None,
                 disable_proxy_force_ranges: Optional[bool] = None,
                 edge_cache_settings: Optional[int] = None,
                 fetched_compressed: Optional[bool] = None,
                 forward_host_header: Optional[bool] = None,
                 gzip_on: Optional[bool] = None,
                 ignore_cookie: Optional[bool] = None,
                 ignore_query_params: Optional[bool] = None,
                 proxy_cache_methods_set: Optional[bool] = None,
                 query_params_blacklists: Optional[Sequence[str]] = None,
                 query_params_whitelists: Optional[Sequence[str]] = None,
                 redirect_http_to_https: Optional[bool] = None,
                 redirect_https_to_http: Optional[bool] = None,
                 slice: Optional[bool] = None,
                 static_request_headers: Optional[Sequence[str]] = None,
                 static_response_headers: Optional[Mapping[str, str]] = None):
        """
        :param Sequence[str] allowed_http_methods: HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        :param int browser_cache_settings: set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        :param Sequence[str] cache_http_headers: list HTTP headers that must be included in responses to clients.
        :param Sequence[str] cors: parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        :param str custom_host_header: custom value for the Host header. Your server must be able to process requests with the chosen header.
        :param str custom_server_name: wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        :param bool disable_cache: setup a cache status.
        :param bool disable_proxy_force_ranges: disabling proxy force ranges.
        :param int edge_cache_settings: content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        :param bool fetched_compressed: option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        :param bool forward_host_header: choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        :param bool gzip_on: GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        :param bool ignore_cookie: set for ignoring cookie.
        :param bool ignore_query_params: files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        :param bool proxy_cache_methods_set: allows caching for GET, HEAD and POST requests.
        :param Sequence[str] query_params_blacklists: files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        :param Sequence[str] query_params_whitelists: files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        :param bool redirect_http_to_https: set up a redirect from HTTPS to HTTP.
        :param bool redirect_https_to_http: set up a redirect from HTTP to HTTPS.
        :param bool slice: files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        :param Sequence[str] static_request_headers: set up custom headers that CDN servers send in requests to origins.
        """
        if allowed_http_methods is not None:
            pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        if browser_cache_settings is not None:
            pulumi.set(__self__, "browser_cache_settings", browser_cache_settings)
        if cache_http_headers is not None:
            pulumi.set(__self__, "cache_http_headers", cache_http_headers)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if custom_host_header is not None:
            pulumi.set(__self__, "custom_host_header", custom_host_header)
        if custom_server_name is not None:
            pulumi.set(__self__, "custom_server_name", custom_server_name)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_proxy_force_ranges is not None:
            pulumi.set(__self__, "disable_proxy_force_ranges", disable_proxy_force_ranges)
        if edge_cache_settings is not None:
            pulumi.set(__self__, "edge_cache_settings", edge_cache_settings)
        if fetched_compressed is not None:
            pulumi.set(__self__, "fetched_compressed", fetched_compressed)
        if forward_host_header is not None:
            pulumi.set(__self__, "forward_host_header", forward_host_header)
        if gzip_on is not None:
            pulumi.set(__self__, "gzip_on", gzip_on)
        if ignore_cookie is not None:
            pulumi.set(__self__, "ignore_cookie", ignore_cookie)
        if ignore_query_params is not None:
            pulumi.set(__self__, "ignore_query_params", ignore_query_params)
        if proxy_cache_methods_set is not None:
            pulumi.set(__self__, "proxy_cache_methods_set", proxy_cache_methods_set)
        if query_params_blacklists is not None:
            pulumi.set(__self__, "query_params_blacklists", query_params_blacklists)
        if query_params_whitelists is not None:
            pulumi.set(__self__, "query_params_whitelists", query_params_whitelists)
        if redirect_http_to_https is not None:
            pulumi.set(__self__, "redirect_http_to_https", redirect_http_to_https)
        if redirect_https_to_http is not None:
            pulumi.set(__self__, "redirect_https_to_http", redirect_https_to_http)
        if slice is not None:
            pulumi.set(__self__, "slice", slice)
        if static_request_headers is not None:
            pulumi.set(__self__, "static_request_headers", static_request_headers)
        if static_response_headers is not None:
            pulumi.set(__self__, "static_response_headers", static_response_headers)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[Sequence[str]]:
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        return pulumi.get(self, "allowed_http_methods")

    @property
    @pulumi.getter(name="browserCacheSettings")
    def browser_cache_settings(self) -> Optional[int]:
        """
        set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        return pulumi.get(self, "browser_cache_settings")

    @property
    @pulumi.getter(name="cacheHttpHeaders")
    def cache_http_headers(self) -> Optional[Sequence[str]]:
        """
        list HTTP headers that must be included in responses to clients.
        """
        return pulumi.get(self, "cache_http_headers")

    @property
    @pulumi.getter
    def cors(self) -> Optional[Sequence[str]]:
        """
        parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="customHostHeader")
    def custom_host_header(self) -> Optional[str]:
        """
        custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        return pulumi.get(self, "custom_host_header")

    @property
    @pulumi.getter(name="customServerName")
    def custom_server_name(self) -> Optional[str]:
        """
        wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        """
        return pulumi.get(self, "custom_server_name")

    @property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[bool]:
        """
        setup a cache status.
        """
        return pulumi.get(self, "disable_cache")

    @property
    @pulumi.getter(name="disableProxyForceRanges")
    def disable_proxy_force_ranges(self) -> Optional[bool]:
        """
        disabling proxy force ranges.
        """
        return pulumi.get(self, "disable_proxy_force_ranges")

    @property
    @pulumi.getter(name="edgeCacheSettings")
    def edge_cache_settings(self) -> Optional[int]:
        """
        content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        return pulumi.get(self, "edge_cache_settings")

    @property
    @pulumi.getter(name="fetchedCompressed")
    def fetched_compressed(self) -> Optional[bool]:
        """
        option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        return pulumi.get(self, "fetched_compressed")

    @property
    @pulumi.getter(name="forwardHostHeader")
    def forward_host_header(self) -> Optional[bool]:
        """
        choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        return pulumi.get(self, "forward_host_header")

    @property
    @pulumi.getter(name="gzipOn")
    def gzip_on(self) -> Optional[bool]:
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        return pulumi.get(self, "gzip_on")

    @property
    @pulumi.getter(name="ignoreCookie")
    def ignore_cookie(self) -> Optional[bool]:
        """
        set for ignoring cookie.
        """
        return pulumi.get(self, "ignore_cookie")

    @property
    @pulumi.getter(name="ignoreQueryParams")
    def ignore_query_params(self) -> Optional[bool]:
        """
        files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        return pulumi.get(self, "ignore_query_params")

    @property
    @pulumi.getter(name="proxyCacheMethodsSet")
    def proxy_cache_methods_set(self) -> Optional[bool]:
        """
        allows caching for GET, HEAD and POST requests.
        """
        return pulumi.get(self, "proxy_cache_methods_set")

    @property
    @pulumi.getter(name="queryParamsBlacklists")
    def query_params_blacklists(self) -> Optional[Sequence[str]]:
        """
        files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        return pulumi.get(self, "query_params_blacklists")

    @property
    @pulumi.getter(name="queryParamsWhitelists")
    def query_params_whitelists(self) -> Optional[Sequence[str]]:
        """
        files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        return pulumi.get(self, "query_params_whitelists")

    @property
    @pulumi.getter(name="redirectHttpToHttps")
    def redirect_http_to_https(self) -> Optional[bool]:
        """
        set up a redirect from HTTPS to HTTP.
        """
        return pulumi.get(self, "redirect_http_to_https")

    @property
    @pulumi.getter(name="redirectHttpsToHttp")
    def redirect_https_to_http(self) -> Optional[bool]:
        """
        set up a redirect from HTTP to HTTPS.
        """
        return pulumi.get(self, "redirect_https_to_http")

    @property
    @pulumi.getter
    def slice(self) -> Optional[bool]:
        """
        files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        return pulumi.get(self, "slice")

    @property
    @pulumi.getter(name="staticRequestHeaders")
    def static_request_headers(self) -> Optional[Sequence[str]]:
        """
        set up custom headers that CDN servers send in requests to origins.
        """
        return pulumi.get(self, "static_request_headers")

    @property
    @pulumi.getter(name="staticResponseHeaders")
    def static_response_headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "static_response_headers")


@pulumi.output_type
class CdnResourceSslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateManagerId":
            suggest = "certificate_manager_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnResourceSslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnResourceSslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnResourceSslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 certificate_manager_id: Optional[str] = None,
                 status: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if certificate_manager_id is not None:
            pulumi.set(__self__, "certificate_manager_id", certificate_manager_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="certificateManagerId")
    def certificate_manager_id(self) -> Optional[str]:
        return pulumi.get(self, "certificate_manager_id")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class ComputeDiskDiskPlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskPlacementGroupId":
            suggest = "disk_placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeDiskDiskPlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeDiskDiskPlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeDiskDiskPlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_placement_group_id: str):
        """
        :param str disk_placement_group_id: Specifies Disk Placement Group id.
        """
        pulumi.set(__self__, "disk_placement_group_id", disk_placement_group_id)

    @property
    @pulumi.getter(name="diskPlacementGroupId")
    def disk_placement_group_id(self) -> str:
        """
        Specifies Disk Placement Group id.
        """
        return pulumi.get(self, "disk_placement_group_id")


@pulumi.output_type
class ComputeInstanceBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "initializeParams":
            suggest = "initialize_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_delete: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 disk_id: Optional[str] = None,
                 initialize_params: Optional['outputs.ComputeInstanceBootDiskInitializeParams'] = None,
                 mode: Optional[str] = None):
        """
        :param bool auto_delete: Whether the disk is auto-deleted when the instance
               is deleted. The default value is false.
        :param str device_name: Name that can be used to access an attached disk
               under `/dev/disk/by-id/`.
        :param str disk_id: ID of the disk that is attached to the instance.
        :param 'ComputeInstanceBootDiskInitializeParamsArgs' initialize_params: Parameters for a new disk that will be created
               alongside the new instance. Either `initialize_params` or `disk_id` must be set. The structure is documented below.
        :param str mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        """
        Whether the disk is auto-deleted when the instance
        is deleted. The default value is false.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name that can be used to access an attached disk
        under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[str]:
        """
        ID of the disk that is attached to the instance.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.ComputeInstanceBootDiskInitializeParams']:
        """
        Parameters for a new disk that will be created
        alongside the new instance. Either `initialize_params` or `disk_id` must be set. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ComputeInstanceBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSize":
            suggest = "block_size"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size: Optional[int] = None,
                 description: Optional[str] = None,
                 image_id: Optional[str] = None,
                 name: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str description: Description of the boot disk.
        :param str image_id: A disk image to initialize this disk from.
        :param str name: Name of the boot disk.
        :param int size: Size of the disk in GB.
        :param str snapshot_id: A snapshot to initialize this disk from.
        :param str type: Disk type.
        """
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[int]:
        return pulumi.get(self, "block_size")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        A disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the boot disk.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        A snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceGroupAllocationPolicy(dict):
    def __init__(__self__, *,
                 zones: Sequence[str]):
        """
        :param Sequence[str] zones: A list of availability zones.
        """
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        A list of availability zones.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class ComputeInstanceGroupApplicationLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOpeningTrafficDuration":
            suggest = "max_opening_traffic_duration"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "targetGroupDescription":
            suggest = "target_group_description"
        elif key == "targetGroupId":
            suggest = "target_group_id"
        elif key == "targetGroupLabels":
            suggest = "target_group_labels"
        elif key == "targetGroupName":
            suggest = "target_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupApplicationLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupApplicationLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupApplicationLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_opening_traffic_duration: Optional[int] = None,
                 status_message: Optional[str] = None,
                 target_group_description: Optional[str] = None,
                 target_group_id: Optional[str] = None,
                 target_group_labels: Optional[Mapping[str, str]] = None,
                 target_group_name: Optional[str] = None):
        """
        :param int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param str status_message: The status message of the instance.
        :param str target_group_description: A description of the target group.
        :param Mapping[str, str] target_group_labels: A set of key/value label pairs.
        :param str target_group_name: The name of the target group.
        """
        if max_opening_traffic_duration is not None:
            pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if target_group_description is not None:
            pulumi.set(__self__, "target_group_description", target_group_description)
        if target_group_id is not None:
            pulumi.set(__self__, "target_group_id", target_group_id)
        if target_group_labels is not None:
            pulumi.set(__self__, "target_group_labels", target_group_labels)
        if target_group_name is not None:
            pulumi.set(__self__, "target_group_name", target_group_name)

    @property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> Optional[int]:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[str]:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> Optional[str]:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> Optional[str]:
        return pulumi.get(self, "target_group_id")

    @property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Optional[Mapping[str, str]]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> Optional[str]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class ComputeInstanceGroupDeployPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxExpansion":
            suggest = "max_expansion"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "maxCreating":
            suggest = "max_creating"
        elif key == "maxDeleting":
            suggest = "max_deleting"
        elif key == "startupDuration":
            suggest = "startup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupDeployPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupDeployPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupDeployPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_expansion: int,
                 max_unavailable: int,
                 max_creating: Optional[int] = None,
                 max_deleting: Optional[int] = None,
                 startup_duration: Optional[int] = None,
                 strategy: Optional[str] = None):
        """
        :param int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size
               during the update process.
        :param int max_unavailable: The maximum number of running instances that can be taken offline (stopped or deleted) at the same time
               during the update process.
        :param int max_creating: The maximum number of instances that can be created at the same time.
        :param int max_deleting: The maximum number of instances that can be deleted at the same time.
        :param int startup_duration: The amount of time in seconds to allow for an instance to start.
               Instance will be considered up and running (and start receiving traffic) only after the startup_duration
               has elapsed and all health checks are passed.
        :param str strategy: Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups
               can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead,
               it will wait until the instance stops itself or becomes unhealthy.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        if max_creating is not None:
            pulumi.set(__self__, "max_creating", max_creating)
        if max_deleting is not None:
            pulumi.set(__self__, "max_deleting", max_deleting)
        if startup_duration is not None:
            pulumi.set(__self__, "startup_duration", startup_duration)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size
        during the update process.
        """
        return pulumi.get(self, "max_expansion")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        """
        The maximum number of running instances that can be taken offline (stopped or deleted) at the same time
        during the update process.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter(name="maxCreating")
    def max_creating(self) -> Optional[int]:
        """
        The maximum number of instances that can be created at the same time.
        """
        return pulumi.get(self, "max_creating")

    @property
    @pulumi.getter(name="maxDeleting")
    def max_deleting(self) -> Optional[int]:
        """
        The maximum number of instances that can be deleted at the same time.
        """
        return pulumi.get(self, "max_deleting")

    @property
    @pulumi.getter(name="startupDuration")
    def startup_duration(self) -> Optional[int]:
        """
        The amount of time in seconds to allow for an instance to start.
        Instance will be considered up and running (and start receiving traffic) only after the startup_duration
        has elapsed and all health checks are passed.
        """
        return pulumi.get(self, "startup_duration")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups
        can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead,
        it will wait until the instance stops itself or becomes unhealthy.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ComputeInstanceGroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpOptions":
            suggest = "http_options"
        elif key == "tcpOptions":
            suggest = "tcp_options"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthy_threshold: Optional[int] = None,
                 http_options: Optional[Sequence['outputs.ComputeInstanceGroupHealthCheckHttpOption']] = None,
                 interval: Optional[int] = None,
                 tcp_options: Optional['outputs.ComputeInstanceGroupHealthCheckTcpOptions'] = None,
                 timeout: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param int healthy_threshold: The number of successful health checks before the managed instance is declared healthy.
        :param Sequence['ComputeInstanceGroupHealthCheckHttpOptionArgs'] http_options: HTTP check options. The structure is documented below.
        :param int interval: The interval to wait between health checks in seconds.
        :param 'ComputeInstanceGroupHealthCheckTcpOptionsArgs' tcp_options: TCP check options. The structure is documented below.
        :param int timeout: The length of time to wait for a response before the health check times out in seconds.
        :param int unhealthy_threshold: The number of failed health checks before the managed instance is declared unhealthy.
        """
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_options is not None:
            pulumi.set(__self__, "http_options", http_options)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        The number of successful health checks before the managed instance is declared healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Optional[Sequence['outputs.ComputeInstanceGroupHealthCheckHttpOption']]:
        """
        HTTP check options. The structure is documented below.
        """
        return pulumi.get(self, "http_options")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The interval to wait between health checks in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional['outputs.ComputeInstanceGroupHealthCheckTcpOptions']:
        """
        TCP check options. The structure is documented below.
        """
        return pulumi.get(self, "tcp_options")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The length of time to wait for a response before the health check times out in seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        The number of failed health checks before the managed instance is declared unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class ComputeInstanceGroupHealthCheckHttpOption(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        """
        :param str path: The URL path used for health check requests.
        :param int port: The port used for TCP health checks.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The URL path used for health check requests.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port used for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ComputeInstanceGroupHealthCheckTcpOptions(dict):
    def __init__(__self__, *,
                 port: int):
        """
        :param int port: The port used for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port used for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ComputeInstanceGroupInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "statusChangedAt":
            suggest = "status_changed_at"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 name: Optional[str] = None,
                 network_interfaces: Optional[Sequence['outputs.ComputeInstanceGroupInstanceNetworkInterface']] = None,
                 status: Optional[str] = None,
                 status_changed_at: Optional[str] = None,
                 status_message: Optional[str] = None,
                 zone_id: Optional[str] = None):
        """
        :param str fqdn: DNS record fqdn (must have dot at the end).
        :param str instance_id: The ID of the instance.
        :param str name: Name template of the instance.  
               In order to be unique it must contain at least one of instance unique placeholders:
               {instance.short_id}
               {instance.index}
               combination of {instance.zone_id} and {instance.index_in_zone}
               Example: my-instance-{instance.index}
               If not set, default is used: {instance_group.id}-{instance.short_id}
               It may also contain another placeholders, see metadata doc for full list.
        :param Sequence['ComputeInstanceGroupInstanceNetworkInterfaceArgs'] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        :param str status: The status of the instance.
        :param str status_message: The status message of the instance.
        :param str zone_id: The ID of the availability zone where the instance resides.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_changed_at is not None:
            pulumi.set(__self__, "status_changed_at", status_changed_at)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        DNS record fqdn (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        The ID of the instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name template of the instance.  
        In order to be unique it must contain at least one of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, default is used: {instance_group.id}-{instance.short_id}
        It may also contain another placeholders, see metadata doc for full list.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceNetworkInterface']]:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the instance.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusChangedAt")
    def status_changed_at(self) -> Optional[str]:
        return pulumi.get(self, "status_changed_at")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[str]:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        The ID of the availability zone where the instance resides.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "natIpAddress":
            suggest = "nat_ip_address"
        elif key == "natIpVersion":
            suggest = "nat_ip_version"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: Optional[int] = None,
                 ip_address: Optional[str] = None,
                 ipv4: Optional[bool] = None,
                 ipv6: Optional[bool] = None,
                 ipv6_address: Optional[str] = None,
                 mac_address: Optional[str] = None,
                 nat: Optional[bool] = None,
                 nat_ip_address: Optional[str] = None,
                 nat_ip_version: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param int index: The index of the network interface as generated by the server.
        :param str ip_address: Manual set static IP address.
        :param bool ipv4: True if IPv4 address allocated for the network interface.
        :param str ipv6_address: Manual set static IPv6 address.
        :param str mac_address: The MAC address assigned to the network interface.
        :param bool nat: Flag for using NAT.
        :param str nat_ip_address: A public address that can be used to access the internet over NAT. Use `variables` to set.
        :param str nat_ip_version: The IP version for the public address.
        :param str subnet_id: The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        """
        The index of the network interface as generated by the server.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[bool]:
        """
        True if IPv4 address allocated for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[bool]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The MAC address assigned to the network interface.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def nat(self) -> Optional[bool]:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[str]:
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        return pulumi.get(self, "nat_ip_address")

    @property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[str]:
        """
        The IP version for the public address.
        """
        return pulumi.get(self, "nat_ip_version")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "networkSettings":
            suggest = "network_settings"
        elif key == "placementPolicy":
            suggest = "placement_policy"
        elif key == "platformId":
            suggest = "platform_id"
        elif key == "schedulingPolicy":
            suggest = "scheduling_policy"
        elif key == "secondaryDisks":
            suggest = "secondary_disks"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk: 'outputs.ComputeInstanceGroupInstanceTemplateBootDisk',
                 network_interfaces: Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterface'],
                 resources: 'outputs.ComputeInstanceGroupInstanceTemplateResources',
                 description: Optional[str] = None,
                 hostname: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 metadata: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 network_settings: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkSetting']] = None,
                 placement_policy: Optional['outputs.ComputeInstanceGroupInstanceTemplatePlacementPolicy'] = None,
                 platform_id: Optional[str] = None,
                 scheduling_policy: Optional['outputs.ComputeInstanceGroupInstanceTemplateSchedulingPolicy'] = None,
                 secondary_disks: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDisk']] = None,
                 service_account_id: Optional[str] = None):
        """
        :param 'ComputeInstanceGroupInstanceTemplateBootDiskArgs' boot_disk: Boot disk specifications for the instance. The structure is documented below.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        :param 'ComputeInstanceGroupInstanceTemplateResourcesArgs' resources: Compute resource specifications for the instance. The structure is documented below.
        :param str description: A description of the boot disk.
        :param str hostname: Hostname template for the instance.   
               This field is used to generate the FQDN value of instance.
               The hostname must be unique within the network and region.
               If not specified, the hostname will be equal to id of the instance
               and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
               In order to be unique it must contain at least on of instance unique placeholders:
               {instance.short_id}
               {instance.index}
               combination of {instance.zone_id} and {instance.index_in_zone}
               Example: my-instance-{instance.index}
               If not set, `name` value will be used
               It may also contain another placeholders, see metadata doc for full list.
        :param Mapping[str, str] labels: A map of labels of metric.
        :param Mapping[str, str] metadata: A set of metadata key/value pairs to make available from within the instance.
        :param str name: Name template of the instance.  
               In order to be unique it must contain at least one of instance unique placeholders:
               {instance.short_id}
               {instance.index}
               combination of {instance.zone_id} and {instance.index_in_zone}
               Example: my-instance-{instance.index}
               If not set, default is used: {instance_group.id}-{instance.short_id}
               It may also contain another placeholders, see metadata doc for full list.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkSettingArgs'] network_settings: Network acceleration type for instance. The structure is documented below.
        :param 'ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs' placement_policy: The placement policy configuration. The structure is documented below.
        :param str platform_id: The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
        :param 'ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs' scheduling_policy: The scheduling policy configuration. The structure is documented below.
        :param Sequence['ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs'] secondary_disks: A list of disks to attach to the instance. The structure is documented below.
        :param str service_account_id: The ID of the service account authorized for this instance.
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resources", resources)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_settings is not None:
            pulumi.set(__self__, "network_settings", network_settings)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)
        if secondary_disks is not None:
            pulumi.set(__self__, "secondary_disks", secondary_disks)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> 'outputs.ComputeInstanceGroupInstanceTemplateBootDisk':
        """
        Boot disk specifications for the instance. The structure is documented below.
        """
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterface']:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces. The structure is documented below.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.ComputeInstanceGroupInstanceTemplateResources':
        """
        Compute resource specifications for the instance. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname template for the instance.   
        This field is used to generate the FQDN value of instance.
        The hostname must be unique within the network and region.
        If not specified, the hostname will be equal to id of the instance
        and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
        In order to be unique it must contain at least on of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, `name` value will be used
        It may also contain another placeholders, see metadata doc for full list.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of labels of metric.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name template of the instance.  
        In order to be unique it must contain at least one of instance unique placeholders:
        {instance.short_id}
        {instance.index}
        combination of {instance.zone_id} and {instance.index_in_zone}
        Example: my-instance-{instance.index}
        If not set, default is used: {instance_group.id}-{instance.short_id}
        It may also contain another placeholders, see metadata doc for full list.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkSettings")
    def network_settings(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkSetting']]:
        """
        Network acceleration type for instance. The structure is documented below.
        """
        return pulumi.get(self, "network_settings")

    @property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplatePlacementPolicy']:
        """
        The placement policy configuration. The structure is documented below.
        """
        return pulumi.get(self, "placement_policy")

    @property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[str]:
        """
        The ID of the hardware platform configuration for the instance. The default is 'standard-v1'.
        """
        return pulumi.get(self, "platform_id")

    @property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplateSchedulingPolicy']:
        """
        The scheduling policy configuration. The structure is documented below.
        """
        return pulumi.get(self, "scheduling_policy")

    @property
    @pulumi.getter(name="secondaryDisks")
    def secondary_disks(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDisk']]:
        """
        A list of disks to attach to the instance. The structure is documented below.
        """
        return pulumi.get(self, "secondary_disks")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[str]:
        """
        The ID of the service account authorized for this instance.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "initializeParams":
            suggest = "initialize_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 disk_id: Optional[str] = None,
                 initialize_params: Optional['outputs.ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams'] = None,
                 mode: Optional[str] = None):
        """
        :param str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param str disk_id: ID of the existing disk. To set use variables.
        :param 'ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs' initialize_params: Parameters for creating a disk alongside the instance. The structure is documented below.
        :param str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[str]:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams']:
        """
        Parameters for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 image_id: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str description: A description of the boot disk.
        :param str image_id: The disk image to initialize this disk from.
        :param int size: The number of instances in the instance group.
        :param str snapshot_id: The snapshot to initialize this disk from.
        :param str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The number of instances in the instance group.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsRecords":
            suggest = "dns_records"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "ipv6DnsRecords":
            suggest = "ipv6_dns_records"
        elif key == "natDnsRecords":
            suggest = "nat_dns_records"
        elif key == "natIpAddress":
            suggest = "nat_ip_address"
        elif key == "networkId":
            suggest = "network_id"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_records: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord']] = None,
                 ip_address: Optional[str] = None,
                 ipv4: Optional[bool] = None,
                 ipv6: Optional[bool] = None,
                 ipv6_address: Optional[str] = None,
                 ipv6_dns_records: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord']] = None,
                 nat: Optional[bool] = None,
                 nat_dns_records: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord']] = None,
                 nat_ip_address: Optional[str] = None,
                 network_id: Optional[str] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs'] dns_records: List of dns records.  The structure is documented below.
        :param str ip_address: Manual set static IP address.
        :param bool ipv4: True if IPv4 address allocated for the network interface.
        :param str ipv6_address: Manual set static IPv6 address.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of ipv6 dns records.  The structure is documented below.
        :param bool nat: Flag for using NAT.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of nat dns records.  The structure is documented below.
        :param str nat_ip_address: A public address that can be used to access the internet over NAT. Use `variables` to set.
        :param str network_id: The ID of the network.
        :param Sequence[str] security_group_ids: Security group ids for network interface.
        :param Sequence[str] subnet_ids: The ID of the subnets to attach this interface to.
        """
        if dns_records is not None:
            pulumi.set(__self__, "dns_records", dns_records)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_dns_records is not None:
            pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord']]:
        """
        List of dns records.  The structure is documented below.
        """
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[bool]:
        """
        True if IPv4 address allocated for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[bool]:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord']]:
        """
        List of ipv6 dns records.  The structure is documented below.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @property
    @pulumi.getter
    def nat(self) -> Optional[bool]:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord']]:
        """
        List of nat dns records.  The structure is documented below.
        """
        return pulumi.get(self, "nat_dns_records")

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[str]:
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        return pulumi.get(self, "nat_ip_address")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[str]:
        """
        The ID of the network.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        The ID of the subnets to attach this interface to.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 dns_zone_id: Optional[str] = None,
                 ptr: Optional[bool] = None,
                 ttl: Optional[int] = None):
        """
        :param str fqdn: DNS record fqdn (must have dot at the end).
        :param str dns_zone_id: DNS zone id (if not set, private zone used).
        :param bool ptr: When set to true, also create PTR DNS record.
        :param int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record fqdn (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[str]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def ptr(self) -> Optional[bool]:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 dns_zone_id: Optional[str] = None,
                 ptr: Optional[bool] = None,
                 ttl: Optional[int] = None):
        """
        :param str fqdn: DNS record fqdn (must have dot at the end).
        :param str dns_zone_id: DNS zone id (if not set, private zone used).
        :param bool ptr: When set to true, also create PTR DNS record.
        :param int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record fqdn (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[str]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def ptr(self) -> Optional[bool]:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 dns_zone_id: Optional[str] = None,
                 ptr: Optional[bool] = None,
                 ttl: Optional[int] = None):
        """
        :param str fqdn: DNS record fqdn (must have dot at the end).
        :param str dns_zone_id: DNS zone id (if not set, private zone used).
        :param bool ptr: When set to true, also create PTR DNS record.
        :param int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record fqdn (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[str]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def ptr(self) -> Optional[bool]:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkSetting(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplatePlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementGroupId":
            suggest = "placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplatePlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_group_id: str):
        """
        :param str placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreFraction":
            suggest = "core_fraction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores: int,
                 memory: float,
                 core_fraction: Optional[int] = None,
                 gpus: Optional[int] = None):
        """
        :param int cores: The number of CPU cores for the instance.
        :param float memory: The memory size in GB.
        :param int core_fraction: If provided, specifies baseline core performance as a percent.
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)

    @property
    @pulumi.getter
    def cores(self) -> int:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def memory(self) -> float:
        """
        The memory size in GB.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[int]:
        """
        If provided, specifies baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @property
    @pulumi.getter
    def gpus(self) -> Optional[int]:
        return pulumi.get(self, "gpus")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateSchedulingPolicy(dict):
    def __init__(__self__, *,
                 preemptible: Optional[bool] = None):
        """
        :param bool preemptible: Specifies if the instance is preemptible. Defaults to false.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateSecondaryDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "initializeParams":
            suggest = "initialize_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateSecondaryDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 disk_id: Optional[str] = None,
                 initialize_params: Optional['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams'] = None,
                 mode: Optional[str] = None):
        """
        :param str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param str disk_id: ID of the existing disk. To set use variables.
        :param 'ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs' initialize_params: Parameters for creating a disk alongside the instance. The structure is documented below.
        :param str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[str]:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams']:
        """
        Parameters for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 image_id: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str description: A description of the boot disk.
        :param str image_id: The disk image to initialize this disk from.
        :param int size: The number of instances in the instance group.
        :param str snapshot_id: The snapshot to initialize this disk from.
        :param str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The number of instances in the instance group.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceGroupLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOpeningTrafficDuration":
            suggest = "max_opening_traffic_duration"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "targetGroupDescription":
            suggest = "target_group_description"
        elif key == "targetGroupId":
            suggest = "target_group_id"
        elif key == "targetGroupLabels":
            suggest = "target_group_labels"
        elif key == "targetGroupName":
            suggest = "target_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_opening_traffic_duration: Optional[int] = None,
                 status_message: Optional[str] = None,
                 target_group_description: Optional[str] = None,
                 target_group_id: Optional[str] = None,
                 target_group_labels: Optional[Mapping[str, str]] = None,
                 target_group_name: Optional[str] = None):
        """
        :param int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param str status_message: The status message of the instance.
        :param str target_group_description: A description of the target group.
        :param Mapping[str, str] target_group_labels: A set of key/value label pairs.
        :param str target_group_name: The name of the target group.
        """
        if max_opening_traffic_duration is not None:
            pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if target_group_description is not None:
            pulumi.set(__self__, "target_group_description", target_group_description)
        if target_group_id is not None:
            pulumi.set(__self__, "target_group_id", target_group_id)
        if target_group_labels is not None:
            pulumi.set(__self__, "target_group_labels", target_group_labels)
        if target_group_name is not None:
            pulumi.set(__self__, "target_group_name", target_group_name)

    @property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> Optional[int]:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[str]:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> Optional[str]:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> Optional[str]:
        return pulumi.get(self, "target_group_id")

    @property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Optional[Mapping[str, str]]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> Optional[str]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class ComputeInstanceGroupScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScale":
            suggest = "auto_scale"
        elif key == "fixedScale":
            suggest = "fixed_scale"
        elif key == "testAutoScale":
            suggest = "test_auto_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scale: Optional['outputs.ComputeInstanceGroupScalePolicyAutoScale'] = None,
                 fixed_scale: Optional['outputs.ComputeInstanceGroupScalePolicyFixedScale'] = None,
                 test_auto_scale: Optional['outputs.ComputeInstanceGroupScalePolicyTestAutoScale'] = None):
        """
        :param 'ComputeInstanceGroupScalePolicyAutoScaleArgs' auto_scale: The auto scaling policy of the instance group. The structure is documented below.
        :param 'ComputeInstanceGroupScalePolicyFixedScaleArgs' fixed_scale: The fixed scaling policy of the instance group. The structure is documented below.
        :param 'ComputeInstanceGroupScalePolicyTestAutoScaleArgs' test_auto_scale: The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if fixed_scale is not None:
            pulumi.set(__self__, "fixed_scale", fixed_scale)
        if test_auto_scale is not None:
            pulumi.set(__self__, "test_auto_scale", test_auto_scale)

    @property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional['outputs.ComputeInstanceGroupScalePolicyAutoScale']:
        """
        The auto scaling policy of the instance group. The structure is documented below.
        """
        return pulumi.get(self, "auto_scale")

    @property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> Optional['outputs.ComputeInstanceGroupScalePolicyFixedScale']:
        """
        The fixed scaling policy of the instance group. The structure is documented below.
        """
        return pulumi.get(self, "fixed_scale")

    @property
    @pulumi.getter(name="testAutoScale")
    def test_auto_scale(self) -> Optional['outputs.ComputeInstanceGroupScalePolicyTestAutoScale']:
        """
        The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
        """
        return pulumi.get(self, "test_auto_scale")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyAutoScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialSize":
            suggest = "initial_size"
        elif key == "measurementDuration":
            suggest = "measurement_duration"
        elif key == "cpuUtilizationTarget":
            suggest = "cpu_utilization_target"
        elif key == "customRules":
            suggest = "custom_rules"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minZoneSize":
            suggest = "min_zone_size"
        elif key == "stabilizationDuration":
            suggest = "stabilization_duration"
        elif key == "warmupDuration":
            suggest = "warmup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyAutoScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyAutoScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyAutoScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_size: int,
                 measurement_duration: int,
                 cpu_utilization_target: Optional[float] = None,
                 custom_rules: Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyAutoScaleCustomRule']] = None,
                 max_size: Optional[int] = None,
                 min_zone_size: Optional[int] = None,
                 stabilization_duration: Optional[int] = None,
                 warmup_duration: Optional[int] = None):
        """
        :param int initial_size: The initial number of instances in the instance group.
        :param int measurement_duration: The amount of time, in seconds, that metrics are averaged for.
               If the average value at the end of the interval is higher than the `cpu_utilization_target`,
               the instance group will increase the number of virtual machines in the group.
        :param float cpu_utilization_target: Target CPU load level.
        :param Sequence['ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules. The structure is documented below.
        :param int max_size: The maximum number of virtual machines in the group.
        :param int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param int stabilization_duration: The minimum time interval, in seconds, to monitor the load before
               an instance group can reduce the number of virtual machines in the group. During this time, the group
               will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time,
               traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_zone_size is not None:
            pulumi.set(__self__, "min_zone_size", min_zone_size)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> int:
        """
        The amount of time, in seconds, that metrics are averaged for.
        If the average value at the end of the interval is higher than the `cpu_utilization_target`,
        the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[float]:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyAutoScaleCustomRule']]:
        """
        A list of custom rules. The structure is documented below.
        """
        return pulumi.get(self, "custom_rules")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> Optional[int]:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[int]:
        """
        The minimum time interval, in seconds, to monitor the load before
        an instance group can reduce the number of virtual machines in the group. During this time, the group
        will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[int]:
        """
        The warm-up time of the virtual machine, in seconds. During this time,
        traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyAutoScaleCustomRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricType":
            suggest = "metric_type"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "folderId":
            suggest = "folder_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyAutoScaleCustomRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyAutoScaleCustomRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyAutoScaleCustomRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 metric_type: str,
                 rule_type: str,
                 target: float,
                 folder_id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 service: Optional[str] = None):
        """
        :param str metric_name: The name of metric.
        :param str metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param str rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
               First, Instance Groups calculates the average metric value for each instance,
               then averages the values for instances in one availability zone.
               This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
               This type of metric must have the `zone_id` label.
        :param float target: Target metric value level.
        :param str folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param Mapping[str, str] labels: A map of labels of metric.
        :param str service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "target", target)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
        First, Instance Groups calculates the average metric value for each instance,
        then averages the values for instances in one availability zone.
        This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
        This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[str]:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of labels of metric.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyFixedScale(dict):
    def __init__(__self__, *,
                 size: int):
        """
        :param int size: The number of instances in the instance group.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The number of instances in the instance group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyTestAutoScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialSize":
            suggest = "initial_size"
        elif key == "measurementDuration":
            suggest = "measurement_duration"
        elif key == "cpuUtilizationTarget":
            suggest = "cpu_utilization_target"
        elif key == "customRules":
            suggest = "custom_rules"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minZoneSize":
            suggest = "min_zone_size"
        elif key == "stabilizationDuration":
            suggest = "stabilization_duration"
        elif key == "warmupDuration":
            suggest = "warmup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyTestAutoScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_size: int,
                 measurement_duration: int,
                 cpu_utilization_target: Optional[float] = None,
                 custom_rules: Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule']] = None,
                 max_size: Optional[int] = None,
                 min_zone_size: Optional[int] = None,
                 stabilization_duration: Optional[int] = None,
                 warmup_duration: Optional[int] = None):
        """
        :param int initial_size: The initial number of instances in the instance group.
        :param int measurement_duration: The amount of time, in seconds, that metrics are averaged for.
               If the average value at the end of the interval is higher than the `cpu_utilization_target`,
               the instance group will increase the number of virtual machines in the group.
        :param float cpu_utilization_target: Target CPU load level.
        :param Sequence['ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules. The structure is documented below.
        :param int max_size: The maximum number of virtual machines in the group.
        :param int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param int stabilization_duration: The minimum time interval, in seconds, to monitor the load before
               an instance group can reduce the number of virtual machines in the group. During this time, the group
               will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time,
               traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_zone_size is not None:
            pulumi.set(__self__, "min_zone_size", min_zone_size)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> int:
        """
        The amount of time, in seconds, that metrics are averaged for.
        If the average value at the end of the interval is higher than the `cpu_utilization_target`,
        the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[float]:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule']]:
        """
        A list of custom rules. The structure is documented below.
        """
        return pulumi.get(self, "custom_rules")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> Optional[int]:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[int]:
        """
        The minimum time interval, in seconds, to monitor the load before
        an instance group can reduce the number of virtual machines in the group. During this time, the group
        will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[int]:
        """
        The warm-up time of the virtual machine, in seconds. During this time,
        traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricType":
            suggest = "metric_type"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "folderId":
            suggest = "folder_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 metric_type: str,
                 rule_type: str,
                 target: float,
                 folder_id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 service: Optional[str] = None):
        """
        :param str metric_name: The name of metric.
        :param str metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param str rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
               First, Instance Groups calculates the average metric value for each instance,
               then averages the values for instances in one availability zone.
               This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
               This type of metric must have the `zone_id` label.
        :param float target: Target metric value level.
        :param str folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param Mapping[str, str] labels: A map of labels of metric.
        :param str service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "target", target)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
        First, Instance Groups calculates the average metric value for each instance,
        then averages the values for instances in one availability zone.
        This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
        This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[str]:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of labels of metric.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ComputeInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "dnsRecords":
            suggest = "dns_records"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "ipv6DnsRecords":
            suggest = "ipv6_dns_records"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "natDnsRecords":
            suggest = "nat_dns_records"
        elif key == "natIpAddress":
            suggest = "nat_ip_address"
        elif key == "natIpVersion":
            suggest = "nat_ip_version"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 dns_records: Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceDnsRecord']] = None,
                 index: Optional[int] = None,
                 ip_address: Optional[str] = None,
                 ipv4: Optional[bool] = None,
                 ipv6: Optional[bool] = None,
                 ipv6_address: Optional[str] = None,
                 ipv6_dns_records: Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceIpv6DnsRecord']] = None,
                 mac_address: Optional[str] = None,
                 nat: Optional[bool] = None,
                 nat_dns_records: Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceNatDnsRecord']] = None,
                 nat_ip_address: Optional[str] = None,
                 nat_ip_version: Optional[str] = None,
                 security_group_ids: Optional[Sequence[str]] = None):
        """
        :param str subnet_id: ID of the subnet to attach this
               interface to. The subnet must exist in the same zone where this instance will be
               created.
        :param Sequence['ComputeInstanceNetworkInterfaceDnsRecordArgs'] dns_records: List of configurations for creating ipv4 DNS records. The structure is documented below.
        :param str ip_address: The private IP address to assign to the instance. If
               empty, the address will be automatically assigned from the specified subnet.
        :param bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param bool ipv6: If true, allocate an IPv6 address for the interface.
               The address will be automatically assigned from the specified subnet.
        :param str ipv6_address: The private IPv6 address to assign to the instance.
        :param Sequence['ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of configurations for creating ipv6 DNS records. The structure is documented below.
        :param bool nat: Provide a public address, for instance, to access the internet over NAT.
        :param Sequence['ComputeInstanceNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of configurations for creating ipv4 NAT DNS records. The structure is documented below.
        :param str nat_ip_address: Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        :param Sequence[str] security_group_ids: Security group ids for network interface.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if dns_records is not None:
            pulumi.set(__self__, "dns_records", dns_records)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_dns_records is not None:
            pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        ID of the subnet to attach this
        interface to. The subnet must exist in the same zone where this instance will be
        created.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceDnsRecord']]:
        """
        List of configurations for creating ipv4 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The private IP address to assign to the instance. If
        empty, the address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[bool]:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[bool]:
        """
        If true, allocate an IPv6 address for the interface.
        The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        The private IPv6 address to assign to the instance.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceIpv6DnsRecord']]:
        """
        List of configurations for creating ipv6 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def nat(self) -> Optional[bool]:
        """
        Provide a public address, for instance, to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceNatDnsRecord']]:
        """
        List of configurations for creating ipv4 NAT DNS records. The structure is documented below.
        """
        return pulumi.get(self, "nat_dns_records")

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[str]:
        """
        Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        """
        return pulumi.get(self, "nat_ip_address")

    @property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[str]:
        return pulumi.get(self, "nat_ip_version")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class ComputeInstanceNetworkInterfaceDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterfaceDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterfaceDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterfaceDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 dns_zone_id: Optional[str] = None,
                 ptr: Optional[bool] = None,
                 ttl: Optional[int] = None):
        """
        :param str fqdn: DNS record FQDN (must have a dot at the end).
        :param str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param bool ptr: When set to true, also create a PTR DNS record.
        :param int ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[str]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def ptr(self) -> Optional[bool]:
        """
        When set to true, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceNetworkInterfaceIpv6DnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterfaceIpv6DnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 dns_zone_id: Optional[str] = None,
                 ptr: Optional[bool] = None,
                 ttl: Optional[int] = None):
        """
        :param str fqdn: DNS record FQDN (must have a dot at the end).
        :param str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param bool ptr: When set to true, also create a PTR DNS record.
        :param int ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[str]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def ptr(self) -> Optional[bool]:
        """
        When set to true, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceNetworkInterfaceNatDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterfaceNatDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 dns_zone_id: Optional[str] = None,
                 ptr: Optional[bool] = None,
                 ttl: Optional[int] = None):
        """
        :param str fqdn: DNS record FQDN (must have a dot at the end).
        :param str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param bool ptr: When set to true, also create a PTR DNS record.
        :param int ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[str]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def ptr(self) -> Optional[bool]:
        """
        When set to true, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstancePlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementGroupId":
            suggest = "placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstancePlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstancePlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstancePlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_group_id: str):
        """
        :param str placement_group_id: Specifies the id of the Placement Group to assign to the instance.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        """
        Specifies the id of the Placement Group to assign to the instance.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class ComputeInstanceResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreFraction":
            suggest = "core_fraction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores: int,
                 memory: float,
                 core_fraction: Optional[int] = None,
                 gpus: Optional[int] = None):
        """
        :param int cores: CPU cores for the instance.
        :param float memory: Memory size in GB.
        :param int core_fraction: If provided, specifies baseline performance for a core as a percent.
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)

    @property
    @pulumi.getter
    def cores(self) -> int:
        """
        CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def memory(self) -> float:
        """
        Memory size in GB.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[int]:
        """
        If provided, specifies baseline performance for a core as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @property
    @pulumi.getter
    def gpus(self) -> Optional[int]:
        return pulumi.get(self, "gpus")


@pulumi.output_type
class ComputeInstanceSchedulingPolicy(dict):
    def __init__(__self__, *,
                 preemptible: Optional[bool] = None):
        """
        :param bool preemptible: Specifies if the instance is preemptible. Defaults to false.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class ComputeInstanceSecondaryDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskId":
            suggest = "disk_id"
        elif key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceSecondaryDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceSecondaryDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceSecondaryDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_id: str,
                 auto_delete: Optional[bool] = None,
                 device_name: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str disk_id: ID of the disk that is attached to the instance.
        :param bool auto_delete: Whether the disk is auto-deleted when the instance
               is deleted. The default value is false.
        :param str device_name: Name that can be used to access an attached disk
               under `/dev/disk/by-id/`.
        :param str mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "disk_id", disk_id)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        ID of the disk that is attached to the instance.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[bool]:
        """
        Whether the disk is auto-deleted when the instance
        is deleted. The default value is false.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        Name that can be used to access an attached disk
        under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DataprocClusterClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subclusterSpecs":
            suggest = "subcluster_specs"
        elif key == "versionId":
            suggest = "version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subcluster_specs: Sequence['outputs.DataprocClusterClusterConfigSubclusterSpec'],
                 hadoop: Optional['outputs.DataprocClusterClusterConfigHadoop'] = None,
                 version_id: Optional[str] = None):
        """
        :param Sequence['DataprocClusterClusterConfigSubclusterSpecArgs'] subcluster_specs: Configuration of the Data Proc subcluster. The structure is documented below.
        :param 'DataprocClusterClusterConfigHadoopArgs' hadoop: Data Proc specific options. The structure is documented below.
        :param str version_id: Version of Data Proc image.
        """
        pulumi.set(__self__, "subcluster_specs", subcluster_specs)
        if hadoop is not None:
            pulumi.set(__self__, "hadoop", hadoop)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="subclusterSpecs")
    def subcluster_specs(self) -> Sequence['outputs.DataprocClusterClusterConfigSubclusterSpec']:
        """
        Configuration of the Data Proc subcluster. The structure is documented below.
        """
        return pulumi.get(self, "subcluster_specs")

    @property
    @pulumi.getter
    def hadoop(self) -> Optional['outputs.DataprocClusterClusterConfigHadoop']:
        """
        Data Proc specific options. The structure is documented below.
        """
        return pulumi.get(self, "hadoop")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[str]:
        """
        Version of Data Proc image.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class DataprocClusterClusterConfigHadoop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshPublicKeys":
            suggest = "ssh_public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigHadoop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigHadoop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigHadoop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 properties: Optional[Mapping[str, str]] = None,
                 services: Optional[Sequence[str]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None):
        """
        :param Mapping[str, str] properties: A set of key/value pairs that are used to configure cluster services.
        :param Sequence[str] services: List of services to run on Data Proc cluster.
        :param Sequence[str] ssh_public_keys: List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://cloud.yandex.com/docs/data-proc/operations/connect).
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        A set of key/value pairs that are used to configure cluster services.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence[str]]:
        """
        List of services to run on Data Proc cluster.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        """
        List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://cloud.yandex.com/docs/data-proc/operations/connect).
        """
        return pulumi.get(self, "ssh_public_keys")


@pulumi.output_type
class DataprocClusterClusterConfigSubclusterSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostsCount":
            suggest = "hosts_count"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "autoscalingConfig":
            suggest = "autoscaling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigSubclusterSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigSubclusterSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigSubclusterSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts_count: int,
                 name: str,
                 resources: 'outputs.DataprocClusterClusterConfigSubclusterSpecResources',
                 role: str,
                 subnet_id: str,
                 autoscaling_config: Optional['outputs.DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig'] = None,
                 id: Optional[str] = None):
        """
        :param int hosts_count: Number of hosts within Data Proc subcluster.
        :param str name: Name of the Data Proc subcluster.
        :param 'DataprocClusterClusterConfigSubclusterSpecResourcesArgs' resources: Resources allocated to each host of the Data Proc subcluster. The structure is documented below.
        :param str role: Role of the subcluster in the Data Proc cluster.
        :param str subnet_id: The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        :param 'DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs' autoscaling_config: Autoscaling configuration for compute subclusters.
        :param str id: (Computed) ID of a new Data Proc cluster.
        """
        pulumi.set(__self__, "hosts_count", hosts_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if autoscaling_config is not None:
            pulumi.set(__self__, "autoscaling_config", autoscaling_config)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="hostsCount")
    def hosts_count(self) -> int:
        """
        Number of hosts within Data Proc subcluster.
        """
        return pulumi.get(self, "hosts_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Data Proc subcluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.DataprocClusterClusterConfigSubclusterSpecResources':
        """
        Resources allocated to each host of the Data Proc subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role of the subcluster in the Data Proc cluster.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="autoscalingConfig")
    def autoscaling_config(self) -> Optional['outputs.DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig']:
        """
        Autoscaling configuration for compute subclusters.
        """
        return pulumi.get(self, "autoscaling_config")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Computed) ID of a new Data Proc cluster.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxHostsCount":
            suggest = "max_hosts_count"
        elif key == "cpuUtilizationTarget":
            suggest = "cpu_utilization_target"
        elif key == "decommissionTimeout":
            suggest = "decommission_timeout"
        elif key == "measurementDuration":
            suggest = "measurement_duration"
        elif key == "stabilizationDuration":
            suggest = "stabilization_duration"
        elif key == "warmupDuration":
            suggest = "warmup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_hosts_count: int,
                 cpu_utilization_target: Optional[float] = None,
                 decommission_timeout: Optional[int] = None,
                 measurement_duration: Optional[int] = None,
                 preemptible: Optional[bool] = None,
                 stabilization_duration: Optional[int] = None,
                 warmup_duration: Optional[int] = None):
        """
        :param int max_hosts_count: Maximum number of nodes in autoscaling subclusters.
        :param float cpu_utilization_target: Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        :param int decommission_timeout: Timeout to gracefully decommission nodes during downscaling. In seconds.
        :param int measurement_duration: Time in seconds allotted for averaging metrics.
        :param bool preemptible: Bool flag -- whether to use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://cloud.yandex.com/docs/compute/concepts/preemptible-vm).
        :param int stabilization_duration: Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        :param int warmup_duration: The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        pulumi.set(__self__, "max_hosts_count", max_hosts_count)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if decommission_timeout is not None:
            pulumi.set(__self__, "decommission_timeout", decommission_timeout)
        if measurement_duration is not None:
            pulumi.set(__self__, "measurement_duration", measurement_duration)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="maxHostsCount")
    def max_hosts_count(self) -> int:
        """
        Maximum number of nodes in autoscaling subclusters.
        """
        return pulumi.get(self, "max_hosts_count")

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[float]:
        """
        Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @property
    @pulumi.getter(name="decommissionTimeout")
    def decommission_timeout(self) -> Optional[int]:
        """
        Timeout to gracefully decommission nodes during downscaling. In seconds.
        """
        return pulumi.get(self, "decommission_timeout")

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> Optional[int]:
        """
        Time in seconds allotted for averaging metrics.
        """
        return pulumi.get(self, "measurement_duration")

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Bool flag -- whether to use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://cloud.yandex.com/docs/compute/concepts/preemptible-vm).
        """
        return pulumi.get(self, "preemptible")

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[int]:
        """
        Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        """
        return pulumi.get(self, "stabilization_duration")

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[int]:
        """
        The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class DataprocClusterClusterConfigSubclusterSpecResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"
        elif key == "diskTypeId":
            suggest = "disk_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigSubclusterSpecResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigSubclusterSpecResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigSubclusterSpecResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 resource_preset_id: str,
                 disk_type_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str resource_preset_id: The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://cloud.yandex.com/docs/data-proc/concepts/instance-types).
        :param str disk_type_id: Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        """
        The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://cloud.yandex.com/docs/data-proc/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
        return pulumi.get(self, "disk_type_id")


@pulumi.output_type
class DatatransferEndpointSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlSource":
            suggest = "mysql_source"
        elif key == "mysqlTarget":
            suggest = "mysql_target"
        elif key == "postgresSource":
            suggest = "postgres_source"
        elif key == "postgresTarget":
            suggest = "postgres_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mysql_source: Optional['outputs.DatatransferEndpointSettingsMysqlSource'] = None,
                 mysql_target: Optional['outputs.DatatransferEndpointSettingsMysqlTarget'] = None,
                 postgres_source: Optional['outputs.DatatransferEndpointSettingsPostgresSource'] = None,
                 postgres_target: Optional['outputs.DatatransferEndpointSettingsPostgresTarget'] = None):
        """
        :param 'DatatransferEndpointSettingsMysqlSourceArgs' mysql_source: Settings specific to the MySQL source endpoint.
        :param 'DatatransferEndpointSettingsMysqlTargetArgs' mysql_target: Settings specific to the MySQL target endpoint.
        :param 'DatatransferEndpointSettingsPostgresSourceArgs' postgres_source: Settings specific to the PostgreSQL source endpoint.
        :param 'DatatransferEndpointSettingsPostgresTargetArgs' postgres_target: Settings specific to the PostgreSQL target endpoint.
        """
        if mysql_source is not None:
            pulumi.set(__self__, "mysql_source", mysql_source)
        if mysql_target is not None:
            pulumi.set(__self__, "mysql_target", mysql_target)
        if postgres_source is not None:
            pulumi.set(__self__, "postgres_source", postgres_source)
        if postgres_target is not None:
            pulumi.set(__self__, "postgres_target", postgres_target)

    @property
    @pulumi.getter(name="mysqlSource")
    def mysql_source(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSource']:
        """
        Settings specific to the MySQL source endpoint.
        """
        return pulumi.get(self, "mysql_source")

    @property
    @pulumi.getter(name="mysqlTarget")
    def mysql_target(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTarget']:
        """
        Settings specific to the MySQL target endpoint.
        """
        return pulumi.get(self, "mysql_target")

    @property
    @pulumi.getter(name="postgresSource")
    def postgres_source(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSource']:
        """
        Settings specific to the PostgreSQL source endpoint.
        """
        return pulumi.get(self, "postgres_source")

    @property
    @pulumi.getter(name="postgresTarget")
    def postgres_target(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTarget']:
        """
        Settings specific to the PostgreSQL target endpoint.
        """
        return pulumi.get(self, "postgres_target")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTablesRegexes":
            suggest = "exclude_tables_regexes"
        elif key == "includeTablesRegexes":
            suggest = "include_tables_regexes"
        elif key == "objectTransferSettings":
            suggest = "object_transfer_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnection'] = None,
                 database: Optional[str] = None,
                 exclude_tables_regexes: Optional[Sequence[str]] = None,
                 include_tables_regexes: Optional[Sequence[str]] = None,
                 object_transfer_settings: Optional['outputs.DatatransferEndpointSettingsMysqlSourceObjectTransferSettings'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsMysqlSourcePassword'] = None,
                 timezone: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionArgs' connection: Connection settings. The structure is documented below.
        :param str database: Name of the database to transfer.
        :param Sequence[str] exclude_tables_regexes: Opposite of `include_table_regex`. The tables matching the specified regular expressions will not be transferred.
        :param Sequence[str] include_tables_regexes: List of regular expressions of table names which should be transferred. A table name is formatted as schemaname.tablename. For example, a single regular expression may look like `^mydb.employees$`.
        :param 'DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs' object_transfer_settings: Defines which database schema objects should be transferred, e.g. views, functions, etc.
        :param 'DatatransferEndpointSettingsMysqlSourcePasswordArgs' password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param str timezone: Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        :param str user: User for the database access.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if exclude_tables_regexes is not None:
            pulumi.set(__self__, "exclude_tables_regexes", exclude_tables_regexes)
        if include_tables_regexes is not None:
            pulumi.set(__self__, "include_tables_regexes", include_tables_regexes)
        if object_transfer_settings is not None:
            pulumi.set(__self__, "object_transfer_settings", object_transfer_settings)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnection']:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="excludeTablesRegexes")
    def exclude_tables_regexes(self) -> Optional[Sequence[str]]:
        """
        Opposite of `include_table_regex`. The tables matching the specified regular expressions will not be transferred.
        """
        return pulumi.get(self, "exclude_tables_regexes")

    @property
    @pulumi.getter(name="includeTablesRegexes")
    def include_tables_regexes(self) -> Optional[Sequence[str]]:
        """
        List of regular expressions of table names which should be transferred. A table name is formatted as schemaname.tablename. For example, a single regular expression may look like `^mydb.employees$`.
        """
        return pulumi.get(self, "include_tables_regexes")

    @property
    @pulumi.getter(name="objectTransferSettings")
    def object_transfer_settings(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceObjectTransferSettings']:
        """
        Defines which database schema objects should be transferred, e.g. views, functions, etc.
        """
        return pulumi.get(self, "object_transfer_settings")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourcePassword']:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSourceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremise'] = None):
        """
        :param str mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise MySQL server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[str]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremise']:
        """
        Connection settings of the on-premise MySQL server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSourceConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None,
                 hosts: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 subnet_id: Optional[str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode'] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        :param Sequence[str] hosts: List of host names of the PostgreSQL server. Exactly one host is expected currently.
        :param int port: Port for the database connection.
        :param str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        List of host names of the PostgreSQL server. Exactly one host is expected currently.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for the database connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled'] = None):
        """
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabledArgs' disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabledArgs' enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled']:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled']:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceObjectTransferSettings(dict):
    def __init__(__self__, *,
                 routine: Optional[str] = None,
                 trigger: Optional[str] = None,
                 view: Optional[str] = None):
        if routine is not None:
            pulumi.set(__self__, "routine", routine)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def routine(self) -> Optional[str]:
        return pulumi.get(self, "routine")

    @property
    @pulumi.getter
    def trigger(self) -> Optional[str]:
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourcePassword(dict):
    def __init__(__self__, *,
                 raw: Optional[str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceSchema":
            suggest = "service_schema"
        elif key == "skipConstraintChecks":
            suggest = "skip_constraint_checks"
        elif key == "sqlMode":
            suggest = "sql_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnection'] = None,
                 database: Optional[str] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsMysqlTargetPassword'] = None,
                 service_schema: Optional[str] = None,
                 skip_constraint_checks: Optional[bool] = None,
                 sql_mode: Optional[str] = None,
                 timezone: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionArgs' connection: Connection settings. The structure is documented below.
        :param str database: Name of the database to transfer.
        :param 'DatatransferEndpointSettingsMysqlTargetPasswordArgs' password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param str service_schema: Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema "public".
        :param bool skip_constraint_checks: When true, disables foreign key checks. See [foreign_key_checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks). False by default.
        :param str sql_mode: [sql_mode](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html) to use when interacting with the server. Defaults to "NO_AUTO_VALUE_ON_ZERO,NO_DIR_IN_CREATE,NO_ENGINE_SUBSTITUTION".
        :param str timezone: Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        :param str user: User for the database access.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_schema is not None:
            pulumi.set(__self__, "service_schema", service_schema)
        if skip_constraint_checks is not None:
            pulumi.set(__self__, "skip_constraint_checks", skip_constraint_checks)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnection']:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetPassword']:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="serviceSchema")
    def service_schema(self) -> Optional[str]:
        """
        Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema "public".
        """
        return pulumi.get(self, "service_schema")

    @property
    @pulumi.getter(name="skipConstraintChecks")
    def skip_constraint_checks(self) -> Optional[bool]:
        """
        When true, disables foreign key checks. See [foreign_key_checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks). False by default.
        """
        return pulumi.get(self, "skip_constraint_checks")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[str]:
        """
        [sql_mode](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html) to use when interacting with the server. Defaults to "NO_AUTO_VALUE_ON_ZERO,NO_DIR_IN_CREATE,NO_ENGINE_SUBSTITUTION".
        """
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: local timezone.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTargetConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremise'] = None):
        """
        :param str mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise MySQL server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[str]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremise']:
        """
        Connection settings of the on-premise MySQL server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTargetConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None,
                 hosts: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 subnet_id: Optional[str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode'] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        :param Sequence[str] hosts: List of host names of the PostgreSQL server. Exactly one host is expected currently.
        :param int port: Port for the database connection.
        :param str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        List of host names of the PostgreSQL server. Exactly one host is expected currently.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for the database connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled'] = None):
        """
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabledArgs' disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabledArgs' enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled']:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled']:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collapseInheritTable":
            suggest = "collapse_inherit_table"
        elif key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"
        elif key == "objectTransferSettings":
            suggest = "object_transfer_settings"
        elif key == "serviceSchema":
            suggest = "service_schema"
        elif key == "slotGigabyteLagLimit":
            suggest = "slot_gigabyte_lag_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collapse_inherit_table: Optional[bool] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnection'] = None,
                 database: Optional[str] = None,
                 exclude_tables: Optional[Sequence[str]] = None,
                 include_tables: Optional[Sequence[str]] = None,
                 object_transfer_settings: Optional['outputs.DatatransferEndpointSettingsPostgresSourceObjectTransferSettings'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsPostgresSourcePassword'] = None,
                 service_schema: Optional[str] = None,
                 slot_gigabyte_lag_limit: Optional[int] = None,
                 user: Optional[str] = None):
        """
        :param 'DatatransferEndpointSettingsPostgresSourceConnectionArgs' connection: Connection settings. The structure is documented below.
        :param str database: Name of the database to transfer.
        :param Sequence[str] exclude_tables: List of tables which will not be transfered, formatted as `schemaname.tablename`.
        :param Sequence[str] include_tables: List of tables to transfer, formatted as `schemaname.tablename`. If omitted or an empty list is specified, all tables will be transferred.
        :param 'DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs' object_transfer_settings: Defines which database schema objects should be transferred, e.g. views, functions, etc.
        :param 'DatatransferEndpointSettingsPostgresSourcePasswordArgs' password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param str service_schema: Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema "public".
        :param int slot_gigabyte_lag_limit: Maximum WAL size held by the replication slot, in gigabytes. Exceeding this limit will result in a replication failure and deletion of the replication slot. Unlimited by default.
        :param str user: User for the database access.
        """
        if collapse_inherit_table is not None:
            pulumi.set(__self__, "collapse_inherit_table", collapse_inherit_table)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)
        if object_transfer_settings is not None:
            pulumi.set(__self__, "object_transfer_settings", object_transfer_settings)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_schema is not None:
            pulumi.set(__self__, "service_schema", service_schema)
        if slot_gigabyte_lag_limit is not None:
            pulumi.set(__self__, "slot_gigabyte_lag_limit", slot_gigabyte_lag_limit)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="collapseInheritTable")
    def collapse_inherit_table(self) -> Optional[bool]:
        return pulumi.get(self, "collapse_inherit_table")

    @property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnection']:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[str]]:
        """
        List of tables which will not be transfered, formatted as `schemaname.tablename`.
        """
        return pulumi.get(self, "exclude_tables")

    @property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[str]]:
        """
        List of tables to transfer, formatted as `schemaname.tablename`. If omitted or an empty list is specified, all tables will be transferred.
        """
        return pulumi.get(self, "include_tables")

    @property
    @pulumi.getter(name="objectTransferSettings")
    def object_transfer_settings(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceObjectTransferSettings']:
        """
        Defines which database schema objects should be transferred, e.g. views, functions, etc.
        """
        return pulumi.get(self, "object_transfer_settings")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourcePassword']:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="serviceSchema")
    def service_schema(self) -> Optional[str]:
        """
        Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema "public".
        """
        return pulumi.get(self, "service_schema")

    @property
    @pulumi.getter(name="slotGigabyteLagLimit")
    def slot_gigabyte_lag_limit(self) -> Optional[int]:
        """
        Maximum WAL size held by the replication slot, in gigabytes. Exceeding this limit will result in a replication failure and deletion of the replication slot. Unlimited by default.
        """
        return pulumi.get(self, "slot_gigabyte_lag_limit")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremise'] = None):
        """
        :param str mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param 'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise MySQL server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[str]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremise']:
        """
        Connection settings of the on-premise MySQL server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None,
                 hosts: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 subnet_id: Optional[str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode'] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        :param Sequence[str] hosts: List of host names of the PostgreSQL server. Exactly one host is expected currently.
        :param int port: Port for the database connection.
        :param str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        List of host names of the PostgreSQL server. Exactly one host is expected currently.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for the database connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled'] = None):
        """
        :param 'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabledArgs' disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param 'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabledArgs' enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled']:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled']:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceObjectTransferSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValues":
            suggest = "default_values"
        elif key == "fkConstraint":
            suggest = "fk_constraint"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "sequenceOwnedBy":
            suggest = "sequence_owned_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceObjectTransferSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceObjectTransferSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceObjectTransferSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cast: Optional[str] = None,
                 collation: Optional[str] = None,
                 constraint: Optional[str] = None,
                 default_values: Optional[str] = None,
                 fk_constraint: Optional[str] = None,
                 function: Optional[str] = None,
                 index: Optional[str] = None,
                 policy: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 rule: Optional[str] = None,
                 sequence: Optional[str] = None,
                 sequence_owned_by: Optional[str] = None,
                 table: Optional[str] = None,
                 trigger: Optional[str] = None,
                 type: Optional[str] = None,
                 view: Optional[str] = None):
        if cast is not None:
            pulumi.set(__self__, "cast", cast)
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if constraint is not None:
            pulumi.set(__self__, "constraint", constraint)
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if fk_constraint is not None:
            pulumi.set(__self__, "fk_constraint", fk_constraint)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if sequence is not None:
            pulumi.set(__self__, "sequence", sequence)
        if sequence_owned_by is not None:
            pulumi.set(__self__, "sequence_owned_by", sequence_owned_by)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def cast(self) -> Optional[str]:
        return pulumi.get(self, "cast")

    @property
    @pulumi.getter
    def collation(self) -> Optional[str]:
        return pulumi.get(self, "collation")

    @property
    @pulumi.getter
    def constraint(self) -> Optional[str]:
        return pulumi.get(self, "constraint")

    @property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[str]:
        return pulumi.get(self, "default_values")

    @property
    @pulumi.getter(name="fkConstraint")
    def fk_constraint(self) -> Optional[str]:
        return pulumi.get(self, "fk_constraint")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def index(self) -> Optional[str]:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def rule(self) -> Optional[str]:
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter
    def sequence(self) -> Optional[str]:
        return pulumi.get(self, "sequence")

    @property
    @pulumi.getter(name="sequenceOwnedBy")
    def sequence_owned_by(self) -> Optional[str]:
        return pulumi.get(self, "sequence_owned_by")

    @property
    @pulumi.getter
    def table(self) -> Optional[str]:
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def trigger(self) -> Optional[str]:
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourcePassword(dict):
    def __init__(__self__, *,
                 raw: Optional[str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTarget(dict):
    def __init__(__self__, *,
                 connection: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnection'] = None,
                 database: Optional[str] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsPostgresTargetPassword'] = None,
                 user: Optional[str] = None):
        """
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionArgs' connection: Connection settings. The structure is documented below.
        :param str database: Name of the database to transfer.
        :param 'DatatransferEndpointSettingsPostgresTargetPasswordArgs' password: Password for the database access. This is a block with a single field named `raw` which should contain the password.
        :param str user: User for the database access.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnection']:
        """
        Connection settings. The structure is documented below.
        """
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetPassword']:
        """
        Password for the database access. This is a block with a single field named `raw` which should contain the password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresTargetConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremise'] = None):
        """
        :param str mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise MySQL server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[str]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremise']:
        """
        Connection settings of the on-premise MySQL server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresTargetConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None,
                 hosts: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 subnet_id: Optional[str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode'] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        :param Sequence[str] hosts: List of host names of the PostgreSQL server. Exactly one host is expected currently.
        :param int port: Port for the database connection.
        :param str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        List of host names of the PostgreSQL server. Exactly one host is expected currently.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for the database connection.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection. The structure is documented below.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled'] = None):
        """
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabledArgs' disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabledArgs' enabled: If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled']:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled']:
        """
        If this attribute is not an empty block, then TLS is used for the server connection. The structure is documented below.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None):
        """
        :param str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class FunctionContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zipFilename":
            suggest = "zip_filename"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zip_filename: str):
        pulumi.set(__self__, "zip_filename", zip_filename)

    @property
    @pulumi.getter(name="zipFilename")
    def zip_filename(self) -> str:
        return pulumi.get(self, "zip_filename")


@pulumi.output_type
class FunctionPackage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "objectName":
            suggest = "object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionPackage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionPackage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionPackage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 object_name: str,
                 sha256: Optional[str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "object_name", object_name)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> str:
        return pulumi.get(self, "object_name")

    @property
    @pulumi.getter
    def sha256(self) -> Optional[str]:
        return pulumi.get(self, "sha256")


@pulumi.output_type
class FunctionScalingPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zoneInstancesLimit":
            suggest = "zone_instances_limit"
        elif key == "zoneRequestsLimit":
            suggest = "zone_requests_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionScalingPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionScalingPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionScalingPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: str,
                 zone_instances_limit: Optional[int] = None,
                 zone_requests_limit: Optional[int] = None):
        pulumi.set(__self__, "tag", tag)
        if zone_instances_limit is not None:
            pulumi.set(__self__, "zone_instances_limit", zone_instances_limit)
        if zone_requests_limit is not None:
            pulumi.set(__self__, "zone_requests_limit", zone_requests_limit)

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zoneInstancesLimit")
    def zone_instances_limit(self) -> Optional[int]:
        return pulumi.get(self, "zone_instances_limit")

    @property
    @pulumi.getter(name="zoneRequestsLimit")
    def zone_requests_limit(self) -> Optional[int]:
        return pulumi.get(self, "zone_requests_limit")


@pulumi.output_type
class FunctionTriggerDlq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueId":
            suggest = "queue_id"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerDlq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerDlq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerDlq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_id: str,
                 service_account_id: str):
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> str:
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class FunctionTriggerFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryAttempts":
            suggest = "retry_attempts"
        elif key == "retryInterval":
            suggest = "retry_interval"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 retry_attempts: Optional[str] = None,
                 retry_interval: Optional[str] = None,
                 service_account_id: Optional[str] = None,
                 tag: Optional[str] = None):
        pulumi.set(__self__, "id", id)
        if retry_attempts is not None:
            pulumi.set(__self__, "retry_attempts", retry_attempts)
        if retry_interval is not None:
            pulumi.set(__self__, "retry_interval", retry_interval)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> Optional[str]:
        return pulumi.get(self, "retry_attempts")

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[str]:
        return pulumi.get(self, "retry_interval")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[str]:
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class FunctionTriggerIot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryId":
            suggest = "registry_id"
        elif key == "deviceId":
            suggest = "device_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerIot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerIot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerIot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_id: str,
                 device_id: Optional[str] = None,
                 topic: Optional[str] = None):
        pulumi.set(__self__, "registry_id", registry_id)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> str:
        return pulumi.get(self, "registry_id")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[str]:
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        return pulumi.get(self, "topic")


@pulumi.output_type
class FunctionTriggerLogGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "logGroupIds":
            suggest = "log_group_ids"
        elif key == "batchSize":
            suggest = "batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerLogGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerLogGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerLogGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: str,
                 log_group_ids: Sequence[str],
                 batch_size: Optional[str] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "log_group_ids", log_group_ids)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> str:
        return pulumi.get(self, "batch_cutoff")

    @property
    @pulumi.getter(name="logGroupIds")
    def log_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "log_group_ids")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[str]:
        return pulumi.get(self, "batch_size")


@pulumi.output_type
class FunctionTriggerLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "resourceIds":
            suggest = "resource_ids"
        elif key == "resourceTypes":
            suggest = "resource_types"
        elif key == "batchSize":
            suggest = "batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: str,
                 group_id: str,
                 levels: Sequence[str],
                 resource_ids: Sequence[str],
                 resource_types: Sequence[str],
                 batch_size: Optional[str] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "resource_ids", resource_ids)
        pulumi.set(__self__, "resource_types", resource_types)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> str:
        return pulumi.get(self, "batch_cutoff")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def levels(self) -> Sequence[str]:
        return pulumi.get(self, "levels")

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Sequence[str]:
        return pulumi.get(self, "resource_ids")

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Sequence[str]:
        return pulumi.get(self, "resource_types")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[str]:
        return pulumi.get(self, "batch_size")


@pulumi.output_type
class FunctionTriggerMessageQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "queueId":
            suggest = "queue_id"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "visibilityTimeout":
            suggest = "visibility_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerMessageQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerMessageQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerMessageQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: str,
                 queue_id: str,
                 service_account_id: str,
                 batch_size: Optional[str] = None,
                 visibility_timeout: Optional[str] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> str:
        return pulumi.get(self, "batch_cutoff")

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> str:
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[str]:
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[str]:
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class FunctionTriggerObjectStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketId":
            suggest = "bucket_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerObjectStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerObjectStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerObjectStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_id: str,
                 create: Optional[bool] = None,
                 delete: Optional[bool] = None,
                 prefix: Optional[str] = None,
                 suffix: Optional[str] = None,
                 update: Optional[bool] = None):
        pulumi.set(__self__, "bucket_id", bucket_id)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter(name="bucketId")
    def bucket_id(self) -> str:
        return pulumi.get(self, "bucket_id")

    @property
    @pulumi.getter
    def create(self) -> Optional[bool]:
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[bool]:
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def suffix(self) -> Optional[str]:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def update(self) -> Optional[bool]:
        return pulumi.get(self, "update")


@pulumi.output_type
class FunctionTriggerTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str):
        pulumi.set(__self__, "cron_expression", cron_expression)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")


@pulumi.output_type
class KubernetesClusterKmsProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKmsProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKmsProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKmsProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: Optional[str] = None):
        """
        :param str key_id: KMS key ID.
        """
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        KMS key ID.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class KubernetesClusterMaster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"
        elif key == "externalV4Address":
            suggest = "external_v4_address"
        elif key == "externalV4Endpoint":
            suggest = "external_v4_endpoint"
        elif key == "internalV4Address":
            suggest = "internal_v4_address"
        elif key == "internalV4Endpoint":
            suggest = "internal_v4_endpoint"
        elif key == "maintenancePolicy":
            suggest = "maintenance_policy"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "versionInfos":
            suggest = "version_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMaster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMaster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMaster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[str] = None,
                 external_v4_address: Optional[str] = None,
                 external_v4_endpoint: Optional[str] = None,
                 internal_v4_address: Optional[str] = None,
                 internal_v4_endpoint: Optional[str] = None,
                 maintenance_policy: Optional['outputs.KubernetesClusterMasterMaintenancePolicy'] = None,
                 public_ip: Optional[bool] = None,
                 regional: Optional['outputs.KubernetesClusterMasterRegional'] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 version: Optional[str] = None,
                 version_infos: Optional[Sequence['outputs.KubernetesClusterMasterVersionInfo']] = None,
                 zonal: Optional['outputs.KubernetesClusterMasterZonal'] = None):
        """
        :param str cluster_ca_certificate: (Computed) PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        :param str external_v4_address: (Computed) An IPv4 external network address that is assigned to the master.
        :param str external_v4_endpoint: (Computed) External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        :param str internal_v4_address: (Computed) An IPv4 internal network address that is assigned to the master.
        :param str internal_v4_endpoint: (Computed) Internal endpoint that can be used to connect to the master from cloud networks.
        :param 'KubernetesClusterMasterMaintenancePolicyArgs' maintenance_policy: (Optional) (Computed) Maintenance policy for Kubernetes master.
               If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time.
               Revision upgrades are performed only within the same minor version, e.g. 1.13.
               Minor version upgrades (e.g. 1.13->1.14) should be performed manually. The structure is documented below.
        :param bool public_ip: (Optional) (Computed) Boolean flag. When `true`, Kubernetes master will have visible ipv4 address.
        :param 'KubernetesClusterMasterRegionalArgs' regional: (Optional) Initialize parameters for Regional Master (highly available master). The structure is documented below.
        :param Sequence[str] security_group_ids: (Optional) List of security group IDs to which the Kubernetes cluster belongs.
        :param str version: (Optional) (Computed) Version of Kubernetes that will be used for master.
        :param Sequence['KubernetesClusterMasterVersionInfoArgs'] version_infos: (Computed) Information about cluster version. The structure is documented below.
        :param 'KubernetesClusterMasterZonalArgs' zonal: (Optional) Initialize parameters for Zonal Master (single node master). The structure is documented below.
        """
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if external_v4_address is not None:
            pulumi.set(__self__, "external_v4_address", external_v4_address)
        if external_v4_endpoint is not None:
            pulumi.set(__self__, "external_v4_endpoint", external_v4_endpoint)
        if internal_v4_address is not None:
            pulumi.set(__self__, "internal_v4_address", internal_v4_address)
        if internal_v4_endpoint is not None:
            pulumi.set(__self__, "internal_v4_endpoint", internal_v4_endpoint)
        if maintenance_policy is not None:
            pulumi.set(__self__, "maintenance_policy", maintenance_policy)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if regional is not None:
            pulumi.set(__self__, "regional", regional)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_infos is not None:
            pulumi.set(__self__, "version_infos", version_infos)
        if zonal is not None:
            pulumi.set(__self__, "zonal", zonal)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[str]:
        """
        (Computed) PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="externalV4Address")
    def external_v4_address(self) -> Optional[str]:
        """
        (Computed) An IPv4 external network address that is assigned to the master.
        """
        return pulumi.get(self, "external_v4_address")

    @property
    @pulumi.getter(name="externalV4Endpoint")
    def external_v4_endpoint(self) -> Optional[str]:
        """
        (Computed) External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        return pulumi.get(self, "external_v4_endpoint")

    @property
    @pulumi.getter(name="internalV4Address")
    def internal_v4_address(self) -> Optional[str]:
        """
        (Computed) An IPv4 internal network address that is assigned to the master.
        """
        return pulumi.get(self, "internal_v4_address")

    @property
    @pulumi.getter(name="internalV4Endpoint")
    def internal_v4_endpoint(self) -> Optional[str]:
        """
        (Computed) Internal endpoint that can be used to connect to the master from cloud networks.
        """
        return pulumi.get(self, "internal_v4_endpoint")

    @property
    @pulumi.getter(name="maintenancePolicy")
    def maintenance_policy(self) -> Optional['outputs.KubernetesClusterMasterMaintenancePolicy']:
        """
        (Optional) (Computed) Maintenance policy for Kubernetes master.
        If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time.
        Revision upgrades are performed only within the same minor version, e.g. 1.13.
        Minor version upgrades (e.g. 1.13->1.14) should be performed manually. The structure is documented below.
        """
        return pulumi.get(self, "maintenance_policy")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[bool]:
        """
        (Optional) (Computed) Boolean flag. When `true`, Kubernetes master will have visible ipv4 address.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def regional(self) -> Optional['outputs.KubernetesClusterMasterRegional']:
        """
        (Optional) Initialize parameters for Regional Master (highly available master). The structure is documented below.
        """
        return pulumi.get(self, "regional")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        (Optional) List of security group IDs to which the Kubernetes cluster belongs.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        (Optional) (Computed) Version of Kubernetes that will be used for master.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionInfos")
    def version_infos(self) -> Optional[Sequence['outputs.KubernetesClusterMasterVersionInfo']]:
        """
        (Computed) Information about cluster version. The structure is documented below.
        """
        return pulumi.get(self, "version_infos")

    @property
    @pulumi.getter
    def zonal(self) -> Optional['outputs.KubernetesClusterMasterZonal']:
        """
        (Optional) Initialize parameters for Zonal Master (single node master). The structure is documented below.
        """
        return pulumi.get(self, "zonal")


@pulumi.output_type
class KubernetesClusterMasterMaintenancePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoUpgrade":
            suggest = "auto_upgrade"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterMaintenancePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterMaintenancePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterMaintenancePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_upgrade: bool,
                 maintenance_windows: Optional[Sequence['outputs.KubernetesClusterMasterMaintenancePolicyMaintenanceWindow']] = None):
        """
        :param bool auto_upgrade: (Required) Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        :param Sequence['KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: (Optional) (Computed) This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time.
               To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`.
               Please see `zonal_cluster_resource_name` config example.
        """
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> bool:
        """
        (Required) Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.KubernetesClusterMasterMaintenancePolicyMaintenanceWindow']]:
        """
        (Optional) (Computed) This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time.
        To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`.
        Please see `zonal_cluster_resource_name` config example.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class KubernetesClusterMasterMaintenancePolicyMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterMaintenancePolicyMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: str,
                 start_time: str,
                 day: Optional[str] = None):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        if day is not None:
            pulumi.set(__self__, "day", day)

    @property
    @pulumi.getter
    def duration(self) -> str:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        return pulumi.get(self, "day")


@pulumi.output_type
class KubernetesClusterMasterRegional(dict):
    def __init__(__self__, *,
                 region: str,
                 locations: Optional[Sequence['outputs.KubernetesClusterMasterRegionalLocation']] = None):
        """
        :param str region: (Required) Name of availability region (e.g. "ru-central1"), where master instances will be allocated.
        :param Sequence['KubernetesClusterMasterRegionalLocationArgs'] locations: Array of locations, where master instances will be allocated. The structure is documented below.
        """
        pulumi.set(__self__, "region", region)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        (Required) Name of availability region (e.g. "ru-central1"), where master instances will be allocated.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.KubernetesClusterMasterRegionalLocation']]:
        """
        Array of locations, where master instances will be allocated. The structure is documented below.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class KubernetesClusterMasterRegionalLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterRegionalLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterRegionalLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterRegionalLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str subnet_id: (Optional) ID of the subnet.
        :param str zone: (Optional) ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        (Optional) ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        (Optional) ID of the availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class KubernetesClusterMasterVersionInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentVersion":
            suggest = "current_version"
        elif key == "newRevisionAvailable":
            suggest = "new_revision_available"
        elif key == "newRevisionSummary":
            suggest = "new_revision_summary"
        elif key == "versionDeprecated":
            suggest = "version_deprecated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterVersionInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterVersionInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterVersionInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_version: Optional[str] = None,
                 new_revision_available: Optional[bool] = None,
                 new_revision_summary: Optional[str] = None,
                 version_deprecated: Optional[bool] = None):
        """
        :param str current_version: Current Kubernetes version, major.minor (e.g. 1.15).
        :param bool new_revision_available: Boolean flag.
               Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
               as some internal component updates - new features or bug fixes in yandex-specific
               components either on the master or nodes.
        :param str new_revision_summary: Human readable description of the changes to be applied
               when updating to the latest revision. Empty if new_revision_available is false.
        :param bool version_deprecated: Boolean flag. The current version is on the deprecation schedule,
               component (master or node group) should be upgraded.
        """
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if new_revision_available is not None:
            pulumi.set(__self__, "new_revision_available", new_revision_available)
        if new_revision_summary is not None:
            pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        if version_deprecated is not None:
            pulumi.set(__self__, "version_deprecated", version_deprecated)

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[str]:
        """
        Current Kubernetes version, major.minor (e.g. 1.15).
        """
        return pulumi.get(self, "current_version")

    @property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> Optional[bool]:
        """
        Boolean flag.
        Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
        as some internal component updates - new features or bug fixes in yandex-specific
        components either on the master or nodes.
        """
        return pulumi.get(self, "new_revision_available")

    @property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> Optional[str]:
        """
        Human readable description of the changes to be applied
        when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> Optional[bool]:
        """
        Boolean flag. The current version is on the deprecation schedule,
        component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class KubernetesClusterMasterZonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterZonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterZonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterZonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str subnet_id: (Optional) ID of the subnet.
        :param str zone: (Optional) ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        (Optional) ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        (Optional) ID of the availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class KubernetesClusterNetworkImplementation(dict):
    def __init__(__self__, *,
                 cilium: Optional['outputs.KubernetesClusterNetworkImplementationCilium'] = None):
        """
        :param 'KubernetesClusterNetworkImplementationCiliumArgs' cilium: (Optional) Cilium network implementation configuration. No options exist.
        """
        if cilium is not None:
            pulumi.set(__self__, "cilium", cilium)

    @property
    @pulumi.getter
    def cilium(self) -> Optional['outputs.KubernetesClusterNetworkImplementationCilium']:
        """
        (Optional) Cilium network implementation configuration. No options exist.
        """
        return pulumi.get(self, "cilium")


@pulumi.output_type
class KubernetesClusterNetworkImplementationCilium(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class KubernetesNodeGroupAllocationPolicy(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence['outputs.KubernetesNodeGroupAllocationPolicyLocation']] = None):
        """
        :param Sequence['KubernetesNodeGroupAllocationPolicyLocationArgs'] locations: Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.KubernetesNodeGroupAllocationPolicyLocation']]:
        """
        Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class KubernetesNodeGroupAllocationPolicyLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupAllocationPolicyLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupAllocationPolicyLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupAllocationPolicyLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str subnet_id: ID of the subnet, that will be used by one compute instance in node group.
        :param str zone: ID of the availability zone where for one compute instance in node group.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        ID of the subnet, that will be used by one compute instance in node group.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        ID of the availability zone where for one compute instance in node group.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class KubernetesNodeGroupDeployPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxExpansion":
            suggest = "max_expansion"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupDeployPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupDeployPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupDeployPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_expansion: int,
                 max_unavailable: int):
        """
        :param int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        :param int max_unavailable: The maximum number of running instances that can be taken offline during update.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        """
        return pulumi.get(self, "max_expansion")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        """
        The maximum number of running instances that can be taken offline during update.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "containerRuntime":
            suggest = "container_runtime"
        elif key == "networkAccelerationType":
            suggest = "network_acceleration_type"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "placementPolicy":
            suggest = "placement_policy"
        elif key == "platformId":
            suggest = "platform_id"
        elif key == "schedulingPolicy":
            suggest = "scheduling_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk: Optional['outputs.KubernetesNodeGroupInstanceTemplateBootDisk'] = None,
                 container_runtime: Optional['outputs.KubernetesNodeGroupInstanceTemplateContainerRuntime'] = None,
                 metadata: Optional[Mapping[str, str]] = None,
                 nat: Optional[bool] = None,
                 network_acceleration_type: Optional[str] = None,
                 network_interfaces: Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterface']] = None,
                 placement_policy: Optional['outputs.KubernetesNodeGroupInstanceTemplatePlacementPolicy'] = None,
                 platform_id: Optional[str] = None,
                 resources: Optional['outputs.KubernetesNodeGroupInstanceTemplateResources'] = None,
                 scheduling_policy: Optional['outputs.KubernetesNodeGroupInstanceTemplateSchedulingPolicy'] = None):
        """
        :param 'KubernetesNodeGroupInstanceTemplateBootDiskArgs' boot_disk: The specifications for boot disks that will be attached to the instance. The structure is documented below.
        :param 'KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs' container_runtime: Container runtime configuration. The structure is documented below.
               ---
        :param Mapping[str, str] metadata: The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
               * `resources.0.memory` - The memory size allocated to the instance.
               * `resources.0.cores` - Number of CPU cores allocated to the instance.
               * `resources.0.core_fraction` - Baseline core performance as a percent.
               * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        :param bool nat: A public address that can be used to access the internet over NAT.
        :param str network_acceleration_type: Type of network acceleration. Values: `standard`, `software_accelerated`.
        :param Sequence['KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: An array with the network interfaces that will be attached to the instance. The structure is documented below.
        :param 'KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs' placement_policy: The placement policy configuration. The structure is documented below.
        :param str platform_id: The ID of the hardware platform configuration for the node group compute instances.
        :param 'KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs' scheduling_policy: The scheduling policy for the instances in node group. The structure is documented below.
        """
        if boot_disk is not None:
            pulumi.set(__self__, "boot_disk", boot_disk)
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if network_acceleration_type is not None:
            pulumi.set(__self__, "network_acceleration_type", network_acceleration_type)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateBootDisk']:
        """
        The specifications for boot disks that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateContainerRuntime']:
        """
        Container runtime configuration. The structure is documented below.
        ---
        """
        return pulumi.get(self, "container_runtime")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
        * `resources.0.memory` - The memory size allocated to the instance.
        * `resources.0.cores` - Number of CPU cores allocated to the instance.
        * `resources.0.core_fraction` - Baseline core performance as a percent.
        * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def nat(self) -> Optional[bool]:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="networkAccelerationType")
    def network_acceleration_type(self) -> Optional[str]:
        """
        Type of network acceleration. Values: `standard`, `software_accelerated`.
        """
        return pulumi.get(self, "network_acceleration_type")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterface']]:
        """
        An array with the network interfaces that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplatePlacementPolicy']:
        """
        The placement policy configuration. The structure is documented below.
        """
        return pulumi.get(self, "placement_policy")

    @property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[str]:
        """
        The ID of the hardware platform configuration for the node group compute instances.
        """
        return pulumi.get(self, "platform_id")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateResources']:
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateSchedulingPolicy']:
        """
        The scheduling policy for the instances in node group. The structure is documented below.
        """
        return pulumi.get(self, "scheduling_policy")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateBootDisk(dict):
    def __init__(__self__, *,
                 size: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int size: The number of instances in the node group.
        :param str type: Type of container runtime. Values: `docker`, `containerd`.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The number of instances in the node group.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateContainerRuntime(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Type of container runtime. Values: `docker`, `containerd`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Sequence[str],
                 ipv4: Optional[bool] = None,
                 ipv6: Optional[bool] = None,
                 nat: Optional[bool] = None,
                 security_group_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] subnet_ids: The IDs of the subnets.
        :param bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param bool ipv6: If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param bool nat: A public address that can be used to access the internet over NAT.
        :param Sequence[str] security_group_ids: Security group ids for network interface.
        """
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[bool]:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[bool]:
        """
        If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter
    def nat(self) -> Optional[bool]:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplatePlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementGroupId":
            suggest = "placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplatePlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_group_id: str):
        """
        :param str placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreFraction":
            suggest = "core_fraction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_fraction: Optional[int] = None,
                 cores: Optional[int] = None,
                 gpus: Optional[int] = None,
                 memory: Optional[float] = None):
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[int]:
        return pulumi.get(self, "core_fraction")

    @property
    @pulumi.getter
    def cores(self) -> Optional[int]:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def gpus(self) -> Optional[int]:
        return pulumi.get(self, "gpus")

    @property
    @pulumi.getter
    def memory(self) -> Optional[float]:
        return pulumi.get(self, "memory")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateSchedulingPolicy(dict):
    def __init__(__self__, *,
                 preemptible: Optional[bool] = None):
        """
        :param bool preemptible: Specifies if the instance is preemptible. Defaults to false.
               ---
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        Specifies if the instance is preemptible. Defaults to false.
        ---
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class KubernetesNodeGroupMaintenancePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRepair":
            suggest = "auto_repair"
        elif key == "autoUpgrade":
            suggest = "auto_upgrade"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupMaintenancePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupMaintenancePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupMaintenancePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_repair: bool,
                 auto_upgrade: bool,
                 maintenance_windows: Optional[Sequence['outputs.KubernetesNodeGroupMaintenancePolicyMaintenanceWindow']] = None):
        """
        :param bool auto_repair: Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
        :param bool auto_upgrade: Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
        :param Sequence['KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> bool:
        """
        Boolean flag that specifies if node group can be repaired automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_repair")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> bool:
        """
        Boolean flag that specifies if node group can be upgraded automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.KubernetesNodeGroupMaintenancePolicyMaintenanceWindow']]:
        """
        (Computed) Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class KubernetesNodeGroupMaintenancePolicyMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupMaintenancePolicyMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: str,
                 start_time: str,
                 day: Optional[str] = None):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        if day is not None:
            pulumi.set(__self__, "day", day)

    @property
    @pulumi.getter
    def duration(self) -> str:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        return pulumi.get(self, "day")


@pulumi.output_type
class KubernetesNodeGroupScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScale":
            suggest = "auto_scale"
        elif key == "fixedScale":
            suggest = "fixed_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scale: Optional['outputs.KubernetesNodeGroupScalePolicyAutoScale'] = None,
                 fixed_scale: Optional['outputs.KubernetesNodeGroupScalePolicyFixedScale'] = None):
        """
        :param 'KubernetesNodeGroupScalePolicyAutoScaleArgs' auto_scale: Scale policy for an autoscaled node group. The structure is documented below.
        :param 'KubernetesNodeGroupScalePolicyFixedScaleArgs' fixed_scale: Scale policy for a fixed scale node group. The structure is documented below.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if fixed_scale is not None:
            pulumi.set(__self__, "fixed_scale", fixed_scale)

    @property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional['outputs.KubernetesNodeGroupScalePolicyAutoScale']:
        """
        Scale policy for an autoscaled node group. The structure is documented below.
        """
        return pulumi.get(self, "auto_scale")

    @property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> Optional['outputs.KubernetesNodeGroupScalePolicyFixedScale']:
        """
        Scale policy for a fixed scale node group. The structure is documented below.
        """
        return pulumi.get(self, "fixed_scale")


@pulumi.output_type
class KubernetesNodeGroupScalePolicyAutoScale(dict):
    def __init__(__self__, *,
                 initial: int,
                 max: int,
                 min: int):
        """
        :param int initial: Initial number of instances in the node group.
        :param int max: Maximum number of instances in the node group.
        :param int min: Minimum number of instances in the node group.
        """
        pulumi.set(__self__, "initial", initial)
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def initial(self) -> int:
        """
        Initial number of instances in the node group.
        """
        return pulumi.get(self, "initial")

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum number of instances in the node group.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum number of instances in the node group.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class KubernetesNodeGroupScalePolicyFixedScale(dict):
    def __init__(__self__, *,
                 size: Optional[int] = None):
        """
        :param int size: The number of instances in the node group.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The number of instances in the node group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class KubernetesNodeGroupVersionInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentVersion":
            suggest = "current_version"
        elif key == "newRevisionAvailable":
            suggest = "new_revision_available"
        elif key == "newRevisionSummary":
            suggest = "new_revision_summary"
        elif key == "versionDeprecated":
            suggest = "version_deprecated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupVersionInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupVersionInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupVersionInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_version: Optional[str] = None,
                 new_revision_available: Optional[bool] = None,
                 new_revision_summary: Optional[str] = None,
                 version_deprecated: Optional[bool] = None):
        """
        :param str current_version: Current Kubernetes version, major.minor (e.g. 1.15).
        :param bool new_revision_available: True/false flag.
               Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
               as some internal component updates - new features or bug fixes in yandex-specific
               components either on the master or nodes.
        :param str new_revision_summary: Human readable description of the changes to be applied
               when updating to the latest revision. Empty if new_revision_available is false.
        :param bool version_deprecated: True/false flag. The current version is on the deprecation schedule,
               component (master or node group) should be upgraded.
        """
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if new_revision_available is not None:
            pulumi.set(__self__, "new_revision_available", new_revision_available)
        if new_revision_summary is not None:
            pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        if version_deprecated is not None:
            pulumi.set(__self__, "version_deprecated", version_deprecated)

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[str]:
        """
        Current Kubernetes version, major.minor (e.g. 1.15).
        """
        return pulumi.get(self, "current_version")

    @property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> Optional[bool]:
        """
        True/false flag.
        Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
        as some internal component updates - new features or bug fixes in yandex-specific
        components either on the master or nodes.
        """
        return pulumi.get(self, "new_revision_available")

    @property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> Optional[str]:
        """
        Human readable description of the changes to be applied
        when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> Optional[bool]:
        """
        True/false flag. The current version is on the deprecation schedule,
        component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupId":
            suggest = "target_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerAttachedTargetGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthchecks: Sequence['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheck'],
                 target_group_id: str):
        """
        :param Sequence['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs'] healthchecks: A HealthCheck resource. The structure is documented below.
        :param str target_group_id: ID of the target group.
        """
        pulumi.set(__self__, "healthchecks", healthchecks)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @property
    @pulumi.getter
    def healthchecks(self) -> Sequence['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheck']:
        """
        A HealthCheck resource. The structure is documented below.
        """
        return pulumi.get(self, "healthchecks")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        ID of the target group.
        """
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpOptions":
            suggest = "http_options"
        elif key == "tcpOptions":
            suggest = "tcp_options"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerAttachedTargetGroupHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroupHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroupHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 healthy_threshold: Optional[int] = None,
                 http_options: Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions'] = None,
                 interval: Optional[int] = None,
                 tcp_options: Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions'] = None,
                 timeout: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param str name: Name of the listener. The name must be unique for each listener on a single load balancer.
        :param int healthy_threshold: Number of successful health checks required in order to set the `HEALTHY` status for the target.
        :param 'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs' http_options: Options for HTTP health check. The structure is documented below.
        :param int interval: The interval between health checks. The default is 2 seconds.
        :param 'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs' tcp_options: Options for TCP health check. The structure is documented below.
        :param int timeout: Timeout for a target to return a response for the health check. The default is 1 second.
        :param int unhealthy_threshold: Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        pulumi.set(__self__, "name", name)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_options is not None:
            pulumi.set(__self__, "http_options", http_options)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the listener. The name must be unique for each listener on a single load balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of successful health checks required in order to set the `HEALTHY` status for the target.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions']:
        """
        Options for HTTP health check. The structure is documented below.
        """
        return pulumi.get(self, "http_options")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The interval between health checks. The default is 2 seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions']:
        """
        Options for TCP health check. The structure is documented below.
        """
        return pulumi.get(self, "tcp_options")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Timeout for a target to return a response for the health check. The default is 1 second.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions(dict):
    def __init__(__self__, *,
                 port: int,
                 path: Optional[str] = None):
        """
        :param int port: Port for incoming traffic.
        :param str path: URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
        pulumi.set(__self__, "port", port)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions(dict):
    def __init__(__self__, *,
                 port: int):
        """
        :param int port: Port for incoming traffic.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class LbNetworkLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalAddressSpec":
            suggest = "external_address_spec"
        elif key == "internalAddressSpec":
            suggest = "internal_address_spec"
        elif key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 port: int,
                 external_address_spec: Optional['outputs.LbNetworkLoadBalancerListenerExternalAddressSpec'] = None,
                 internal_address_spec: Optional['outputs.LbNetworkLoadBalancerListenerInternalAddressSpec'] = None,
                 protocol: Optional[str] = None,
                 target_port: Optional[int] = None):
        """
        :param str name: Name of the listener. The name must be unique for each listener on a single load balancer.
        :param int port: Port for incoming traffic.
        :param 'LbNetworkLoadBalancerListenerExternalAddressSpecArgs' external_address_spec: External IP address specification. The structure is documented below.
        :param 'LbNetworkLoadBalancerListenerInternalAddressSpecArgs' internal_address_spec: Internal IP address specification. The structure is documented below.
        :param str protocol: Protocol for incoming traffic. TCP or UDP and the default is TCP.
        :param int target_port: Port of a target. The default is the same as listener's port.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if external_address_spec is not None:
            pulumi.set(__self__, "external_address_spec", external_address_spec)
        if internal_address_spec is not None:
            pulumi.set(__self__, "internal_address_spec", internal_address_spec)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the listener. The name must be unique for each listener on a single load balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="externalAddressSpec")
    def external_address_spec(self) -> Optional['outputs.LbNetworkLoadBalancerListenerExternalAddressSpec']:
        """
        External IP address specification. The structure is documented below.
        """
        return pulumi.get(self, "external_address_spec")

    @property
    @pulumi.getter(name="internalAddressSpec")
    def internal_address_spec(self) -> Optional['outputs.LbNetworkLoadBalancerListenerInternalAddressSpec']:
        """
        Internal IP address specification. The structure is documented below.
        """
        return pulumi.get(self, "internal_address_spec")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for incoming traffic. TCP or UDP and the default is TCP.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[int]:
        """
        Port of a target. The default is the same as listener's port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class LbNetworkLoadBalancerListenerExternalAddressSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipVersion":
            suggest = "ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerListenerExternalAddressSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerListenerExternalAddressSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerListenerExternalAddressSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 ip_version: Optional[str] = None):
        """
        :param str address: Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        :param str ip_version: IP version of the internal addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        """
        IP version of the internal addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        return pulumi.get(self, "ip_version")


@pulumi.output_type
class LbNetworkLoadBalancerListenerInternalAddressSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "ipVersion":
            suggest = "ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerListenerInternalAddressSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerListenerInternalAddressSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerListenerInternalAddressSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 address: Optional[str] = None,
                 ip_version: Optional[str] = None):
        """
        :param str subnet_id: ID of the subnet to which the internal IP address belongs.
        :param str address: Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        :param str ip_version: IP version of the internal addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        ID of the subnet to which the internal IP address belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[str]:
        """
        IP version of the internal addresses that the load balancer works with. Must be one of ipv4 or ipv6. The default is ipv4.
        """
        return pulumi.get(self, "ip_version")


@pulumi.output_type
class LbTargetGroupTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbTargetGroupTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbTargetGroupTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbTargetGroupTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 subnet_id: str):
        """
        :param str address: IP address of the target.
        :param str subnet_id: ID of the subnet that targets are connected to. 
               All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        IP address of the target.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        ID of the subnet that targets are connected to. 
        All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbClickhouseClusterAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "webSql":
            suggest = "web_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[bool] = None,
                 metrika: Optional[bool] = None,
                 serverless: Optional[bool] = None,
                 web_sql: Optional[bool] = None):
        """
        :param bool data_lens: Allow access for DataLens. Can be either `true` or `false`.
        :param bool metrika: Allow access for Yandex.Metrika. Can be either `true` or `false`.
        :param bool serverless: Allow access for Serverless. Can be either `true` or `false`.
        :param bool web_sql: Allow access for Web SQL. Can be either `true` or `false`.
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if metrika is not None:
            pulumi.set(__self__, "metrika", metrika)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[bool]:
        """
        Allow access for DataLens. Can be either `true` or `false`.
        """
        return pulumi.get(self, "data_lens")

    @property
    @pulumi.getter
    def metrika(self) -> Optional[bool]:
        """
        Allow access for Yandex.Metrika. Can be either `true` or `false`.
        """
        return pulumi.get(self, "metrika")

    @property
    @pulumi.getter
    def serverless(self) -> Optional[bool]:
        """
        Allow access for Serverless. Can be either `true` or `false`.
        """
        return pulumi.get(self, "serverless")

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[bool]:
        """
        Allow access for Web SQL. Can be either `true` or `false`.
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class MdbClickhouseClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbClickhouseClusterClickhouse(dict):
    def __init__(__self__, *,
                 resources: 'outputs.MdbClickhouseClusterClickhouseResources',
                 config: Optional['outputs.MdbClickhouseClusterClickhouseConfig'] = None):
        """
        :param 'MdbClickhouseClusterClickhouseResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        :param 'MdbClickhouseClusterClickhouseConfigArgs' config: Main ClickHouse cluster configuration.
        """
        pulumi.set(__self__, "resources", resources)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbClickhouseClusterClickhouseResources':
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfig']:
        """
        Main ClickHouse cluster configuration.
        """
        return pulumi.get(self, "config")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundPoolSize":
            suggest = "background_pool_size"
        elif key == "backgroundSchedulePoolSize":
            suggest = "background_schedule_pool_size"
        elif key == "geobaseUri":
            suggest = "geobase_uri"
        elif key == "graphiteRollups":
            suggest = "graphite_rollups"
        elif key == "kafkaTopics":
            suggest = "kafka_topics"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "markCacheSize":
            suggest = "mark_cache_size"
        elif key == "maxConcurrentQueries":
            suggest = "max_concurrent_queries"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPartitionSizeToDrop":
            suggest = "max_partition_size_to_drop"
        elif key == "maxTableSizeToDrop":
            suggest = "max_table_size_to_drop"
        elif key == "mergeTree":
            suggest = "merge_tree"
        elif key == "metricLogEnabled":
            suggest = "metric_log_enabled"
        elif key == "metricLogRetentionSize":
            suggest = "metric_log_retention_size"
        elif key == "metricLogRetentionTime":
            suggest = "metric_log_retention_time"
        elif key == "partLogRetentionSize":
            suggest = "part_log_retention_size"
        elif key == "partLogRetentionTime":
            suggest = "part_log_retention_time"
        elif key == "queryLogRetentionSize":
            suggest = "query_log_retention_size"
        elif key == "queryLogRetentionTime":
            suggest = "query_log_retention_time"
        elif key == "queryThreadLogEnabled":
            suggest = "query_thread_log_enabled"
        elif key == "queryThreadLogRetentionSize":
            suggest = "query_thread_log_retention_size"
        elif key == "queryThreadLogRetentionTime":
            suggest = "query_thread_log_retention_time"
        elif key == "textLogEnabled":
            suggest = "text_log_enabled"
        elif key == "textLogLevel":
            suggest = "text_log_level"
        elif key == "textLogRetentionSize":
            suggest = "text_log_retention_size"
        elif key == "textLogRetentionTime":
            suggest = "text_log_retention_time"
        elif key == "traceLogEnabled":
            suggest = "trace_log_enabled"
        elif key == "traceLogRetentionSize":
            suggest = "trace_log_retention_size"
        elif key == "traceLogRetentionTime":
            suggest = "trace_log_retention_time"
        elif key == "uncompressedCacheSize":
            suggest = "uncompressed_cache_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 background_pool_size: Optional[int] = None,
                 background_schedule_pool_size: Optional[int] = None,
                 compressions: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigCompression']] = None,
                 geobase_uri: Optional[str] = None,
                 graphite_rollups: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollup']] = None,
                 kafka: Optional['outputs.MdbClickhouseClusterClickhouseConfigKafka'] = None,
                 kafka_topics: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopic']] = None,
                 keep_alive_timeout: Optional[int] = None,
                 log_level: Optional[str] = None,
                 mark_cache_size: Optional[int] = None,
                 max_concurrent_queries: Optional[int] = None,
                 max_connections: Optional[int] = None,
                 max_partition_size_to_drop: Optional[int] = None,
                 max_table_size_to_drop: Optional[int] = None,
                 merge_tree: Optional['outputs.MdbClickhouseClusterClickhouseConfigMergeTree'] = None,
                 metric_log_enabled: Optional[bool] = None,
                 metric_log_retention_size: Optional[int] = None,
                 metric_log_retention_time: Optional[int] = None,
                 part_log_retention_size: Optional[int] = None,
                 part_log_retention_time: Optional[int] = None,
                 query_log_retention_size: Optional[int] = None,
                 query_log_retention_time: Optional[int] = None,
                 query_thread_log_enabled: Optional[bool] = None,
                 query_thread_log_retention_size: Optional[int] = None,
                 query_thread_log_retention_time: Optional[int] = None,
                 rabbitmq: Optional['outputs.MdbClickhouseClusterClickhouseConfigRabbitmq'] = None,
                 text_log_enabled: Optional[bool] = None,
                 text_log_level: Optional[str] = None,
                 text_log_retention_size: Optional[int] = None,
                 text_log_retention_time: Optional[int] = None,
                 timezone: Optional[str] = None,
                 trace_log_enabled: Optional[bool] = None,
                 trace_log_retention_size: Optional[int] = None,
                 trace_log_retention_time: Optional[int] = None,
                 uncompressed_cache_size: Optional[int] = None):
        """
        :param Sequence['MdbClickhouseClusterClickhouseConfigCompressionArgs'] compressions: Data compression configuration. The structure is documented below.
        :param Sequence['MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs'] graphite_rollups: Graphite rollup configuration. The structure is documented below.
        :param 'MdbClickhouseClusterClickhouseConfigKafkaArgs' kafka: Kafka connection configuration. The structure is documented below.
        :param Sequence['MdbClickhouseClusterClickhouseConfigKafkaTopicArgs'] kafka_topics: Kafka topic connection configuration. The structure is documented below.
        :param 'MdbClickhouseClusterClickhouseConfigMergeTreeArgs' merge_tree: MergeTree engine configuration. The structure is documented below.
        :param 'MdbClickhouseClusterClickhouseConfigRabbitmqArgs' rabbitmq: RabbitMQ connection configuration. The structure is documented below.
        """
        if background_pool_size is not None:
            pulumi.set(__self__, "background_pool_size", background_pool_size)
        if background_schedule_pool_size is not None:
            pulumi.set(__self__, "background_schedule_pool_size", background_schedule_pool_size)
        if compressions is not None:
            pulumi.set(__self__, "compressions", compressions)
        if geobase_uri is not None:
            pulumi.set(__self__, "geobase_uri", geobase_uri)
        if graphite_rollups is not None:
            pulumi.set(__self__, "graphite_rollups", graphite_rollups)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_topics is not None:
            pulumi.set(__self__, "kafka_topics", kafka_topics)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if mark_cache_size is not None:
            pulumi.set(__self__, "mark_cache_size", mark_cache_size)
        if max_concurrent_queries is not None:
            pulumi.set(__self__, "max_concurrent_queries", max_concurrent_queries)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_partition_size_to_drop is not None:
            pulumi.set(__self__, "max_partition_size_to_drop", max_partition_size_to_drop)
        if max_table_size_to_drop is not None:
            pulumi.set(__self__, "max_table_size_to_drop", max_table_size_to_drop)
        if merge_tree is not None:
            pulumi.set(__self__, "merge_tree", merge_tree)
        if metric_log_enabled is not None:
            pulumi.set(__self__, "metric_log_enabled", metric_log_enabled)
        if metric_log_retention_size is not None:
            pulumi.set(__self__, "metric_log_retention_size", metric_log_retention_size)
        if metric_log_retention_time is not None:
            pulumi.set(__self__, "metric_log_retention_time", metric_log_retention_time)
        if part_log_retention_size is not None:
            pulumi.set(__self__, "part_log_retention_size", part_log_retention_size)
        if part_log_retention_time is not None:
            pulumi.set(__self__, "part_log_retention_time", part_log_retention_time)
        if query_log_retention_size is not None:
            pulumi.set(__self__, "query_log_retention_size", query_log_retention_size)
        if query_log_retention_time is not None:
            pulumi.set(__self__, "query_log_retention_time", query_log_retention_time)
        if query_thread_log_enabled is not None:
            pulumi.set(__self__, "query_thread_log_enabled", query_thread_log_enabled)
        if query_thread_log_retention_size is not None:
            pulumi.set(__self__, "query_thread_log_retention_size", query_thread_log_retention_size)
        if query_thread_log_retention_time is not None:
            pulumi.set(__self__, "query_thread_log_retention_time", query_thread_log_retention_time)
        if rabbitmq is not None:
            pulumi.set(__self__, "rabbitmq", rabbitmq)
        if text_log_enabled is not None:
            pulumi.set(__self__, "text_log_enabled", text_log_enabled)
        if text_log_level is not None:
            pulumi.set(__self__, "text_log_level", text_log_level)
        if text_log_retention_size is not None:
            pulumi.set(__self__, "text_log_retention_size", text_log_retention_size)
        if text_log_retention_time is not None:
            pulumi.set(__self__, "text_log_retention_time", text_log_retention_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if trace_log_enabled is not None:
            pulumi.set(__self__, "trace_log_enabled", trace_log_enabled)
        if trace_log_retention_size is not None:
            pulumi.set(__self__, "trace_log_retention_size", trace_log_retention_size)
        if trace_log_retention_time is not None:
            pulumi.set(__self__, "trace_log_retention_time", trace_log_retention_time)
        if uncompressed_cache_size is not None:
            pulumi.set(__self__, "uncompressed_cache_size", uncompressed_cache_size)

    @property
    @pulumi.getter(name="backgroundPoolSize")
    def background_pool_size(self) -> Optional[int]:
        return pulumi.get(self, "background_pool_size")

    @property
    @pulumi.getter(name="backgroundSchedulePoolSize")
    def background_schedule_pool_size(self) -> Optional[int]:
        return pulumi.get(self, "background_schedule_pool_size")

    @property
    @pulumi.getter
    def compressions(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigCompression']]:
        """
        Data compression configuration. The structure is documented below.
        """
        return pulumi.get(self, "compressions")

    @property
    @pulumi.getter(name="geobaseUri")
    def geobase_uri(self) -> Optional[str]:
        return pulumi.get(self, "geobase_uri")

    @property
    @pulumi.getter(name="graphiteRollups")
    def graphite_rollups(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollup']]:
        """
        Graphite rollup configuration. The structure is documented below.
        """
        return pulumi.get(self, "graphite_rollups")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigKafka']:
        """
        Kafka connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="kafkaTopics")
    def kafka_topics(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopic']]:
        """
        Kafka topic connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafka_topics")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[int]:
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="markCacheSize")
    def mark_cache_size(self) -> Optional[int]:
        return pulumi.get(self, "mark_cache_size")

    @property
    @pulumi.getter(name="maxConcurrentQueries")
    def max_concurrent_queries(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrent_queries")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPartitionSizeToDrop")
    def max_partition_size_to_drop(self) -> Optional[int]:
        return pulumi.get(self, "max_partition_size_to_drop")

    @property
    @pulumi.getter(name="maxTableSizeToDrop")
    def max_table_size_to_drop(self) -> Optional[int]:
        return pulumi.get(self, "max_table_size_to_drop")

    @property
    @pulumi.getter(name="mergeTree")
    def merge_tree(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigMergeTree']:
        """
        MergeTree engine configuration. The structure is documented below.
        """
        return pulumi.get(self, "merge_tree")

    @property
    @pulumi.getter(name="metricLogEnabled")
    def metric_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "metric_log_enabled")

    @property
    @pulumi.getter(name="metricLogRetentionSize")
    def metric_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "metric_log_retention_size")

    @property
    @pulumi.getter(name="metricLogRetentionTime")
    def metric_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "metric_log_retention_time")

    @property
    @pulumi.getter(name="partLogRetentionSize")
    def part_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "part_log_retention_size")

    @property
    @pulumi.getter(name="partLogRetentionTime")
    def part_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "part_log_retention_time")

    @property
    @pulumi.getter(name="queryLogRetentionSize")
    def query_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "query_log_retention_size")

    @property
    @pulumi.getter(name="queryLogRetentionTime")
    def query_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "query_log_retention_time")

    @property
    @pulumi.getter(name="queryThreadLogEnabled")
    def query_thread_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "query_thread_log_enabled")

    @property
    @pulumi.getter(name="queryThreadLogRetentionSize")
    def query_thread_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "query_thread_log_retention_size")

    @property
    @pulumi.getter(name="queryThreadLogRetentionTime")
    def query_thread_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "query_thread_log_retention_time")

    @property
    @pulumi.getter
    def rabbitmq(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigRabbitmq']:
        """
        RabbitMQ connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "rabbitmq")

    @property
    @pulumi.getter(name="textLogEnabled")
    def text_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "text_log_enabled")

    @property
    @pulumi.getter(name="textLogLevel")
    def text_log_level(self) -> Optional[str]:
        return pulumi.get(self, "text_log_level")

    @property
    @pulumi.getter(name="textLogRetentionSize")
    def text_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "text_log_retention_size")

    @property
    @pulumi.getter(name="textLogRetentionTime")
    def text_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "text_log_retention_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="traceLogEnabled")
    def trace_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "trace_log_enabled")

    @property
    @pulumi.getter(name="traceLogRetentionSize")
    def trace_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "trace_log_retention_size")

    @property
    @pulumi.getter(name="traceLogRetentionTime")
    def trace_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "trace_log_retention_time")

    @property
    @pulumi.getter(name="uncompressedCacheSize")
    def uncompressed_cache_size(self) -> Optional[int]:
        return pulumi.get(self, "uncompressed_cache_size")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minPartSize":
            suggest = "min_part_size"
        elif key == "minPartSizeRatio":
            suggest = "min_part_size_ratio"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 min_part_size: int,
                 min_part_size_ratio: float):
        """
        :param str method: Method: Compression method. Two methods are available: LZ4 and zstd.
        :param int min_part_size: Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        :param float min_part_size_ratio: Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "min_part_size", min_part_size)
        pulumi.set(__self__, "min_part_size_ratio", min_part_size_ratio)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Method: Compression method. Two methods are available: LZ4 and zstd.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="minPartSize")
    def min_part_size(self) -> int:
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        return pulumi.get(self, "min_part_size")

    @property
    @pulumi.getter(name="minPartSizeRatio")
    def min_part_size_ratio(self) -> float:
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        return pulumi.get(self, "min_part_size_ratio")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollup(dict):
    def __init__(__self__, *,
                 name: str,
                 patterns: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern']] = None):
        """
        :param str name: Graphite rollup configuration name.
        :param Sequence['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs'] patterns: Set of thinning rules.
        """
        pulumi.set(__self__, "name", name)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern']]:
        """
        Set of thinning rules.
        """
        return pulumi.get(self, "patterns")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern(dict):
    def __init__(__self__, *,
                 function: str,
                 regexp: Optional[str] = None,
                 retentions: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention']] = None):
        """
        :param str function: Aggregation function name.
        :param str regexp: Regular expression that the metric name must match.
        :param Sequence['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs'] retentions: Retain parameters.
        """
        pulumi.set(__self__, "function", function)
        if regexp is not None:
            pulumi.set(__self__, "regexp", regexp)
        if retentions is not None:
            pulumi.set(__self__, "retentions", retentions)

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        Aggregation function name.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def regexp(self) -> Optional[str]:
        """
        Regular expression that the metric name must match.
        """
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def retentions(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention']]:
        """
        Retain parameters.
        """
        return pulumi.get(self, "retentions")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention(dict):
    def __init__(__self__, *,
                 age: int,
                 precision: int):
        """
        :param int age: Minimum data age in seconds.
        :param int precision: Accuracy of determining the age of the data in seconds.
        """
        pulumi.set(__self__, "age", age)
        pulumi.set(__self__, "precision", precision)

    @property
    @pulumi.getter
    def age(self) -> int:
        """
        Minimum data age in seconds.
        """
        return pulumi.get(self, "age")

    @property
    @pulumi.getter
    def precision(self) -> int:
        """
        Accuracy of determining the age of the data in seconds.
        """
        return pulumi.get(self, "precision")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPassword":
            suggest = "sasl_password"
        elif key == "saslUsername":
            suggest = "sasl_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sasl_mechanism: Optional[str] = None,
                 sasl_password: Optional[str] = None,
                 sasl_username: Optional[str] = None,
                 security_protocol: Optional[str] = None):
        """
        :param str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param str sasl_password: User password on kafka server.
        :param str sasl_username: Username on kafka server.
        :param str security_protocol: Security protocol used to connect to kafka server.
        """
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigKafkaTopic(dict):
    def __init__(__self__, *,
                 name: str,
                 settings: Optional['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopicSettings'] = None):
        """
        :param str name: Graphite rollup configuration name.
        :param 'MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs' settings: Kafka connection settngs sanem as `kafka` block.
        """
        pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopicSettings']:
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigKafkaTopicSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPassword":
            suggest = "sasl_password"
        elif key == "saslUsername":
            suggest = "sasl_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigKafkaTopicSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigKafkaTopicSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigKafkaTopicSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sasl_mechanism: Optional[str] = None,
                 sasl_password: Optional[str] = None,
                 sasl_username: Optional[str] = None,
                 security_protocol: Optional[str] = None):
        """
        :param str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param str sasl_password: User password on kafka server.
        :param str sasl_username: Username on kafka server.
        :param str security_protocol: Security protocol used to connect to kafka server.
        """
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigMergeTree(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBytesToMergeAtMinSpaceInPool":
            suggest = "max_bytes_to_merge_at_min_space_in_pool"
        elif key == "maxReplicatedMergesInQueue":
            suggest = "max_replicated_merges_in_queue"
        elif key == "numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge":
            suggest = "number_of_free_entries_in_pool_to_lower_max_size_of_merge"
        elif key == "partsToDelayInsert":
            suggest = "parts_to_delay_insert"
        elif key == "partsToThrowInsert":
            suggest = "parts_to_throw_insert"
        elif key == "replicatedDeduplicationWindow":
            suggest = "replicated_deduplication_window"
        elif key == "replicatedDeduplicationWindowSeconds":
            suggest = "replicated_deduplication_window_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigMergeTree. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigMergeTree.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigMergeTree.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_bytes_to_merge_at_min_space_in_pool: Optional[int] = None,
                 max_replicated_merges_in_queue: Optional[int] = None,
                 number_of_free_entries_in_pool_to_lower_max_size_of_merge: Optional[int] = None,
                 parts_to_delay_insert: Optional[int] = None,
                 parts_to_throw_insert: Optional[int] = None,
                 replicated_deduplication_window: Optional[int] = None,
                 replicated_deduplication_window_seconds: Optional[int] = None):
        """
        :param int max_bytes_to_merge_at_min_space_in_pool: Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        :param int max_replicated_merges_in_queue: Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        :param int number_of_free_entries_in_pool_to_lower_max_size_of_merge: Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        :param int parts_to_delay_insert: Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        :param int parts_to_throw_insert: Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        :param int replicated_deduplication_window: Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        :param int replicated_deduplication_window_seconds: Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        if max_bytes_to_merge_at_min_space_in_pool is not None:
            pulumi.set(__self__, "max_bytes_to_merge_at_min_space_in_pool", max_bytes_to_merge_at_min_space_in_pool)
        if max_replicated_merges_in_queue is not None:
            pulumi.set(__self__, "max_replicated_merges_in_queue", max_replicated_merges_in_queue)
        if number_of_free_entries_in_pool_to_lower_max_size_of_merge is not None:
            pulumi.set(__self__, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", number_of_free_entries_in_pool_to_lower_max_size_of_merge)
        if parts_to_delay_insert is not None:
            pulumi.set(__self__, "parts_to_delay_insert", parts_to_delay_insert)
        if parts_to_throw_insert is not None:
            pulumi.set(__self__, "parts_to_throw_insert", parts_to_throw_insert)
        if replicated_deduplication_window is not None:
            pulumi.set(__self__, "replicated_deduplication_window", replicated_deduplication_window)
        if replicated_deduplication_window_seconds is not None:
            pulumi.set(__self__, "replicated_deduplication_window_seconds", replicated_deduplication_window_seconds)

    @property
    @pulumi.getter(name="maxBytesToMergeAtMinSpaceInPool")
    def max_bytes_to_merge_at_min_space_in_pool(self) -> Optional[int]:
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_min_space_in_pool")

    @property
    @pulumi.getter(name="maxReplicatedMergesInQueue")
    def max_replicated_merges_in_queue(self) -> Optional[int]:
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        return pulumi.get(self, "max_replicated_merges_in_queue")

    @property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge")
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self) -> Optional[int]:
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge")

    @property
    @pulumi.getter(name="partsToDelayInsert")
    def parts_to_delay_insert(self) -> Optional[int]:
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        """
        return pulumi.get(self, "parts_to_delay_insert")

    @property
    @pulumi.getter(name="partsToThrowInsert")
    def parts_to_throw_insert(self) -> Optional[int]:
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        return pulumi.get(self, "parts_to_throw_insert")

    @property
    @pulumi.getter(name="replicatedDeduplicationWindow")
    def replicated_deduplication_window(self) -> Optional[int]:
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window")

    @property
    @pulumi.getter(name="replicatedDeduplicationWindowSeconds")
    def replicated_deduplication_window_seconds(self) -> Optional[int]:
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window_seconds")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigRabbitmq(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: RabbitMQ user password.
        :param str username: RabbitMQ username.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        RabbitMQ username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class MdbClickhouseClusterClickhouseResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param str disk_type_id: Type of the storage of ZooKeeper hosts.
               For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of ZooKeeper hosts.
        For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbClickhouseClusterCloudStorage(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MdbClickhouseClusterDatabase(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Graphite rollup configuration name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbClickhouseClusterFormatSchema(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 uri: str):
        """
        :param str name: Graphite rollup configuration name.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class MdbClickhouseClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "shardName":
            suggest = "shard_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 zone: str,
                 assign_public_ip: Optional[bool] = None,
                 fqdn: Optional[str] = None,
                 shard_name: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str zone: The availability zone where the ClickHouse host will be created.
               For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        :param str fqdn: The fully qualified domain name of the host.
        :param str shard_name: The name of the shard to which the host belongs.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the ClickHouse host will be created.
        For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[str]:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbClickhouseClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: str,
                 day: Optional[str] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbClickhouseClusterMlModel(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 uri: str):
        """
        :param str name: Graphite rollup configuration name.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class MdbClickhouseClusterShardGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shardNames":
            suggest = "shard_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterShardGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterShardGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterShardGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 shard_names: Sequence[str],
                 description: Optional[str] = None):
        """
        :param str name: Graphite rollup configuration name.
        :param Sequence[str] shard_names: List of shards names that belong to the shard group.
        :param str description: Description of the shard group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "shard_names", shard_names)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shardNames")
    def shard_names(self) -> Sequence[str]:
        """
        List of shards names that belong to the shard group.
        """
        return pulumi.get(self, "shard_names")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the shard group.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MdbClickhouseClusterUser(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permissions: Optional[Sequence['outputs.MdbClickhouseClusterUserPermission']] = None,
                 quotas: Optional[Sequence['outputs.MdbClickhouseClusterUserQuota']] = None,
                 settings: Optional['outputs.MdbClickhouseClusterUserSettings'] = None):
        """
        :param str name: Graphite rollup configuration name.
        :param str password: RabbitMQ user password.
        :param Sequence['MdbClickhouseClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        :param Sequence['MdbClickhouseClusterUserQuotaArgs'] quotas: Set of user quotas. The structure is documented below.
        :param 'MdbClickhouseClusterUserSettingsArgs' settings: Kafka connection settngs sanem as `kafka` block.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if quotas is not None:
            pulumi.set(__self__, "quotas", quotas)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbClickhouseClusterUserPermission']]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def quotas(self) -> Optional[Sequence['outputs.MdbClickhouseClusterUserQuota']]:
        """
        Set of user quotas. The structure is documented below.
        """
        return pulumi.get(self, "quotas")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.MdbClickhouseClusterUserSettings']:
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class MdbClickhouseClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str):
        """
        :param str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class MdbClickhouseClusterUserQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDuration":
            suggest = "interval_duration"
        elif key == "executionTime":
            suggest = "execution_time"
        elif key == "readRows":
            suggest = "read_rows"
        elif key == "resultRows":
            suggest = "result_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterUserQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterUserQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterUserQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_duration: int,
                 errors: Optional[int] = None,
                 execution_time: Optional[int] = None,
                 queries: Optional[int] = None,
                 read_rows: Optional[int] = None,
                 result_rows: Optional[int] = None):
        """
        :param int interval_duration: Duration of interval for quota in milliseconds.
        :param int errors: The number of queries that threw exception.
        :param int execution_time: The total query execution time, in milliseconds (wall time).
        :param int queries: The total number of queries.
        :param int read_rows: The total number of source rows read from tables for running the query, on all remote servers.
        :param int result_rows: The total number of rows given as the result.
        """
        pulumi.set(__self__, "interval_duration", interval_duration)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if execution_time is not None:
            pulumi.set(__self__, "execution_time", execution_time)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if read_rows is not None:
            pulumi.set(__self__, "read_rows", read_rows)
        if result_rows is not None:
            pulumi.set(__self__, "result_rows", result_rows)

    @property
    @pulumi.getter(name="intervalDuration")
    def interval_duration(self) -> int:
        """
        Duration of interval for quota in milliseconds.
        """
        return pulumi.get(self, "interval_duration")

    @property
    @pulumi.getter
    def errors(self) -> Optional[int]:
        """
        The number of queries that threw exception.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> Optional[int]:
        """
        The total query execution time, in milliseconds (wall time).
        """
        return pulumi.get(self, "execution_time")

    @property
    @pulumi.getter
    def queries(self) -> Optional[int]:
        """
        The total number of queries.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="readRows")
    def read_rows(self) -> Optional[int]:
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        return pulumi.get(self, "read_rows")

    @property
    @pulumi.getter(name="resultRows")
    def result_rows(self) -> Optional[int]:
        """
        The total number of rows given as the result.
        """
        return pulumi.get(self, "result_rows")


@pulumi.output_type
class MdbClickhouseClusterUserSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addHttpCorsHeader":
            suggest = "add_http_cors_header"
        elif key == "allowDdl":
            suggest = "allow_ddl"
        elif key == "compileExpressions":
            suggest = "compile_expressions"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "countDistinctImplementation":
            suggest = "count_distinct_implementation"
        elif key == "distinctOverflowMode":
            suggest = "distinct_overflow_mode"
        elif key == "distributedAggregationMemoryEfficient":
            suggest = "distributed_aggregation_memory_efficient"
        elif key == "distributedDdlTaskTimeout":
            suggest = "distributed_ddl_task_timeout"
        elif key == "distributedProductMode":
            suggest = "distributed_product_mode"
        elif key == "emptyResultForAggregationByEmptySet":
            suggest = "empty_result_for_aggregation_by_empty_set"
        elif key == "enableHttpCompression":
            suggest = "enable_http_compression"
        elif key == "fallbackToStaleReplicasForDistributedQueries":
            suggest = "fallback_to_stale_replicas_for_distributed_queries"
        elif key == "forceIndexByDate":
            suggest = "force_index_by_date"
        elif key == "forcePrimaryKey":
            suggest = "force_primary_key"
        elif key == "groupByOverflowMode":
            suggest = "group_by_overflow_mode"
        elif key == "groupByTwoLevelThreshold":
            suggest = "group_by_two_level_threshold"
        elif key == "groupByTwoLevelThresholdBytes":
            suggest = "group_by_two_level_threshold_bytes"
        elif key == "httpConnectionTimeout":
            suggest = "http_connection_timeout"
        elif key == "httpHeadersProgressInterval":
            suggest = "http_headers_progress_interval"
        elif key == "httpReceiveTimeout":
            suggest = "http_receive_timeout"
        elif key == "httpSendTimeout":
            suggest = "http_send_timeout"
        elif key == "inputFormatDefaultsForOmittedFields":
            suggest = "input_format_defaults_for_omitted_fields"
        elif key == "inputFormatValuesInterpretExpressions":
            suggest = "input_format_values_interpret_expressions"
        elif key == "insertQuorum":
            suggest = "insert_quorum"
        elif key == "insertQuorumTimeout":
            suggest = "insert_quorum_timeout"
        elif key == "joinOverflowMode":
            suggest = "join_overflow_mode"
        elif key == "joinUseNulls":
            suggest = "join_use_nulls"
        elif key == "joinedSubqueryRequiresAlias":
            suggest = "joined_subquery_requires_alias"
        elif key == "lowCardinalityAllowInNativeFormat":
            suggest = "low_cardinality_allow_in_native_format"
        elif key == "maxAstDepth":
            suggest = "max_ast_depth"
        elif key == "maxAstElements":
            suggest = "max_ast_elements"
        elif key == "maxBlockSize":
            suggest = "max_block_size"
        elif key == "maxBytesBeforeExternalGroupBy":
            suggest = "max_bytes_before_external_group_by"
        elif key == "maxBytesBeforeExternalSort":
            suggest = "max_bytes_before_external_sort"
        elif key == "maxBytesInDistinct":
            suggest = "max_bytes_in_distinct"
        elif key == "maxBytesInJoin":
            suggest = "max_bytes_in_join"
        elif key == "maxBytesInSet":
            suggest = "max_bytes_in_set"
        elif key == "maxBytesToRead":
            suggest = "max_bytes_to_read"
        elif key == "maxBytesToSort":
            suggest = "max_bytes_to_sort"
        elif key == "maxBytesToTransfer":
            suggest = "max_bytes_to_transfer"
        elif key == "maxColumnsToRead":
            suggest = "max_columns_to_read"
        elif key == "maxExecutionTime":
            suggest = "max_execution_time"
        elif key == "maxExpandedAstElements":
            suggest = "max_expanded_ast_elements"
        elif key == "maxInsertBlockSize":
            suggest = "max_insert_block_size"
        elif key == "maxMemoryUsage":
            suggest = "max_memory_usage"
        elif key == "maxMemoryUsageForUser":
            suggest = "max_memory_usage_for_user"
        elif key == "maxNetworkBandwidth":
            suggest = "max_network_bandwidth"
        elif key == "maxNetworkBandwidthForUser":
            suggest = "max_network_bandwidth_for_user"
        elif key == "maxQuerySize":
            suggest = "max_query_size"
        elif key == "maxReplicaDelayForDistributedQueries":
            suggest = "max_replica_delay_for_distributed_queries"
        elif key == "maxResultBytes":
            suggest = "max_result_bytes"
        elif key == "maxResultRows":
            suggest = "max_result_rows"
        elif key == "maxRowsInDistinct":
            suggest = "max_rows_in_distinct"
        elif key == "maxRowsInJoin":
            suggest = "max_rows_in_join"
        elif key == "maxRowsInSet":
            suggest = "max_rows_in_set"
        elif key == "maxRowsToGroupBy":
            suggest = "max_rows_to_group_by"
        elif key == "maxRowsToRead":
            suggest = "max_rows_to_read"
        elif key == "maxRowsToSort":
            suggest = "max_rows_to_sort"
        elif key == "maxRowsToTransfer":
            suggest = "max_rows_to_transfer"
        elif key == "maxTemporaryColumns":
            suggest = "max_temporary_columns"
        elif key == "maxTemporaryNonConstColumns":
            suggest = "max_temporary_non_const_columns"
        elif key == "maxThreads":
            suggest = "max_threads"
        elif key == "mergeTreeMaxBytesToUseCache":
            suggest = "merge_tree_max_bytes_to_use_cache"
        elif key == "mergeTreeMaxRowsToUseCache":
            suggest = "merge_tree_max_rows_to_use_cache"
        elif key == "mergeTreeMinBytesForConcurrentRead":
            suggest = "merge_tree_min_bytes_for_concurrent_read"
        elif key == "mergeTreeMinRowsForConcurrentRead":
            suggest = "merge_tree_min_rows_for_concurrent_read"
        elif key == "minBytesToUseDirectIo":
            suggest = "min_bytes_to_use_direct_io"
        elif key == "minCountToCompile":
            suggest = "min_count_to_compile"
        elif key == "minCountToCompileExpression":
            suggest = "min_count_to_compile_expression"
        elif key == "minExecutionSpeed":
            suggest = "min_execution_speed"
        elif key == "minExecutionSpeedBytes":
            suggest = "min_execution_speed_bytes"
        elif key == "minInsertBlockSizeBytes":
            suggest = "min_insert_block_size_bytes"
        elif key == "minInsertBlockSizeRows":
            suggest = "min_insert_block_size_rows"
        elif key == "outputFormatJsonQuote64bitIntegers":
            suggest = "output_format_json_quote64bit_integers"
        elif key == "outputFormatJsonQuoteDenormals":
            suggest = "output_format_json_quote_denormals"
        elif key == "quotaMode":
            suggest = "quota_mode"
        elif key == "readOverflowMode":
            suggest = "read_overflow_mode"
        elif key == "receiveTimeout":
            suggest = "receive_timeout"
        elif key == "replicationAlterPartitionsSync":
            suggest = "replication_alter_partitions_sync"
        elif key == "resultOverflowMode":
            suggest = "result_overflow_mode"
        elif key == "selectSequentialConsistency":
            suggest = "select_sequential_consistency"
        elif key == "sendProgressInHttpHeaders":
            suggest = "send_progress_in_http_headers"
        elif key == "sendTimeout":
            suggest = "send_timeout"
        elif key == "setOverflowMode":
            suggest = "set_overflow_mode"
        elif key == "skipUnavailableShards":
            suggest = "skip_unavailable_shards"
        elif key == "sortOverflowMode":
            suggest = "sort_overflow_mode"
        elif key == "timeoutOverflowMode":
            suggest = "timeout_overflow_mode"
        elif key == "transferOverflowMode":
            suggest = "transfer_overflow_mode"
        elif key == "transformNullIn":
            suggest = "transform_null_in"
        elif key == "useUncompressedCache":
            suggest = "use_uncompressed_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterUserSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterUserSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterUserSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_http_cors_header: Optional[bool] = None,
                 allow_ddl: Optional[bool] = None,
                 compile: Optional[bool] = None,
                 compile_expressions: Optional[bool] = None,
                 connect_timeout: Optional[int] = None,
                 count_distinct_implementation: Optional[str] = None,
                 distinct_overflow_mode: Optional[str] = None,
                 distributed_aggregation_memory_efficient: Optional[bool] = None,
                 distributed_ddl_task_timeout: Optional[int] = None,
                 distributed_product_mode: Optional[str] = None,
                 empty_result_for_aggregation_by_empty_set: Optional[bool] = None,
                 enable_http_compression: Optional[bool] = None,
                 fallback_to_stale_replicas_for_distributed_queries: Optional[bool] = None,
                 force_index_by_date: Optional[bool] = None,
                 force_primary_key: Optional[bool] = None,
                 group_by_overflow_mode: Optional[str] = None,
                 group_by_two_level_threshold: Optional[int] = None,
                 group_by_two_level_threshold_bytes: Optional[int] = None,
                 http_connection_timeout: Optional[int] = None,
                 http_headers_progress_interval: Optional[int] = None,
                 http_receive_timeout: Optional[int] = None,
                 http_send_timeout: Optional[int] = None,
                 input_format_defaults_for_omitted_fields: Optional[bool] = None,
                 input_format_values_interpret_expressions: Optional[bool] = None,
                 insert_quorum: Optional[int] = None,
                 insert_quorum_timeout: Optional[int] = None,
                 join_overflow_mode: Optional[str] = None,
                 join_use_nulls: Optional[bool] = None,
                 joined_subquery_requires_alias: Optional[bool] = None,
                 low_cardinality_allow_in_native_format: Optional[bool] = None,
                 max_ast_depth: Optional[int] = None,
                 max_ast_elements: Optional[int] = None,
                 max_block_size: Optional[int] = None,
                 max_bytes_before_external_group_by: Optional[int] = None,
                 max_bytes_before_external_sort: Optional[int] = None,
                 max_bytes_in_distinct: Optional[int] = None,
                 max_bytes_in_join: Optional[int] = None,
                 max_bytes_in_set: Optional[int] = None,
                 max_bytes_to_read: Optional[int] = None,
                 max_bytes_to_sort: Optional[int] = None,
                 max_bytes_to_transfer: Optional[int] = None,
                 max_columns_to_read: Optional[int] = None,
                 max_execution_time: Optional[int] = None,
                 max_expanded_ast_elements: Optional[int] = None,
                 max_insert_block_size: Optional[int] = None,
                 max_memory_usage: Optional[int] = None,
                 max_memory_usage_for_user: Optional[int] = None,
                 max_network_bandwidth: Optional[int] = None,
                 max_network_bandwidth_for_user: Optional[int] = None,
                 max_query_size: Optional[int] = None,
                 max_replica_delay_for_distributed_queries: Optional[int] = None,
                 max_result_bytes: Optional[int] = None,
                 max_result_rows: Optional[int] = None,
                 max_rows_in_distinct: Optional[int] = None,
                 max_rows_in_join: Optional[int] = None,
                 max_rows_in_set: Optional[int] = None,
                 max_rows_to_group_by: Optional[int] = None,
                 max_rows_to_read: Optional[int] = None,
                 max_rows_to_sort: Optional[int] = None,
                 max_rows_to_transfer: Optional[int] = None,
                 max_temporary_columns: Optional[int] = None,
                 max_temporary_non_const_columns: Optional[int] = None,
                 max_threads: Optional[int] = None,
                 merge_tree_max_bytes_to_use_cache: Optional[int] = None,
                 merge_tree_max_rows_to_use_cache: Optional[int] = None,
                 merge_tree_min_bytes_for_concurrent_read: Optional[int] = None,
                 merge_tree_min_rows_for_concurrent_read: Optional[int] = None,
                 min_bytes_to_use_direct_io: Optional[int] = None,
                 min_count_to_compile: Optional[int] = None,
                 min_count_to_compile_expression: Optional[int] = None,
                 min_execution_speed: Optional[int] = None,
                 min_execution_speed_bytes: Optional[int] = None,
                 min_insert_block_size_bytes: Optional[int] = None,
                 min_insert_block_size_rows: Optional[int] = None,
                 output_format_json_quote64bit_integers: Optional[bool] = None,
                 output_format_json_quote_denormals: Optional[bool] = None,
                 priority: Optional[int] = None,
                 quota_mode: Optional[str] = None,
                 read_overflow_mode: Optional[str] = None,
                 readonly: Optional[int] = None,
                 receive_timeout: Optional[int] = None,
                 replication_alter_partitions_sync: Optional[int] = None,
                 result_overflow_mode: Optional[str] = None,
                 select_sequential_consistency: Optional[bool] = None,
                 send_progress_in_http_headers: Optional[bool] = None,
                 send_timeout: Optional[int] = None,
                 set_overflow_mode: Optional[str] = None,
                 skip_unavailable_shards: Optional[bool] = None,
                 sort_overflow_mode: Optional[str] = None,
                 timeout_overflow_mode: Optional[str] = None,
                 transfer_overflow_mode: Optional[str] = None,
                 transform_null_in: Optional[bool] = None,
                 use_uncompressed_cache: Optional[bool] = None):
        """
        :param bool add_http_cors_header: Include CORS headers in HTTP responces.
        :param bool allow_ddl: Allows or denies DDL queries.
        :param bool compile: Enable compilation of queries.
        :param bool compile_expressions: Turn on expression compilation.
        :param int connect_timeout: Connect timeout in milliseconds on the socket used for communicating with the client.
        :param str count_distinct_implementation: Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT …) construction.
        :param str distinct_overflow_mode: Sets behaviour on overflow when using DISTINCT. Possible values:
        :param bool distributed_aggregation_memory_efficient: Determine the behavior of distributed subqueries.
        :param int distributed_ddl_task_timeout: Timeout for DDL queries, in milliseconds.
        :param str distributed_product_mode: Changes the behaviour of distributed subqueries.
        :param bool empty_result_for_aggregation_by_empty_set: Allows to retunr empty result.
        :param bool enable_http_compression: Enables or disables data compression in the response to an HTTP request.
        :param bool fallback_to_stale_replicas_for_distributed_queries: Forces a query to an out-of-date replica if updated data is not available.
        :param bool force_index_by_date: Disables query execution if the index can’t be used by date.
        :param bool force_primary_key: Disables query execution if indexing by the primary key is not possible.
        :param str group_by_overflow_mode: Sets behaviour on overflow while GROUP BY operation. Possible values:
        :param int group_by_two_level_threshold: Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        :param int group_by_two_level_threshold_bytes: Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        :param int http_connection_timeout: Timeout for HTTP connection in milliseconds.
        :param int http_headers_progress_interval: Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        :param int http_receive_timeout: Timeout for HTTP connection in milliseconds.
        :param int http_send_timeout: Timeout for HTTP connection in milliseconds.
        :param bool input_format_defaults_for_omitted_fields: When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        :param bool input_format_values_interpret_expressions: Enables or disables the full SQL parser if the fast stream parser can’t parse the data.
        :param int insert_quorum: Enables the quorum writes.
        :param int insert_quorum_timeout: Write to a quorum timeout in milliseconds.
        :param str join_overflow_mode: Sets behaviour on overflow in JOIN. Possible values:
        :param bool join_use_nulls: Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        :param bool joined_subquery_requires_alias: Require aliases for subselects and table functions in FROM that more than one table is present.
        :param bool low_cardinality_allow_in_native_format: Allows or restricts using the LowCardinality data type with the Native format.
        :param int max_ast_depth: Maximum abstract syntax tree depth.
        :param int max_ast_elements: Maximum abstract syntax tree elements.
        :param int max_block_size: A recommendation for what size of the block (in a count of rows) to load from tables.
        :param int max_bytes_before_external_group_by: Limit in bytes for using memoru for GROUP BY before using swap on disk.
        :param int max_bytes_before_external_sort: This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        :param int max_bytes_in_distinct: Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        :param int max_bytes_in_join: Limit on maximum size of the hash table for JOIN, in bytes.
        :param int max_bytes_in_set: Limit on the number of bytes in the set resulting from the execution of the IN section.
        :param int max_bytes_to_read: Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        :param int max_bytes_to_sort: Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        :param int max_bytes_to_transfer: Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param int max_columns_to_read: Limits the maximum number of columns that can be read from a table in a single query.
        :param int max_execution_time: Limits the maximum query execution time in milliseconds.
        :param int max_expanded_ast_elements: Maximum abstract syntax tree depth after after expansion of aliases.
        :param int max_insert_block_size: The size of blocks (in a count of rows) to form for insertion into a table.
        :param int max_memory_usage: Limits the maximum memory usage (in bytes) for processing queries on a single server.
        :param int max_memory_usage_for_user: Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        :param int max_network_bandwidth: Limits the speed of the data exchange over the network in bytes per second.
        :param int max_network_bandwidth_for_user: Limits the speed of the data exchange over the network in bytes per second.
        :param int max_query_size: The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        :param int max_replica_delay_for_distributed_queries: Disables lagging replicas for distributed queries.
        :param int max_result_bytes: Limits the number of bytes in the result.
        :param int max_result_rows: Limits the number of rows in the result.
        :param int max_rows_in_distinct: Limits the maximum number of different rows when using DISTINCT.
        :param int max_rows_in_join: Limit on maximum size of the hash table for JOIN, in rows.
        :param int max_rows_in_set: Limit on the number of rows in the set resulting from the execution of the IN section.
        :param int max_rows_to_group_by: Limits the maximum number of unique keys received from aggregation function.
        :param int max_rows_to_read: Limits the maximum number of rows that can be read from a table when running a query.
        :param int max_rows_to_sort: Limits the maximum number of rows that can be read from a table for sorting.
        :param int max_rows_to_transfer: Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param int max_temporary_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        :param int max_temporary_non_const_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        :param int max_threads: The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        :param int merge_tree_max_bytes_to_use_cache: If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesn’t use the cache of uncompressed blocks.
        :param int merge_tree_max_rows_to_use_cache: If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesn’t use the cache of uncompressed blocks.
        :param int merge_tree_min_bytes_for_concurrent_read: If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        :param int merge_tree_min_rows_for_concurrent_read: If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        :param int min_bytes_to_use_direct_io: The minimum data volume required for using direct I/O access to the storage disk.
        :param int min_count_to_compile: How many times to potentially use a compiled chunk of code before running compilation.
        :param int min_count_to_compile_expression: A query waits for expression compilation process to complete prior to continuing execution.
        :param int min_execution_speed: Minimal execution speed in rows per second.
        :param int min_execution_speed_bytes: Minimal execution speed in bytes per second.
        :param int min_insert_block_size_bytes: Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        :param int min_insert_block_size_rows: Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        :param bool output_format_json_quote64bit_integers: If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        :param bool output_format_json_quote_denormals: Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        :param int priority: Query priority.
        :param str quota_mode: Quota accounting mode.
        :param str read_overflow_mode: Sets behaviour on overflow while read. Possible values:
        :param int readonly: Restricts permissions for reading data, write data and change settings queries.
        :param int receive_timeout: Receive timeout in milliseconds on the socket used for communicating with the client.
        :param int replication_alter_partitions_sync: For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        :param str result_overflow_mode: Sets behaviour on overflow in result. Possible values:
        :param bool select_sequential_consistency: Enables or disables sequential consistency for SELECT queries.
        :param bool send_progress_in_http_headers: Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        :param int send_timeout: Send timeout in milliseconds on the socket used for communicating with the client.
        :param str set_overflow_mode: Sets behaviour on overflow in the set resulting. Possible values:
        :param bool skip_unavailable_shards: Enables or disables silently skipping of unavailable shards.
        :param str sort_overflow_mode: Sets behaviour on overflow while sort. Possible values:
        :param str timeout_overflow_mode: Sets behaviour on overflow. Possible values:
        :param str transfer_overflow_mode: Sets behaviour on overflow. Possible values:
        :param bool transform_null_in: Enables equality of NULL values for IN operator.
        :param bool use_uncompressed_cache: Whether to use a cache of uncompressed blocks.
        """
        if add_http_cors_header is not None:
            pulumi.set(__self__, "add_http_cors_header", add_http_cors_header)
        if allow_ddl is not None:
            pulumi.set(__self__, "allow_ddl", allow_ddl)
        if compile is not None:
            pulumi.set(__self__, "compile", compile)
        if compile_expressions is not None:
            pulumi.set(__self__, "compile_expressions", compile_expressions)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if count_distinct_implementation is not None:
            pulumi.set(__self__, "count_distinct_implementation", count_distinct_implementation)
        if distinct_overflow_mode is not None:
            pulumi.set(__self__, "distinct_overflow_mode", distinct_overflow_mode)
        if distributed_aggregation_memory_efficient is not None:
            pulumi.set(__self__, "distributed_aggregation_memory_efficient", distributed_aggregation_memory_efficient)
        if distributed_ddl_task_timeout is not None:
            pulumi.set(__self__, "distributed_ddl_task_timeout", distributed_ddl_task_timeout)
        if distributed_product_mode is not None:
            pulumi.set(__self__, "distributed_product_mode", distributed_product_mode)
        if empty_result_for_aggregation_by_empty_set is not None:
            pulumi.set(__self__, "empty_result_for_aggregation_by_empty_set", empty_result_for_aggregation_by_empty_set)
        if enable_http_compression is not None:
            pulumi.set(__self__, "enable_http_compression", enable_http_compression)
        if fallback_to_stale_replicas_for_distributed_queries is not None:
            pulumi.set(__self__, "fallback_to_stale_replicas_for_distributed_queries", fallback_to_stale_replicas_for_distributed_queries)
        if force_index_by_date is not None:
            pulumi.set(__self__, "force_index_by_date", force_index_by_date)
        if force_primary_key is not None:
            pulumi.set(__self__, "force_primary_key", force_primary_key)
        if group_by_overflow_mode is not None:
            pulumi.set(__self__, "group_by_overflow_mode", group_by_overflow_mode)
        if group_by_two_level_threshold is not None:
            pulumi.set(__self__, "group_by_two_level_threshold", group_by_two_level_threshold)
        if group_by_two_level_threshold_bytes is not None:
            pulumi.set(__self__, "group_by_two_level_threshold_bytes", group_by_two_level_threshold_bytes)
        if http_connection_timeout is not None:
            pulumi.set(__self__, "http_connection_timeout", http_connection_timeout)
        if http_headers_progress_interval is not None:
            pulumi.set(__self__, "http_headers_progress_interval", http_headers_progress_interval)
        if http_receive_timeout is not None:
            pulumi.set(__self__, "http_receive_timeout", http_receive_timeout)
        if http_send_timeout is not None:
            pulumi.set(__self__, "http_send_timeout", http_send_timeout)
        if input_format_defaults_for_omitted_fields is not None:
            pulumi.set(__self__, "input_format_defaults_for_omitted_fields", input_format_defaults_for_omitted_fields)
        if input_format_values_interpret_expressions is not None:
            pulumi.set(__self__, "input_format_values_interpret_expressions", input_format_values_interpret_expressions)
        if insert_quorum is not None:
            pulumi.set(__self__, "insert_quorum", insert_quorum)
        if insert_quorum_timeout is not None:
            pulumi.set(__self__, "insert_quorum_timeout", insert_quorum_timeout)
        if join_overflow_mode is not None:
            pulumi.set(__self__, "join_overflow_mode", join_overflow_mode)
        if join_use_nulls is not None:
            pulumi.set(__self__, "join_use_nulls", join_use_nulls)
        if joined_subquery_requires_alias is not None:
            pulumi.set(__self__, "joined_subquery_requires_alias", joined_subquery_requires_alias)
        if low_cardinality_allow_in_native_format is not None:
            pulumi.set(__self__, "low_cardinality_allow_in_native_format", low_cardinality_allow_in_native_format)
        if max_ast_depth is not None:
            pulumi.set(__self__, "max_ast_depth", max_ast_depth)
        if max_ast_elements is not None:
            pulumi.set(__self__, "max_ast_elements", max_ast_elements)
        if max_block_size is not None:
            pulumi.set(__self__, "max_block_size", max_block_size)
        if max_bytes_before_external_group_by is not None:
            pulumi.set(__self__, "max_bytes_before_external_group_by", max_bytes_before_external_group_by)
        if max_bytes_before_external_sort is not None:
            pulumi.set(__self__, "max_bytes_before_external_sort", max_bytes_before_external_sort)
        if max_bytes_in_distinct is not None:
            pulumi.set(__self__, "max_bytes_in_distinct", max_bytes_in_distinct)
        if max_bytes_in_join is not None:
            pulumi.set(__self__, "max_bytes_in_join", max_bytes_in_join)
        if max_bytes_in_set is not None:
            pulumi.set(__self__, "max_bytes_in_set", max_bytes_in_set)
        if max_bytes_to_read is not None:
            pulumi.set(__self__, "max_bytes_to_read", max_bytes_to_read)
        if max_bytes_to_sort is not None:
            pulumi.set(__self__, "max_bytes_to_sort", max_bytes_to_sort)
        if max_bytes_to_transfer is not None:
            pulumi.set(__self__, "max_bytes_to_transfer", max_bytes_to_transfer)
        if max_columns_to_read is not None:
            pulumi.set(__self__, "max_columns_to_read", max_columns_to_read)
        if max_execution_time is not None:
            pulumi.set(__self__, "max_execution_time", max_execution_time)
        if max_expanded_ast_elements is not None:
            pulumi.set(__self__, "max_expanded_ast_elements", max_expanded_ast_elements)
        if max_insert_block_size is not None:
            pulumi.set(__self__, "max_insert_block_size", max_insert_block_size)
        if max_memory_usage is not None:
            pulumi.set(__self__, "max_memory_usage", max_memory_usage)
        if max_memory_usage_for_user is not None:
            pulumi.set(__self__, "max_memory_usage_for_user", max_memory_usage_for_user)
        if max_network_bandwidth is not None:
            pulumi.set(__self__, "max_network_bandwidth", max_network_bandwidth)
        if max_network_bandwidth_for_user is not None:
            pulumi.set(__self__, "max_network_bandwidth_for_user", max_network_bandwidth_for_user)
        if max_query_size is not None:
            pulumi.set(__self__, "max_query_size", max_query_size)
        if max_replica_delay_for_distributed_queries is not None:
            pulumi.set(__self__, "max_replica_delay_for_distributed_queries", max_replica_delay_for_distributed_queries)
        if max_result_bytes is not None:
            pulumi.set(__self__, "max_result_bytes", max_result_bytes)
        if max_result_rows is not None:
            pulumi.set(__self__, "max_result_rows", max_result_rows)
        if max_rows_in_distinct is not None:
            pulumi.set(__self__, "max_rows_in_distinct", max_rows_in_distinct)
        if max_rows_in_join is not None:
            pulumi.set(__self__, "max_rows_in_join", max_rows_in_join)
        if max_rows_in_set is not None:
            pulumi.set(__self__, "max_rows_in_set", max_rows_in_set)
        if max_rows_to_group_by is not None:
            pulumi.set(__self__, "max_rows_to_group_by", max_rows_to_group_by)
        if max_rows_to_read is not None:
            pulumi.set(__self__, "max_rows_to_read", max_rows_to_read)
        if max_rows_to_sort is not None:
            pulumi.set(__self__, "max_rows_to_sort", max_rows_to_sort)
        if max_rows_to_transfer is not None:
            pulumi.set(__self__, "max_rows_to_transfer", max_rows_to_transfer)
        if max_temporary_columns is not None:
            pulumi.set(__self__, "max_temporary_columns", max_temporary_columns)
        if max_temporary_non_const_columns is not None:
            pulumi.set(__self__, "max_temporary_non_const_columns", max_temporary_non_const_columns)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if merge_tree_max_bytes_to_use_cache is not None:
            pulumi.set(__self__, "merge_tree_max_bytes_to_use_cache", merge_tree_max_bytes_to_use_cache)
        if merge_tree_max_rows_to_use_cache is not None:
            pulumi.set(__self__, "merge_tree_max_rows_to_use_cache", merge_tree_max_rows_to_use_cache)
        if merge_tree_min_bytes_for_concurrent_read is not None:
            pulumi.set(__self__, "merge_tree_min_bytes_for_concurrent_read", merge_tree_min_bytes_for_concurrent_read)
        if merge_tree_min_rows_for_concurrent_read is not None:
            pulumi.set(__self__, "merge_tree_min_rows_for_concurrent_read", merge_tree_min_rows_for_concurrent_read)
        if min_bytes_to_use_direct_io is not None:
            pulumi.set(__self__, "min_bytes_to_use_direct_io", min_bytes_to_use_direct_io)
        if min_count_to_compile is not None:
            pulumi.set(__self__, "min_count_to_compile", min_count_to_compile)
        if min_count_to_compile_expression is not None:
            pulumi.set(__self__, "min_count_to_compile_expression", min_count_to_compile_expression)
        if min_execution_speed is not None:
            pulumi.set(__self__, "min_execution_speed", min_execution_speed)
        if min_execution_speed_bytes is not None:
            pulumi.set(__self__, "min_execution_speed_bytes", min_execution_speed_bytes)
        if min_insert_block_size_bytes is not None:
            pulumi.set(__self__, "min_insert_block_size_bytes", min_insert_block_size_bytes)
        if min_insert_block_size_rows is not None:
            pulumi.set(__self__, "min_insert_block_size_rows", min_insert_block_size_rows)
        if output_format_json_quote64bit_integers is not None:
            pulumi.set(__self__, "output_format_json_quote64bit_integers", output_format_json_quote64bit_integers)
        if output_format_json_quote_denormals is not None:
            pulumi.set(__self__, "output_format_json_quote_denormals", output_format_json_quote_denormals)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if quota_mode is not None:
            pulumi.set(__self__, "quota_mode", quota_mode)
        if read_overflow_mode is not None:
            pulumi.set(__self__, "read_overflow_mode", read_overflow_mode)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if receive_timeout is not None:
            pulumi.set(__self__, "receive_timeout", receive_timeout)
        if replication_alter_partitions_sync is not None:
            pulumi.set(__self__, "replication_alter_partitions_sync", replication_alter_partitions_sync)
        if result_overflow_mode is not None:
            pulumi.set(__self__, "result_overflow_mode", result_overflow_mode)
        if select_sequential_consistency is not None:
            pulumi.set(__self__, "select_sequential_consistency", select_sequential_consistency)
        if send_progress_in_http_headers is not None:
            pulumi.set(__self__, "send_progress_in_http_headers", send_progress_in_http_headers)
        if send_timeout is not None:
            pulumi.set(__self__, "send_timeout", send_timeout)
        if set_overflow_mode is not None:
            pulumi.set(__self__, "set_overflow_mode", set_overflow_mode)
        if skip_unavailable_shards is not None:
            pulumi.set(__self__, "skip_unavailable_shards", skip_unavailable_shards)
        if sort_overflow_mode is not None:
            pulumi.set(__self__, "sort_overflow_mode", sort_overflow_mode)
        if timeout_overflow_mode is not None:
            pulumi.set(__self__, "timeout_overflow_mode", timeout_overflow_mode)
        if transfer_overflow_mode is not None:
            pulumi.set(__self__, "transfer_overflow_mode", transfer_overflow_mode)
        if transform_null_in is not None:
            pulumi.set(__self__, "transform_null_in", transform_null_in)
        if use_uncompressed_cache is not None:
            pulumi.set(__self__, "use_uncompressed_cache", use_uncompressed_cache)

    @property
    @pulumi.getter(name="addHttpCorsHeader")
    def add_http_cors_header(self) -> Optional[bool]:
        """
        Include CORS headers in HTTP responces.
        """
        return pulumi.get(self, "add_http_cors_header")

    @property
    @pulumi.getter(name="allowDdl")
    def allow_ddl(self) -> Optional[bool]:
        """
        Allows or denies DDL queries.
        """
        return pulumi.get(self, "allow_ddl")

    @property
    @pulumi.getter
    def compile(self) -> Optional[bool]:
        """
        Enable compilation of queries.
        """
        return pulumi.get(self, "compile")

    @property
    @pulumi.getter(name="compileExpressions")
    def compile_expressions(self) -> Optional[bool]:
        """
        Turn on expression compilation.
        """
        return pulumi.get(self, "compile_expressions")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="countDistinctImplementation")
    def count_distinct_implementation(self) -> Optional[str]:
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT …) construction.
        """
        return pulumi.get(self, "count_distinct_implementation")

    @property
    @pulumi.getter(name="distinctOverflowMode")
    def distinct_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow when using DISTINCT. Possible values:
        """
        return pulumi.get(self, "distinct_overflow_mode")

    @property
    @pulumi.getter(name="distributedAggregationMemoryEfficient")
    def distributed_aggregation_memory_efficient(self) -> Optional[bool]:
        """
        Determine the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_aggregation_memory_efficient")

    @property
    @pulumi.getter(name="distributedDdlTaskTimeout")
    def distributed_ddl_task_timeout(self) -> Optional[int]:
        """
        Timeout for DDL queries, in milliseconds.
        """
        return pulumi.get(self, "distributed_ddl_task_timeout")

    @property
    @pulumi.getter(name="distributedProductMode")
    def distributed_product_mode(self) -> Optional[str]:
        """
        Changes the behaviour of distributed subqueries.
        """
        return pulumi.get(self, "distributed_product_mode")

    @property
    @pulumi.getter(name="emptyResultForAggregationByEmptySet")
    def empty_result_for_aggregation_by_empty_set(self) -> Optional[bool]:
        """
        Allows to retunr empty result.
        """
        return pulumi.get(self, "empty_result_for_aggregation_by_empty_set")

    @property
    @pulumi.getter(name="enableHttpCompression")
    def enable_http_compression(self) -> Optional[bool]:
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        return pulumi.get(self, "enable_http_compression")

    @property
    @pulumi.getter(name="fallbackToStaleReplicasForDistributedQueries")
    def fallback_to_stale_replicas_for_distributed_queries(self) -> Optional[bool]:
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        return pulumi.get(self, "fallback_to_stale_replicas_for_distributed_queries")

    @property
    @pulumi.getter(name="forceIndexByDate")
    def force_index_by_date(self) -> Optional[bool]:
        """
        Disables query execution if the index can’t be used by date.
        """
        return pulumi.get(self, "force_index_by_date")

    @property
    @pulumi.getter(name="forcePrimaryKey")
    def force_primary_key(self) -> Optional[bool]:
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        return pulumi.get(self, "force_primary_key")

    @property
    @pulumi.getter(name="groupByOverflowMode")
    def group_by_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow while GROUP BY operation. Possible values:
        """
        return pulumi.get(self, "group_by_overflow_mode")

    @property
    @pulumi.getter(name="groupByTwoLevelThreshold")
    def group_by_two_level_threshold(self) -> Optional[int]:
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold")

    @property
    @pulumi.getter(name="groupByTwoLevelThresholdBytes")
    def group_by_two_level_threshold_bytes(self) -> Optional[int]:
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold_bytes")

    @property
    @pulumi.getter(name="httpConnectionTimeout")
    def http_connection_timeout(self) -> Optional[int]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_connection_timeout")

    @property
    @pulumi.getter(name="httpHeadersProgressInterval")
    def http_headers_progress_interval(self) -> Optional[int]:
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        return pulumi.get(self, "http_headers_progress_interval")

    @property
    @pulumi.getter(name="httpReceiveTimeout")
    def http_receive_timeout(self) -> Optional[int]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_receive_timeout")

    @property
    @pulumi.getter(name="httpSendTimeout")
    def http_send_timeout(self) -> Optional[int]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_send_timeout")

    @property
    @pulumi.getter(name="inputFormatDefaultsForOmittedFields")
    def input_format_defaults_for_omitted_fields(self) -> Optional[bool]:
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        return pulumi.get(self, "input_format_defaults_for_omitted_fields")

    @property
    @pulumi.getter(name="inputFormatValuesInterpretExpressions")
    def input_format_values_interpret_expressions(self) -> Optional[bool]:
        """
        Enables or disables the full SQL parser if the fast stream parser can’t parse the data.
        """
        return pulumi.get(self, "input_format_values_interpret_expressions")

    @property
    @pulumi.getter(name="insertQuorum")
    def insert_quorum(self) -> Optional[int]:
        """
        Enables the quorum writes.
        """
        return pulumi.get(self, "insert_quorum")

    @property
    @pulumi.getter(name="insertQuorumTimeout")
    def insert_quorum_timeout(self) -> Optional[int]:
        """
        Write to a quorum timeout in milliseconds.
        """
        return pulumi.get(self, "insert_quorum_timeout")

    @property
    @pulumi.getter(name="joinOverflowMode")
    def join_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow in JOIN. Possible values:
        """
        return pulumi.get(self, "join_overflow_mode")

    @property
    @pulumi.getter(name="joinUseNulls")
    def join_use_nulls(self) -> Optional[bool]:
        """
        Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        return pulumi.get(self, "join_use_nulls")

    @property
    @pulumi.getter(name="joinedSubqueryRequiresAlias")
    def joined_subquery_requires_alias(self) -> Optional[bool]:
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        return pulumi.get(self, "joined_subquery_requires_alias")

    @property
    @pulumi.getter(name="lowCardinalityAllowInNativeFormat")
    def low_cardinality_allow_in_native_format(self) -> Optional[bool]:
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        return pulumi.get(self, "low_cardinality_allow_in_native_format")

    @property
    @pulumi.getter(name="maxAstDepth")
    def max_ast_depth(self) -> Optional[int]:
        """
        Maximum abstract syntax tree depth.
        """
        return pulumi.get(self, "max_ast_depth")

    @property
    @pulumi.getter(name="maxAstElements")
    def max_ast_elements(self) -> Optional[int]:
        """
        Maximum abstract syntax tree elements.
        """
        return pulumi.get(self, "max_ast_elements")

    @property
    @pulumi.getter(name="maxBlockSize")
    def max_block_size(self) -> Optional[int]:
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        return pulumi.get(self, "max_block_size")

    @property
    @pulumi.getter(name="maxBytesBeforeExternalGroupBy")
    def max_bytes_before_external_group_by(self) -> Optional[int]:
        """
        Limit in bytes for using memoru for GROUP BY before using swap on disk.
        """
        return pulumi.get(self, "max_bytes_before_external_group_by")

    @property
    @pulumi.getter(name="maxBytesBeforeExternalSort")
    def max_bytes_before_external_sort(self) -> Optional[int]:
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        return pulumi.get(self, "max_bytes_before_external_sort")

    @property
    @pulumi.getter(name="maxBytesInDistinct")
    def max_bytes_in_distinct(self) -> Optional[int]:
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        return pulumi.get(self, "max_bytes_in_distinct")

    @property
    @pulumi.getter(name="maxBytesInJoin")
    def max_bytes_in_join(self) -> Optional[int]:
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        return pulumi.get(self, "max_bytes_in_join")

    @property
    @pulumi.getter(name="maxBytesInSet")
    def max_bytes_in_set(self) -> Optional[int]:
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_bytes_in_set")

    @property
    @pulumi.getter(name="maxBytesToRead")
    def max_bytes_to_read(self) -> Optional[int]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_bytes_to_read")

    @property
    @pulumi.getter(name="maxBytesToSort")
    def max_bytes_to_sort(self) -> Optional[int]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_bytes_to_sort")

    @property
    @pulumi.getter(name="maxBytesToTransfer")
    def max_bytes_to_transfer(self) -> Optional[int]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_bytes_to_transfer")

    @property
    @pulumi.getter(name="maxColumnsToRead")
    def max_columns_to_read(self) -> Optional[int]:
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        return pulumi.get(self, "max_columns_to_read")

    @property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> Optional[int]:
        """
        Limits the maximum query execution time in milliseconds.
        """
        return pulumi.get(self, "max_execution_time")

    @property
    @pulumi.getter(name="maxExpandedAstElements")
    def max_expanded_ast_elements(self) -> Optional[int]:
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        return pulumi.get(self, "max_expanded_ast_elements")

    @property
    @pulumi.getter(name="maxInsertBlockSize")
    def max_insert_block_size(self) -> Optional[int]:
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        return pulumi.get(self, "max_insert_block_size")

    @property
    @pulumi.getter(name="maxMemoryUsage")
    def max_memory_usage(self) -> Optional[int]:
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage")

    @property
    @pulumi.getter(name="maxMemoryUsageForUser")
    def max_memory_usage_for_user(self) -> Optional[int]:
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage_for_user")

    @property
    @pulumi.getter(name="maxNetworkBandwidth")
    def max_network_bandwidth(self) -> Optional[int]:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth")

    @property
    @pulumi.getter(name="maxNetworkBandwidthForUser")
    def max_network_bandwidth_for_user(self) -> Optional[int]:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth_for_user")

    @property
    @pulumi.getter(name="maxQuerySize")
    def max_query_size(self) -> Optional[int]:
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        return pulumi.get(self, "max_query_size")

    @property
    @pulumi.getter(name="maxReplicaDelayForDistributedQueries")
    def max_replica_delay_for_distributed_queries(self) -> Optional[int]:
        """
        Disables lagging replicas for distributed queries.
        """
        return pulumi.get(self, "max_replica_delay_for_distributed_queries")

    @property
    @pulumi.getter(name="maxResultBytes")
    def max_result_bytes(self) -> Optional[int]:
        """
        Limits the number of bytes in the result.
        """
        return pulumi.get(self, "max_result_bytes")

    @property
    @pulumi.getter(name="maxResultRows")
    def max_result_rows(self) -> Optional[int]:
        """
        Limits the number of rows in the result.
        """
        return pulumi.get(self, "max_result_rows")

    @property
    @pulumi.getter(name="maxRowsInDistinct")
    def max_rows_in_distinct(self) -> Optional[int]:
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        return pulumi.get(self, "max_rows_in_distinct")

    @property
    @pulumi.getter(name="maxRowsInJoin")
    def max_rows_in_join(self) -> Optional[int]:
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        return pulumi.get(self, "max_rows_in_join")

    @property
    @pulumi.getter(name="maxRowsInSet")
    def max_rows_in_set(self) -> Optional[int]:
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_rows_in_set")

    @property
    @pulumi.getter(name="maxRowsToGroupBy")
    def max_rows_to_group_by(self) -> Optional[int]:
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        return pulumi.get(self, "max_rows_to_group_by")

    @property
    @pulumi.getter(name="maxRowsToRead")
    def max_rows_to_read(self) -> Optional[int]:
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_rows_to_read")

    @property
    @pulumi.getter(name="maxRowsToSort")
    def max_rows_to_sort(self) -> Optional[int]:
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_rows_to_sort")

    @property
    @pulumi.getter(name="maxRowsToTransfer")
    def max_rows_to_transfer(self) -> Optional[int]:
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_rows_to_transfer")

    @property
    @pulumi.getter(name="maxTemporaryColumns")
    def max_temporary_columns(self) -> Optional[int]:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        return pulumi.get(self, "max_temporary_columns")

    @property
    @pulumi.getter(name="maxTemporaryNonConstColumns")
    def max_temporary_non_const_columns(self) -> Optional[int]:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        return pulumi.get(self, "max_temporary_non_const_columns")

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[int]:
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        return pulumi.get(self, "max_threads")

    @property
    @pulumi.getter(name="mergeTreeMaxBytesToUseCache")
    def merge_tree_max_bytes_to_use_cache(self) -> Optional[int]:
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesn’t use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_bytes_to_use_cache")

    @property
    @pulumi.getter(name="mergeTreeMaxRowsToUseCache")
    def merge_tree_max_rows_to_use_cache(self) -> Optional[int]:
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesn’t use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_rows_to_use_cache")

    @property
    @pulumi.getter(name="mergeTreeMinBytesForConcurrentRead")
    def merge_tree_min_bytes_for_concurrent_read(self) -> Optional[int]:
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        return pulumi.get(self, "merge_tree_min_bytes_for_concurrent_read")

    @property
    @pulumi.getter(name="mergeTreeMinRowsForConcurrentRead")
    def merge_tree_min_rows_for_concurrent_read(self) -> Optional[int]:
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        return pulumi.get(self, "merge_tree_min_rows_for_concurrent_read")

    @property
    @pulumi.getter(name="minBytesToUseDirectIo")
    def min_bytes_to_use_direct_io(self) -> Optional[int]:
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        return pulumi.get(self, "min_bytes_to_use_direct_io")

    @property
    @pulumi.getter(name="minCountToCompile")
    def min_count_to_compile(self) -> Optional[int]:
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        return pulumi.get(self, "min_count_to_compile")

    @property
    @pulumi.getter(name="minCountToCompileExpression")
    def min_count_to_compile_expression(self) -> Optional[int]:
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        return pulumi.get(self, "min_count_to_compile_expression")

    @property
    @pulumi.getter(name="minExecutionSpeed")
    def min_execution_speed(self) -> Optional[int]:
        """
        Minimal execution speed in rows per second.
        """
        return pulumi.get(self, "min_execution_speed")

    @property
    @pulumi.getter(name="minExecutionSpeedBytes")
    def min_execution_speed_bytes(self) -> Optional[int]:
        """
        Minimal execution speed in bytes per second.
        """
        return pulumi.get(self, "min_execution_speed_bytes")

    @property
    @pulumi.getter(name="minInsertBlockSizeBytes")
    def min_insert_block_size_bytes(self) -> Optional[int]:
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_bytes")

    @property
    @pulumi.getter(name="minInsertBlockSizeRows")
    def min_insert_block_size_rows(self) -> Optional[int]:
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_rows")

    @property
    @pulumi.getter(name="outputFormatJsonQuote64bitIntegers")
    def output_format_json_quote64bit_integers(self) -> Optional[bool]:
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        return pulumi.get(self, "output_format_json_quote64bit_integers")

    @property
    @pulumi.getter(name="outputFormatJsonQuoteDenormals")
    def output_format_json_quote_denormals(self) -> Optional[bool]:
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        return pulumi.get(self, "output_format_json_quote_denormals")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Query priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="quotaMode")
    def quota_mode(self) -> Optional[str]:
        """
        Quota accounting mode.
        """
        return pulumi.get(self, "quota_mode")

    @property
    @pulumi.getter(name="readOverflowMode")
    def read_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow while read. Possible values:
        """
        return pulumi.get(self, "read_overflow_mode")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[int]:
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter(name="receiveTimeout")
    def receive_timeout(self) -> Optional[int]:
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "receive_timeout")

    @property
    @pulumi.getter(name="replicationAlterPartitionsSync")
    def replication_alter_partitions_sync(self) -> Optional[int]:
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        return pulumi.get(self, "replication_alter_partitions_sync")

    @property
    @pulumi.getter(name="resultOverflowMode")
    def result_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow in result. Possible values:
        """
        return pulumi.get(self, "result_overflow_mode")

    @property
    @pulumi.getter(name="selectSequentialConsistency")
    def select_sequential_consistency(self) -> Optional[bool]:
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        return pulumi.get(self, "select_sequential_consistency")

    @property
    @pulumi.getter(name="sendProgressInHttpHeaders")
    def send_progress_in_http_headers(self) -> Optional[bool]:
        """
        Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        """
        return pulumi.get(self, "send_progress_in_http_headers")

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> Optional[int]:
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "send_timeout")

    @property
    @pulumi.getter(name="setOverflowMode")
    def set_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow in the set resulting. Possible values:
        """
        return pulumi.get(self, "set_overflow_mode")

    @property
    @pulumi.getter(name="skipUnavailableShards")
    def skip_unavailable_shards(self) -> Optional[bool]:
        """
        Enables or disables silently skipping of unavailable shards.
        """
        return pulumi.get(self, "skip_unavailable_shards")

    @property
    @pulumi.getter(name="sortOverflowMode")
    def sort_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow while sort. Possible values:
        """
        return pulumi.get(self, "sort_overflow_mode")

    @property
    @pulumi.getter(name="timeoutOverflowMode")
    def timeout_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "timeout_overflow_mode")

    @property
    @pulumi.getter(name="transferOverflowMode")
    def transfer_overflow_mode(self) -> Optional[str]:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "transfer_overflow_mode")

    @property
    @pulumi.getter(name="transformNullIn")
    def transform_null_in(self) -> Optional[bool]:
        """
        Enables equality of NULL values for IN operator.
        """
        return pulumi.get(self, "transform_null_in")

    @property
    @pulumi.getter(name="useUncompressedCache")
    def use_uncompressed_cache(self) -> Optional[bool]:
        """
        Whether to use a cache of uncompressed blocks.
        """
        return pulumi.get(self, "use_uncompressed_cache")


@pulumi.output_type
class MdbClickhouseClusterZookeeper(dict):
    def __init__(__self__, *,
                 resources: Optional['outputs.MdbClickhouseClusterZookeeperResources'] = None):
        """
        :param 'MdbClickhouseClusterZookeeperResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MdbClickhouseClusterZookeeperResources']:
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbClickhouseClusterZookeeperResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterZookeeperResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterZookeeperResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterZookeeperResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: Optional[int] = None,
                 disk_type_id: Optional[str] = None,
                 resource_preset_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param str disk_type_id: Type of the storage of ZooKeeper hosts.
               For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        Type of the storage of ZooKeeper hosts.
        For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbElasticSearchClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "dataNode":
            suggest = "data_node"
        elif key == "masterNode":
            suggest = "master_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbElasticSearchClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbElasticSearchClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbElasticSearchClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: str,
                 data_node: 'outputs.MdbElasticSearchClusterConfigDataNode',
                 edition: Optional[str] = None,
                 master_node: Optional['outputs.MdbElasticSearchClusterConfigMasterNode'] = None,
                 plugins: Optional[Sequence[str]] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: Password for admin user of Elasticsearch.
        :param 'MdbElasticSearchClusterConfigDataNodeArgs' data_node: Configuration for Elasticsearch data nodes subcluster. The structure is documented below.
        :param str edition: Edition of Elasticsearch. For more information, see [the official documentation](https://cloud.yandex.com/en-ru/docs/managed-elasticsearch/concepts/es-editions).
        :param 'MdbElasticSearchClusterConfigMasterNodeArgs' master_node: Configuration for Elasticsearch master nodes subcluster. The structure is documented below.
        :param Sequence[str] plugins: A set of Elasticsearch plugins to install.
        :param str version: Version of Elasticsearch.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "data_node", data_node)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if master_node is not None:
            pulumi.set(__self__, "master_node", master_node)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        """
        Password for admin user of Elasticsearch.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="dataNode")
    def data_node(self) -> 'outputs.MdbElasticSearchClusterConfigDataNode':
        """
        Configuration for Elasticsearch data nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "data_node")

    @property
    @pulumi.getter
    def edition(self) -> Optional[str]:
        """
        Edition of Elasticsearch. For more information, see [the official documentation](https://cloud.yandex.com/en-ru/docs/managed-elasticsearch/concepts/es-editions).
        """
        return pulumi.get(self, "edition")

    @property
    @pulumi.getter(name="masterNode")
    def master_node(self) -> Optional['outputs.MdbElasticSearchClusterConfigMasterNode']:
        """
        Configuration for Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "master_node")

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence[str]]:
        """
        A set of Elasticsearch plugins to install.
        """
        return pulumi.get(self, "plugins")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of Elasticsearch.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MdbElasticSearchClusterConfigDataNode(dict):
    def __init__(__self__, *,
                 resources: 'outputs.MdbElasticSearchClusterConfigDataNodeResources'):
        """
        :param 'MdbElasticSearchClusterConfigDataNodeResourcesArgs' resources: Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbElasticSearchClusterConfigDataNodeResources':
        """
        Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbElasticSearchClusterConfigDataNodeResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbElasticSearchClusterConfigDataNodeResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbElasticSearchClusterConfigDataNodeResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbElasticSearchClusterConfigDataNodeResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of Elasticsearch hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of Elasticsearch hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbElasticSearchClusterConfigMasterNode(dict):
    def __init__(__self__, *,
                 resources: 'outputs.MdbElasticSearchClusterConfigMasterNodeResources'):
        """
        :param 'MdbElasticSearchClusterConfigMasterNodeResourcesArgs' resources: Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbElasticSearchClusterConfigMasterNodeResources':
        """
        Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbElasticSearchClusterConfigMasterNodeResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbElasticSearchClusterConfigMasterNodeResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbElasticSearchClusterConfigMasterNodeResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbElasticSearchClusterConfigMasterNodeResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of Elasticsearch hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of Elasticsearch hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbElasticSearchClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbElasticSearchClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbElasticSearchClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbElasticSearchClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 type: str,
                 zone: str,
                 assign_public_ip: Optional[bool] = None,
                 fqdn: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str name: User defined host name.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str zone: The availability zone where the Elasticsearch host will be created.
               For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        :param str fqdn: The fully qualified domain name of the host.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must
               be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User defined host name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the Elasticsearch host will be created.
        For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must
        be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbElasticSearchClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: str,
                 day: Optional[str] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbGreenplumClusterAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "webSql":
            suggest = "web_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[bool] = None,
                 web_sql: Optional[bool] = None):
        """
        :param bool data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param bool web_sql: Allows access for SQL queries in the management console
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[bool]:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[bool]:
        """
        Allows access for SQL queries in the management console
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class MdbGreenplumClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started (UTC).
        :param int minutes: The minute at which backup will be started (UTC).
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started (UTC).
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbGreenplumClusterMasterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterMasterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterMasterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterMasterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_public_ip: Optional[bool] = None,
                 fqdn: Optional[str] = None):
        """
        :param bool assign_public_ip: Sets whether the master hosts should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        :param str fqdn: (Computed) The fully qualified domain name of the host.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Sets whether the master hosts should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        (Computed) The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class MdbGreenplumClusterMasterSubcluster(dict):
    def __init__(__self__, *,
                 resources: 'outputs.MdbGreenplumClusterMasterSubclusterResources'):
        """
        :param 'MdbGreenplumClusterMasterSubclusterResourcesArgs' resources: Resources allocated to hosts for segment subcluster of the Greenplum cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbGreenplumClusterMasterSubclusterResources':
        """
        Resources allocated to hosts for segment subcluster of the Greenplum cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbGreenplumClusterMasterSubclusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterMasterSubclusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterMasterSubclusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterMasterSubclusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbGreenplumClusterSegmentHost(dict):
    def __init__(__self__, *,
                 fqdn: Optional[str] = None):
        """
        :param str fqdn: (Computed) The fully qualified domain name of the host.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        (Computed) The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class MdbGreenplumClusterSegmentSubcluster(dict):
    def __init__(__self__, *,
                 resources: 'outputs.MdbGreenplumClusterSegmentSubclusterResources'):
        """
        :param 'MdbGreenplumClusterSegmentSubclusterResourcesArgs' resources: Resources allocated to hosts for segment subcluster of the Greenplum cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbGreenplumClusterSegmentSubclusterResources':
        """
        Resources allocated to hosts for segment subcluster of the Greenplum cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbGreenplumClusterSegmentSubclusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterSegmentSubclusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterSegmentSubclusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterSegmentSubclusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbKafkaClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "brokersCount":
            suggest = "brokers_count"
        elif key == "schemaRegistry":
            suggest = "schema_registry"
        elif key == "unmanagedTopics":
            suggest = "unmanaged_topics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka: 'outputs.MdbKafkaClusterConfigKafka',
                 version: str,
                 zones: Sequence[str],
                 assign_public_ip: Optional[bool] = None,
                 brokers_count: Optional[int] = None,
                 schema_registry: Optional[bool] = None,
                 unmanaged_topics: Optional[bool] = None,
                 zookeeper: Optional['outputs.MdbKafkaClusterConfigZookeeper'] = None):
        """
        :param 'MdbKafkaClusterConfigKafkaArgs' kafka: Configuration of the Kafka subcluster. The structure is documented below.
        :param str version: Version of the Kafka server software.
        :param Sequence[str] zones: List of availability zones.
        :param bool assign_public_ip: Determines whether each broker will be assigned a public IP address. The default is `false`.
        :param int brokers_count: Count of brokers per availability zone. The default is `1`.
        :param bool schema_registry: Enables managed schema registry on cluster. The default is `false`.
        :param bool unmanaged_topics: Allows to use Kafka AdminAPI to manage topics. The default is `false`.
        :param 'MdbKafkaClusterConfigZookeeperArgs' zookeeper: Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zones", zones)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if brokers_count is not None:
            pulumi.set(__self__, "brokers_count", brokers_count)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if unmanaged_topics is not None:
            pulumi.set(__self__, "unmanaged_topics", unmanaged_topics)
        if zookeeper is not None:
            pulumi.set(__self__, "zookeeper", zookeeper)

    @property
    @pulumi.getter
    def kafka(self) -> 'outputs.MdbKafkaClusterConfigKafka':
        """
        Configuration of the Kafka subcluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the Kafka server software.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        List of availability zones.
        """
        return pulumi.get(self, "zones")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Determines whether each broker will be assigned a public IP address. The default is `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="brokersCount")
    def brokers_count(self) -> Optional[int]:
        """
        Count of brokers per availability zone. The default is `1`.
        """
        return pulumi.get(self, "brokers_count")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[bool]:
        """
        Enables managed schema registry on cluster. The default is `false`.
        """
        return pulumi.get(self, "schema_registry")

    @property
    @pulumi.getter(name="unmanagedTopics")
    def unmanaged_topics(self) -> Optional[bool]:
        """
        Allows to use Kafka AdminAPI to manage topics. The default is `false`.
        """
        return pulumi.get(self, "unmanaged_topics")

    @property
    @pulumi.getter
    def zookeeper(self) -> Optional['outputs.MdbKafkaClusterConfigZookeeper']:
        """
        Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "zookeeper")


@pulumi.output_type
class MdbKafkaClusterConfigKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConfig":
            suggest = "kafka_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resources: 'outputs.MdbKafkaClusterConfigKafkaResources',
                 kafka_config: Optional['outputs.MdbKafkaClusterConfigKafkaKafkaConfig'] = None):
        """
        :param 'MdbKafkaClusterConfigKafkaResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        :param 'MdbKafkaClusterConfigKafkaKafkaConfigArgs' kafka_config: User-defined settings for the Kafka cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)
        if kafka_config is not None:
            pulumi.set(__self__, "kafka_config", kafka_config)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbKafkaClusterConfigKafkaResources':
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="kafkaConfig")
    def kafka_config(self) -> Optional['outputs.MdbKafkaClusterConfigKafkaKafkaConfig']:
        """
        User-defined settings for the Kafka cluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka_config")


@pulumi.output_type
class MdbKafkaClusterConfigKafkaKafkaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoCreateTopicsEnable":
            suggest = "auto_create_topics_enable"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "defaultReplicationFactor":
            suggest = "default_replication_factor"
        elif key == "logFlushIntervalMessages":
            suggest = "log_flush_interval_messages"
        elif key == "logFlushIntervalMs":
            suggest = "log_flush_interval_ms"
        elif key == "logFlushSchedulerIntervalMs":
            suggest = "log_flush_scheduler_interval_ms"
        elif key == "logPreallocate":
            suggest = "log_preallocate"
        elif key == "logRetentionBytes":
            suggest = "log_retention_bytes"
        elif key == "logRetentionHours":
            suggest = "log_retention_hours"
        elif key == "logRetentionMinutes":
            suggest = "log_retention_minutes"
        elif key == "logRetentionMs":
            suggest = "log_retention_ms"
        elif key == "logSegmentBytes":
            suggest = "log_segment_bytes"
        elif key == "numPartitions":
            suggest = "num_partitions"
        elif key == "socketReceiveBufferBytes":
            suggest = "socket_receive_buffer_bytes"
        elif key == "socketSendBufferBytes":
            suggest = "socket_send_buffer_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigKafkaKafkaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigKafkaKafkaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigKafkaKafkaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[bool] = None,
                 compression_type: Optional[str] = None,
                 default_replication_factor: Optional[str] = None,
                 log_flush_interval_messages: Optional[str] = None,
                 log_flush_interval_ms: Optional[str] = None,
                 log_flush_scheduler_interval_ms: Optional[str] = None,
                 log_preallocate: Optional[bool] = None,
                 log_retention_bytes: Optional[str] = None,
                 log_retention_hours: Optional[str] = None,
                 log_retention_minutes: Optional[str] = None,
                 log_retention_ms: Optional[str] = None,
                 log_segment_bytes: Optional[str] = None,
                 num_partitions: Optional[str] = None,
                 socket_receive_buffer_bytes: Optional[str] = None,
                 socket_send_buffer_bytes: Optional[str] = None):
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_flush_scheduler_interval_ms is not None:
            pulumi.set(__self__, "log_flush_scheduler_interval_ms", log_flush_scheduler_interval_ms)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_minutes is not None:
            pulumi.set(__self__, "log_retention_minutes", log_retention_minutes)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if socket_receive_buffer_bytes is not None:
            pulumi.set(__self__, "socket_receive_buffer_bytes", socket_receive_buffer_bytes)
        if socket_send_buffer_bytes is not None:
            pulumi.set(__self__, "socket_send_buffer_bytes", socket_send_buffer_bytes)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[bool]:
        return pulumi.get(self, "auto_create_topics_enable")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[str]:
        return pulumi.get(self, "default_replication_factor")

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_messages")

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_ms")

    @property
    @pulumi.getter(name="logFlushSchedulerIntervalMs")
    def log_flush_scheduler_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_scheduler_interval_ms")

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[bool]:
        return pulumi.get(self, "log_preallocate")

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_bytes")

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_hours")

    @property
    @pulumi.getter(name="logRetentionMinutes")
    def log_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_minutes")

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_ms")

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_bytes")

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[str]:
        return pulumi.get(self, "num_partitions")

    @property
    @pulumi.getter(name="socketReceiveBufferBytes")
    def socket_receive_buffer_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_receive_buffer_bytes")

    @property
    @pulumi.getter(name="socketSendBufferBytes")
    def socket_send_buffer_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_send_buffer_bytes")


@pulumi.output_type
class MdbKafkaClusterConfigKafkaResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigKafkaResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigKafkaResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigKafkaResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param str disk_type_id: Type of the storage of ZooKeeper hosts.
               For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of ZooKeeper hosts.
        For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbKafkaClusterConfigZookeeper(dict):
    def __init__(__self__, *,
                 resources: Optional['outputs.MdbKafkaClusterConfigZookeeperResources'] = None):
        """
        :param 'MdbKafkaClusterConfigZookeeperResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MdbKafkaClusterConfigZookeeperResources']:
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbKafkaClusterConfigZookeeperResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigZookeeperResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigZookeeperResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigZookeeperResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: Optional[int] = None,
                 disk_type_id: Optional[str] = None,
                 resource_preset_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param str disk_type_id: Type of the storage of ZooKeeper hosts.
               For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        Type of the storage of ZooKeeper hosts.
        For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbKafkaClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_public_ip: Optional[bool] = None,
                 health: Optional[str] = None,
                 name: Optional[str] = None,
                 role: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 zone_id: Optional[str] = None):
        """
        :param bool assign_public_ip: Determines whether each broker will be assigned a public IP address. The default is `false`.
        :param str health: Health of the host.
        :param str name: The name of the topic.
        :param str role: The role type to grant to the topic.
        :param str subnet_id: The ID of the subnet, to which the host belongs.
        :param str zone_id: The availability zone where the Kafka host was created.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Determines whether each broker will be assigned a public IP address. The default is `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def health(self) -> Optional[str]:
        """
        Health of the host.
        """
        return pulumi.get(self, "health")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet, to which the host belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        The availability zone where the Kafka host was created.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class MdbKafkaClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: str,
                 day: Optional[str] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str day: Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbKafkaClusterTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationFactor":
            suggest = "replication_factor"
        elif key == "topicConfig":
            suggest = "topic_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 partitions: int,
                 replication_factor: int,
                 topic_config: Optional['outputs.MdbKafkaClusterTopicTopicConfig'] = None):
        """
        :param str name: The name of the topic.
        :param int partitions: The number of the topic's partitions.
        :param int replication_factor: Amount of data copies (replicas) for the topic in the cluster.
        :param 'MdbKafkaClusterTopicTopicConfigArgs' topic_config: User-defined settings for the topic. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replication_factor", replication_factor)
        if topic_config is not None:
            pulumi.set(__self__, "topic_config", topic_config)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> int:
        """
        The number of the topic's partitions.
        """
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> int:
        """
        Amount of data copies (replicas) for the topic in the cluster.
        """
        return pulumi.get(self, "replication_factor")

    @property
    @pulumi.getter(name="topicConfig")
    def topic_config(self) -> Optional['outputs.MdbKafkaClusterTopicTopicConfig']:
        """
        User-defined settings for the topic. The structure is documented below.
        """
        return pulumi.get(self, "topic_config")


@pulumi.output_type
class MdbKafkaClusterTopicTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "deleteRetentionMs":
            suggest = "delete_retention_ms"
        elif key == "fileDeleteDelayMs":
            suggest = "file_delete_delay_ms"
        elif key == "flushMessages":
            suggest = "flush_messages"
        elif key == "flushMs":
            suggest = "flush_ms"
        elif key == "maxMessageBytes":
            suggest = "max_message_bytes"
        elif key == "minCompactionLagMs":
            suggest = "min_compaction_lag_ms"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "retentionBytes":
            suggest = "retention_bytes"
        elif key == "retentionMs":
            suggest = "retention_ms"
        elif key == "segmentBytes":
            suggest = "segment_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterTopicTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterTopicTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterTopicTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[bool] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None):
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[bool]:
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class MdbKafkaClusterUser(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permissions: Optional[Sequence['outputs.MdbKafkaClusterUserPermission']] = None):
        """
        :param str name: The name of the topic.
        :param str password: The password of the user.
        :param Sequence['MdbKafkaClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbKafkaClusterUserPermission']]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbKafkaClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: str,
                 topic_name: str):
        """
        :param str role: The role type to grant to the topic.
        :param str topic_name: The name of the topic that the permission grants access to.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> str:
        """
        The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class MdbKafkaTopicTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "deleteRetentionMs":
            suggest = "delete_retention_ms"
        elif key == "fileDeleteDelayMs":
            suggest = "file_delete_delay_ms"
        elif key == "flushMessages":
            suggest = "flush_messages"
        elif key == "flushMs":
            suggest = "flush_ms"
        elif key == "maxMessageBytes":
            suggest = "max_message_bytes"
        elif key == "minCompactionLagMs":
            suggest = "min_compaction_lag_ms"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "retentionBytes":
            suggest = "retention_bytes"
        elif key == "retentionMs":
            suggest = "retention_ms"
        elif key == "segmentBytes":
            suggest = "segment_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaTopicTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaTopicTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaTopicTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[bool] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None):
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[bool]:
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class MdbMongodbClusterClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupWindowStart":
            suggest = "backup_window_start"
        elif key == "featureCompatibilityVersion":
            suggest = "feature_compatibility_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 access: Optional['outputs.MdbMongodbClusterClusterConfigAccess'] = None,
                 backup_window_start: Optional['outputs.MdbMongodbClusterClusterConfigBackupWindowStart'] = None,
                 feature_compatibility_version: Optional[str] = None):
        """
        :param str version: Version of MongoDB (either 5.0, 4.4, 4.2 or 4.0).
        :param 'MdbMongodbClusterClusterConfigAccessArgs' access: Shows whether cluster has access to data lens. The structure is documented below.
        :param 'MdbMongodbClusterClusterConfigBackupWindowStartArgs' backup_window_start: Time to start the daily backup, in the UTC timezone. The structure is documented below.
        :param str feature_compatibility_version: Feature compatibility version of MongoDB. If not provided version is taken. Can be either `5.0`, `4.4`, `4.2` and `4.0`.
        """
        pulumi.set(__self__, "version", version)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if feature_compatibility_version is not None:
            pulumi.set(__self__, "feature_compatibility_version", feature_compatibility_version)

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of MongoDB (either 5.0, 4.4, 4.2 or 4.0).
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def access(self) -> Optional['outputs.MdbMongodbClusterClusterConfigAccess']:
        """
        Shows whether cluster has access to data lens. The structure is documented below.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional['outputs.MdbMongodbClusterClusterConfigBackupWindowStart']:
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        return pulumi.get(self, "backup_window_start")

    @property
    @pulumi.getter(name="featureCompatibilityVersion")
    def feature_compatibility_version(self) -> Optional[str]:
        """
        Feature compatibility version of MongoDB. If not provided version is taken. Can be either `5.0`, `4.4`, `4.2` and `4.0`.
        """
        return pulumi.get(self, "feature_compatibility_version")


@pulumi.output_type
class MdbMongodbClusterClusterConfigAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[bool] = None):
        """
        :param bool data_lens: Allow access for DataLens.
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[bool]:
        """
        Allow access for DataLens.
        """
        return pulumi.get(self, "data_lens")


@pulumi.output_type
class MdbMongodbClusterClusterConfigBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbMongodbClusterDatabase(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The fully qualified domain name of the host. Computed on server side.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The fully qualified domain name of the host. Computed on server side.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbMongodbClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "shardName":
            suggest = "shard_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 zone_id: str,
                 assign_public_ip: Optional[bool] = None,
                 health: Optional[str] = None,
                 name: Optional[str] = None,
                 role: Optional[str] = None,
                 shard_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must
               be a part of the network to which the cluster belongs.
        :param str zone_id: The availability zone where the MongoDB host will be created.
               For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param bool assign_public_ip: -(Optional)  Should this host have assigned public IP assigned. Can be either `true` or `false`.
        :param str health: The health of the host.
        :param str name: The fully qualified domain name of the host. Computed on server side.
        :param str role: The role of the cluster (either PRIMARY or SECONDARY).
        :param str shard_name: The name of the shard to which the host belongs.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must
        be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The availability zone where the MongoDB host will be created.
        For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        -(Optional)  Should this host have assigned public IP assigned. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def health(self) -> Optional[str]:
        """
        The health of the host.
        """
        return pulumi.get(self, "health")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The fully qualified domain name of the host. Computed on server side.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The role of the cluster (either PRIMARY or SECONDARY).
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[str]:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MdbMongodbClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: str,
                 day: Optional[str] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbMongodbClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param str disk_type_id: Type of the storage of MongoDB hosts.
               For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of MongoDB hosts.
        For more information see [the official documentation](https://cloud.yandex.com/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMongodbClusterUser(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permissions: Optional[Sequence['outputs.MdbMongodbClusterUserPermission']] = None):
        """
        :param str name: The fully qualified domain name of the host. Computed on server side.
        :param str password: The password of the user.
        :param Sequence['MdbMongodbClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The fully qualified domain name of the host. Computed on server side.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbMongodbClusterUserPermission']]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbMongodbClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class MdbMysqlClusterAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "webSql":
            suggest = "web_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[bool] = None,
                 web_sql: Optional[bool] = None):
        """
        :param bool data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param bool web_sql: Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[bool]:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[bool]:
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class MdbMysqlClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbMysqlClusterDatabase(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbMysqlClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "replicationSource":
            suggest = "replication_source"
        elif key == "replicationSourceName":
            suggest = "replication_source_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: str,
                 assign_public_ip: Optional[bool] = None,
                 fqdn: Optional[str] = None,
                 name: Optional[str] = None,
                 replication_source: Optional[str] = None,
                 replication_source_name: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str zone: The availability zone where the MySQL host will be created.
        :param bool assign_public_ip: Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        :param str fqdn: The fully qualified domain name of the host.
        :param str name: Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        :param str replication_source: Host replication source (fqdn), when replication_source is empty then host is in HA group.
        :param str replication_source_name: Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if replication_source is not None:
            pulumi.set(__self__, "replication_source", replication_source)
        if replication_source_name is not None:
            pulumi.set(__self__, "replication_source_name", replication_source_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the MySQL host will be created.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> Optional[str]:
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        return pulumi.get(self, "replication_source")

    @property
    @pulumi.getter(name="replicationSourceName")
    def replication_source_name(self) -> Optional[str]:
        """
        Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "replication_source_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbMysqlClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: str,
                 day: Optional[str] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str day: Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of the week (in `DDD` format). Allowed values: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbMysqlClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a MySQL host, in gigabytes.
        :param str disk_type_id: Type of the storage of MySQL hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a MySQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of MySQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMysqlClusterRestore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupId":
            suggest = "backup_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterRestore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterRestore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterRestore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_id: str,
                 time: Optional[str] = None):
        """
        :param str backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of MySQL backups](https://cloud.yandex.com/docs/managed-mysql/operations/cluster-backups).
        :param str time: Timestamp of the moment to which the MySQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of MySQL backups](https://cloud.yandex.com/docs/managed-mysql/operations/cluster-backups).
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        """
        Timestamp of the moment to which the MySQL cluster should be restored. (Format: "2006-01-02T15:04:05" - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class MdbMysqlClusterUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationPlugin":
            suggest = "authentication_plugin"
        elif key == "connectionLimits":
            suggest = "connection_limits"
        elif key == "globalPermissions":
            suggest = "global_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 password: str,
                 authentication_plugin: Optional[str] = None,
                 connection_limits: Optional['outputs.MdbMysqlClusterUserConnectionLimits'] = None,
                 global_permissions: Optional[Sequence[str]] = None,
                 permissions: Optional[Sequence['outputs.MdbMysqlClusterUserPermission']] = None):
        """
        :param str name: Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        :param str password: The password of the user.
        :param str authentication_plugin: Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`)
        :param 'MdbMysqlClusterUserConnectionLimitsArgs' connection_limits: User's connection limits. The structure is documented below.
               If the attribute is not specified there will be no changes.
        :param Sequence[str] global_permissions: List user's global permissions     
               Allowed permissions:  `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS` for clear list use empty list.
               If the attribute is not specified there will be no changes.
        :param Sequence['MdbMysqlClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if authentication_plugin is not None:
            pulumi.set(__self__, "authentication_plugin", authentication_plugin)
        if connection_limits is not None:
            pulumi.set(__self__, "connection_limits", connection_limits)
        if global_permissions is not None:
            pulumi.set(__self__, "global_permissions", global_permissions)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="authenticationPlugin")
    def authentication_plugin(self) -> Optional[str]:
        """
        Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`)
        """
        return pulumi.get(self, "authentication_plugin")

    @property
    @pulumi.getter(name="connectionLimits")
    def connection_limits(self) -> Optional['outputs.MdbMysqlClusterUserConnectionLimits']:
        """
        User's connection limits. The structure is documented below.
        If the attribute is not specified there will be no changes.
        """
        return pulumi.get(self, "connection_limits")

    @property
    @pulumi.getter(name="globalPermissions")
    def global_permissions(self) -> Optional[Sequence[str]]:
        """
        List user's global permissions     
        Allowed permissions:  `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS` for clear list use empty list.
        If the attribute is not specified there will be no changes.
        """
        return pulumi.get(self, "global_permissions")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbMysqlClusterUserPermission']]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbMysqlClusterUserConnectionLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnectionsPerHour":
            suggest = "max_connections_per_hour"
        elif key == "maxQuestionsPerHour":
            suggest = "max_questions_per_hour"
        elif key == "maxUpdatesPerHour":
            suggest = "max_updates_per_hour"
        elif key == "maxUserConnections":
            suggest = "max_user_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterUserConnectionLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterUserConnectionLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterUserConnectionLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connections_per_hour: Optional[int] = None,
                 max_questions_per_hour: Optional[int] = None,
                 max_updates_per_hour: Optional[int] = None,
                 max_user_connections: Optional[int] = None):
        """
        :param int max_connections_per_hour: Max connections per hour.
        :param int max_questions_per_hour: Max questions per hour.
        :param int max_updates_per_hour: Max updates per hour.
        :param int max_user_connections: Max user connections.
        """
        if max_connections_per_hour is not None:
            pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        if max_questions_per_hour is not None:
            pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        if max_updates_per_hour is not None:
            pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        if max_user_connections is not None:
            pulumi.set(__self__, "max_user_connections", max_user_connections)

    @property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> Optional[int]:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> Optional[int]:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> Optional[int]:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> Optional[int]:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")


@pulumi.output_type
class MdbMysqlClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        :param Sequence[str] roles: List user's roles in the database.
               Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`,
               `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        List user's roles in the database.
        Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`,
        `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class MdbRedisClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxmemoryPolicy":
            suggest = "maxmemory_policy"
        elif key == "notifyKeyspaceEvents":
            suggest = "notify_keyspace_events"
        elif key == "slowlogLogSlowerThan":
            suggest = "slowlog_log_slower_than"
        elif key == "slowlogMaxLen":
            suggest = "slowlog_max_len"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: str,
                 version: str,
                 databases: Optional[int] = None,
                 maxmemory_policy: Optional[str] = None,
                 notify_keyspace_events: Optional[str] = None,
                 slowlog_log_slower_than: Optional[int] = None,
                 slowlog_max_len: Optional[int] = None,
                 timeout: Optional[int] = None):
        """
        :param str password: Password for the Redis cluster.
        :param str version: Version of Redis (5.0, 6.0 or 6.2).
        :param int databases: Number of databases (changing requires redis-server restart).
        :param str maxmemory_policy: Redis key eviction policy for a dataset that reaches maximum memory.
               Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        :param str notify_keyspace_events: Select the events that Redis will notify among a set of classes.
        :param int slowlog_log_slower_than: Log slow queries below this number in microseconds.
        :param int slowlog_max_len: Slow queries log length.
        :param int timeout: Close the connection after a client is idle for N seconds.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "version", version)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if maxmemory_policy is not None:
            pulumi.set(__self__, "maxmemory_policy", maxmemory_policy)
        if notify_keyspace_events is not None:
            pulumi.set(__self__, "notify_keyspace_events", notify_keyspace_events)
        if slowlog_log_slower_than is not None:
            pulumi.set(__self__, "slowlog_log_slower_than", slowlog_log_slower_than)
        if slowlog_max_len is not None:
            pulumi.set(__self__, "slowlog_max_len", slowlog_max_len)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for the Redis cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of Redis (5.0, 6.0 or 6.2).
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def databases(self) -> Optional[int]:
        """
        Number of databases (changing requires redis-server restart).
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="maxmemoryPolicy")
    def maxmemory_policy(self) -> Optional[str]:
        """
        Redis key eviction policy for a dataset that reaches maximum memory.
        Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        """
        return pulumi.get(self, "maxmemory_policy")

    @property
    @pulumi.getter(name="notifyKeyspaceEvents")
    def notify_keyspace_events(self) -> Optional[str]:
        """
        Select the events that Redis will notify among a set of classes.
        """
        return pulumi.get(self, "notify_keyspace_events")

    @property
    @pulumi.getter(name="slowlogLogSlowerThan")
    def slowlog_log_slower_than(self) -> Optional[int]:
        """
        Log slow queries below this number in microseconds.
        """
        return pulumi.get(self, "slowlog_log_slower_than")

    @property
    @pulumi.getter(name="slowlogMaxLen")
    def slowlog_max_len(self) -> Optional[int]:
        """
        Slow queries log length.
        """
        return pulumi.get(self, "slowlog_max_len")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Close the connection after a client is idle for N seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class MdbRedisClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shardName":
            suggest = "shard_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: str,
                 fqdn: Optional[str] = None,
                 shard_name: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str zone: The availability zone where the Redis host will be created.
               For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        :param str fqdn: The fully qualified domain name of the host.
        :param str shard_name: The name of the shard to which the host belongs.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must
               be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the Redis host will be created.
        For more information see [the official documentation](https://cloud.yandex.com/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[str]:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must
        be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbRedisClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: str,
                 day: Optional[str] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbRedisClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"
        elif key == "diskTypeId":
            suggest = "disk_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 resource_preset_id: str,
                 disk_type_id: Optional[str] = None):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of Redis hosts - environment default is used if missing.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[str]:
        """
        Type of the storage of Redis hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")


@pulumi.output_type
class MdbSqlServerClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbSqlServerClusterDatabase(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbSqlServerClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbSqlServerClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbSqlServerClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbSqlServerClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: str,
                 assign_public_ip: Optional[bool] = None,
                 fqdn: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str zone: The availability zone where the SQLServer host will be created.
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        :param str fqdn: The fully qualified domain name of the host.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the SQLServer host will be created.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbSqlServerClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbSqlServerClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbSqlServerClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbSqlServerClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a SQLServer host, in gigabytes.
        :param str disk_type_id: Type of the storage of SQLServer hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a SQLServer host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of SQLServer hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbSqlServerClusterUser(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permissions: Optional[Sequence['outputs.MdbSqlServerClusterUserPermission']] = None):
        """
        :param str name: The name of the database.
        :param str password: The password of the user.
        :param Sequence['MdbSqlServerClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbSqlServerClusterUserPermission']]:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbSqlServerClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbSqlServerClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbSqlServerClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbSqlServerClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        :param Sequence[str] roles: List user's roles in the database.
               Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        List user's roles in the database.
        Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class OrganizationmanagerSamlFederationSecuritySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedAssertions":
            suggest = "encrypted_assertions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationmanagerSamlFederationSecuritySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationmanagerSamlFederationSecuritySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationmanagerSamlFederationSecuritySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted_assertions: bool):
        """
        :param bool encrypted_assertions: Enable encrypted assertions.
        """
        pulumi.set(__self__, "encrypted_assertions", encrypted_assertions)

    @property
    @pulumi.getter(name="encryptedAssertions")
    def encrypted_assertions(self) -> bool:
        """
        Enable encrypted assertions.
        """
        return pulumi.get(self, "encrypted_assertions")


@pulumi.output_type
class ServerlessContainerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workDir":
            suggest = "work_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 digest: Optional[str] = None,
                 environment: Optional[Mapping[str, str]] = None,
                 work_dir: Optional[str] = None):
        """
        :param str url: Invoke URL for the Yandex Cloud Serverless Container
        """
        pulumi.set(__self__, "url", url)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if work_dir is not None:
            pulumi.set(__self__, "work_dir", work_dir)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Invoke URL for the Yandex Cloud Serverless Container
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="workDir")
    def work_dir(self) -> Optional[str]:
        return pulumi.get(self, "work_dir")


@pulumi.output_type
class StorageBucketCorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketCorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketCorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketCorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str],
                 allowed_headers: Optional[Sequence[str]] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age_seconds: Optional[int] = None):
        """
        :param Sequence[str] allowed_methods: Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        :param Sequence[str] allowed_origins: Specifies which origins are allowed.
        :param Sequence[str] allowed_headers: Specifies which headers are allowed.
        :param Sequence[str] expose_headers: Specifies expose header in the response.
        :param int max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        """
        Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies expose header in the response.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[int]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class StorageBucketGrant(dict):
    def __init__(__self__, *,
                 permissions: Sequence[str],
                 type: str,
                 id: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class StorageBucketLifecycleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortIncompleteMultipartUploadDays":
            suggest = "abort_incomplete_multipart_upload_days"
        elif key == "noncurrentVersionExpiration":
            suggest = "noncurrent_version_expiration"
        elif key == "noncurrentVersionTransitions":
            suggest = "noncurrent_version_transitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 abort_incomplete_multipart_upload_days: Optional[int] = None,
                 expiration: Optional['outputs.StorageBucketLifecycleRuleExpiration'] = None,
                 id: Optional[str] = None,
                 noncurrent_version_expiration: Optional['outputs.StorageBucketLifecycleRuleNoncurrentVersionExpiration'] = None,
                 noncurrent_version_transitions: Optional[Sequence['outputs.StorageBucketLifecycleRuleNoncurrentVersionTransition']] = None,
                 prefix: Optional[str] = None,
                 transitions: Optional[Sequence['outputs.StorageBucketLifecycleRuleTransition']] = None):
        """
        :param bool enabled: Specifies lifecycle rule status.
        :param int abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        :param 'StorageBucketLifecycleRuleExpirationArgs' expiration: Specifies a period in the object's expire (documented below).
        :param str id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param 'StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs' noncurrent_version_expiration: Specifies when noncurrent object versions expire (documented below).
        :param Sequence['StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs'] noncurrent_version_transitions: Specifies when noncurrent object versions transitions (documented below).
        :param str prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param Sequence['StorageBucketLifecycleRuleTransitionArgs'] transitions: Specifies a period in the object's transitions (documented below).
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[int]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @property
    @pulumi.getter
    def expiration(self) -> Optional['outputs.StorageBucketLifecycleRuleExpiration']:
        """
        Specifies a period in the object's expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional['outputs.StorageBucketLifecycleRuleNoncurrentVersionExpiration']:
        """
        Specifies when noncurrent object versions expire (documented below).
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[Sequence['outputs.StorageBucketLifecycleRuleNoncurrentVersionTransition']]:
        """
        Specifies when noncurrent object versions transitions (documented below).
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def transitions(self) -> Optional[Sequence['outputs.StorageBucketLifecycleRuleTransition']]:
        """
        Specifies a period in the object's transitions (documented below).
        """
        return pulumi.get(self, "transitions")


@pulumi.output_type
class StorageBucketLifecycleRuleExpiration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiredObjectDeleteMarker":
            suggest = "expired_object_delete_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleExpiration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleExpiration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleExpiration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date: Optional[str] = None,
                 days: Optional[int] = None,
                 expired_object_delete_marker: Optional[bool] = None):
        """
        :param str date: Specifies the date after which you want the corresponding action to take effect.
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect.
        :param bool expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Object Storage to delete expired object delete markers.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[bool]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Object Storage to delete expired object delete markers.
        """
        return pulumi.get(self, "expired_object_delete_marker")


@pulumi.output_type
class StorageBucketLifecycleRuleNoncurrentVersionExpiration(dict):
    def __init__(__self__, *,
                 days: Optional[int] = None):
        """
        :param int days: Specifies the number of days noncurrent object versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Specifies the number of days noncurrent object versions expire.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class StorageBucketLifecycleRuleNoncurrentVersionTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleNoncurrentVersionTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleNoncurrentVersionTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleNoncurrentVersionTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_class: str,
                 days: Optional[int] = None):
        """
        :param str storage_class: Specifies the storage class to which you want the noncurrent object versions to transition. Can only be `COLD` or `STANDARD_IA`.
        :param int days: Specifies the number of days noncurrent object versions transition.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        Specifies the storage class to which you want the noncurrent object versions to transition. Can only be `COLD` or `STANDARD_IA`.
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class StorageBucketLifecycleRuleTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_class: str,
                 date: Optional[str] = None,
                 days: Optional[int] = None):
        """
        :param str storage_class: Specifies the storage class to which you want the object to transition. Can only be `COLD` or `STANDARD_IA`.
        :param str date: Specifies the date after which you want the corresponding action to take effect.
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        Specifies the storage class to which you want the object to transition. Can only be `COLD` or `STANDARD_IA`.
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class StorageBucketLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetBucket":
            suggest = "target_bucket"
        elif key == "targetPrefix":
            suggest = "target_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_bucket: str,
                 target_prefix: Optional[str] = None):
        """
        :param str target_bucket: The name of the bucket that will receive the log objects.
        :param str target_prefix: To specify a key prefix for log objects.
        """
        pulumi.set(__self__, "target_bucket", target_bucket)
        if target_prefix is not None:
            pulumi.set(__self__, "target_prefix", target_prefix)

    @property
    @pulumi.getter(name="targetBucket")
    def target_bucket(self) -> str:
        """
        The name of the bucket that will receive the log objects.
        """
        return pulumi.get(self, "target_bucket")

    @property
    @pulumi.getter(name="targetPrefix")
    def target_prefix(self) -> Optional[str]:
        """
        To specify a key prefix for log objects.
        """
        return pulumi.get(self, "target_prefix")


@pulumi.output_type
class StorageBucketServerSideEncryptionConfiguration(dict):
    def __init__(__self__, *,
                 rule: 'outputs.StorageBucketServerSideEncryptionConfigurationRule'):
        """
        :param 'StorageBucketServerSideEncryptionConfigurationRuleArgs' rule: A single object for server-side encryption by default configuration. (documented below)
        """
        pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter
    def rule(self) -> 'outputs.StorageBucketServerSideEncryptionConfigurationRule':
        """
        A single object for server-side encryption by default configuration. (documented below)
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class StorageBucketServerSideEncryptionConfigurationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyServerSideEncryptionByDefault":
            suggest = "apply_server_side_encryption_by_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketServerSideEncryptionConfigurationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketServerSideEncryptionConfigurationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketServerSideEncryptionConfigurationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_server_side_encryption_by_default: 'outputs.StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault'):
        """
        :param 'StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs' apply_server_side_encryption_by_default: A single object for setting server-side encryption by default. (documented below)
        """
        pulumi.set(__self__, "apply_server_side_encryption_by_default", apply_server_side_encryption_by_default)

    @property
    @pulumi.getter(name="applyServerSideEncryptionByDefault")
    def apply_server_side_encryption_by_default(self) -> 'outputs.StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault':
        """
        A single object for setting server-side encryption by default. (documented below)
        """
        return pulumi.get(self, "apply_server_side_encryption_by_default")


@pulumi.output_type
class StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsMasterKeyId":
            suggest = "kms_master_key_id"
        elif key == "sseAlgorithm":
            suggest = "sse_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_master_key_id: str,
                 sse_algorithm: str):
        """
        :param str kms_master_key_id: The KMS master key ID used for the SSE-KMS encryption.
        :param str sse_algorithm: The server-side encryption algorithm to use. Single valid value is `aws:kms`
        """
        pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> str:
        """
        The KMS master key ID used for the SSE-KMS encryption.
        """
        return pulumi.get(self, "kms_master_key_id")

    @property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> str:
        """
        The server-side encryption algorithm to use. Single valid value is `aws:kms`
        """
        return pulumi.get(self, "sse_algorithm")


@pulumi.output_type
class StorageBucketVersioning(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class StorageBucketWebsite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDocument":
            suggest = "error_document"
        elif key == "indexDocument":
            suggest = "index_document"
        elif key == "redirectAllRequestsTo":
            suggest = "redirect_all_requests_to"
        elif key == "routingRules":
            suggest = "routing_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketWebsite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketWebsite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketWebsite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_document: Optional[str] = None,
                 index_document: Optional[str] = None,
                 redirect_all_requests_to: Optional[str] = None,
                 routing_rules: Optional[str] = None):
        """
        :param str error_document: An absolute path to the document to return in case of a 4XX error.
        :param str index_document: Storage returns this index document when requests are made to the root domain or any of the subfolders.
        :param str redirect_all_requests_to: A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        :param str routing_rules: A json array containing [routing rules](https://cloud.yandex.com/docs/storage/s3/api-ref/hosting/upload#request-scheme) describing redirect behavior and when redirects are applied.
        """
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if redirect_all_requests_to is not None:
            pulumi.set(__self__, "redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[str]:
        """
        An absolute path to the document to return in case of a 4XX error.
        """
        return pulumi.get(self, "error_document")

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[str]:
        """
        Storage returns this index document when requests are made to the root domain or any of the subfolders.
        """
        return pulumi.get(self, "index_document")

    @property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional[str]:
        """
        A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "redirect_all_requests_to")

    @property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[str]:
        """
        A json array containing [routing rules](https://cloud.yandex.com/docs/storage/s3/api-ref/hosting/upload#request-scheme) describing redirect behavior and when redirects are applied.
        """
        return pulumi.get(self, "routing_rules")


@pulumi.output_type
class VpcAddressExternalIpv4Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ddosProtectionProvider":
            suggest = "ddos_protection_provider"
        elif key == "outgoingSmtpCapability":
            suggest = "outgoing_smtp_capability"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcAddressExternalIpv4Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcAddressExternalIpv4Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcAddressExternalIpv4Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 ddos_protection_provider: Optional[str] = None,
                 outgoing_smtp_capability: Optional[str] = None,
                 zone_id: Optional[str] = None):
        """
        :param str address: - Desired IP.
        :param str ddos_protection_provider: Enable DDOS protection. Possible values are: "qrator"
        :param str outgoing_smtp_capability: Wanted outgoing smtp capability.
        :param str zone_id: - Zone for allocating address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ddos_protection_provider is not None:
            pulumi.set(__self__, "ddos_protection_provider", ddos_protection_provider)
        if outgoing_smtp_capability is not None:
            pulumi.set(__self__, "outgoing_smtp_capability", outgoing_smtp_capability)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        - Desired IP.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="ddosProtectionProvider")
    def ddos_protection_provider(self) -> Optional[str]:
        """
        Enable DDOS protection. Possible values are: "qrator"
        """
        return pulumi.get(self, "ddos_protection_provider")

    @property
    @pulumi.getter(name="outgoingSmtpCapability")
    def outgoing_smtp_capability(self) -> Optional[str]:
        """
        Wanted outgoing smtp capability.
        """
        return pulumi.get(self, "outgoing_smtp_capability")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        - Zone for allocating address.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class VpcDefaultSecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcDefaultSecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcDefaultSecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcDefaultSecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 description: Optional[str] = None,
                 from_port: Optional[int] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 port: Optional[int] = None,
                 predefined_target: Optional[str] = None,
                 security_group_id: Optional[str] = None,
                 to_port: Optional[int] = None,
                 v4_cidr_blocks: Optional[Sequence[str]] = None,
                 v6_cidr_blocks: Optional[Sequence[str]] = None):
        """
        :param str description: Description of the security group.
        :param str id: Id of the security group.
        :param Mapping[str, str] labels: Labels to assign to this security group.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the security group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[str]:
        return pulumi.get(self, "predefined_target")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v4_cidr_blocks")

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcDefaultSecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcDefaultSecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcDefaultSecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcDefaultSecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 description: Optional[str] = None,
                 from_port: Optional[int] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 port: Optional[int] = None,
                 predefined_target: Optional[str] = None,
                 security_group_id: Optional[str] = None,
                 to_port: Optional[int] = None,
                 v4_cidr_blocks: Optional[Sequence[str]] = None,
                 v6_cidr_blocks: Optional[Sequence[str]] = None):
        """
        :param str description: Description of the security group.
        :param str id: Id of the security group.
        :param Mapping[str, str] labels: Labels to assign to this security group.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the security group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[str]:
        return pulumi.get(self, "predefined_target")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v4_cidr_blocks")

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcRouteTableStaticRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPrefix":
            suggest = "destination_prefix"
        elif key == "nextHopAddress":
            suggest = "next_hop_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcRouteTableStaticRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcRouteTableStaticRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcRouteTableStaticRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_prefix: Optional[str] = None,
                 next_hop_address: Optional[str] = None):
        """
        :param str destination_prefix: Route prefix in CIDR notation.
        :param str next_hop_address: Address of the next hop.
        """
        if destination_prefix is not None:
            pulumi.set(__self__, "destination_prefix", destination_prefix)
        if next_hop_address is not None:
            pulumi.set(__self__, "next_hop_address", next_hop_address)

    @property
    @pulumi.getter(name="destinationPrefix")
    def destination_prefix(self) -> Optional[str]:
        """
        Route prefix in CIDR notation.
        """
        return pulumi.get(self, "destination_prefix")

    @property
    @pulumi.getter(name="nextHopAddress")
    def next_hop_address(self) -> Optional[str]:
        """
        Address of the next hop.
        """
        return pulumi.get(self, "next_hop_address")


@pulumi.output_type
class VpcSecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcSecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcSecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcSecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 description: Optional[str] = None,
                 from_port: Optional[int] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 port: Optional[int] = None,
                 predefined_target: Optional[str] = None,
                 security_group_id: Optional[str] = None,
                 to_port: Optional[int] = None,
                 v4_cidr_blocks: Optional[Sequence[str]] = None,
                 v6_cidr_blocks: Optional[Sequence[str]] = None):
        """
        :param str description: Description of the security group.
        :param str id: Id of the rule.
        :param Mapping[str, str] labels: Labels to assign to this security group.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[str]:
        return pulumi.get(self, "predefined_target")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v4_cidr_blocks")

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcSecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcSecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcSecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcSecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 description: Optional[str] = None,
                 from_port: Optional[int] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 port: Optional[int] = None,
                 predefined_target: Optional[str] = None,
                 security_group_id: Optional[str] = None,
                 to_port: Optional[int] = None,
                 v4_cidr_blocks: Optional[Sequence[str]] = None,
                 v6_cidr_blocks: Optional[Sequence[str]] = None):
        """
        :param str description: Description of the security group.
        :param str id: Id of the rule.
        :param Mapping[str, str] labels: Labels to assign to this security group.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the security group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to assign to this security group.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[str]:
        return pulumi.get(self, "predefined_target")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v4_cidr_blocks")

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcSubnetDhcpOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "domainNameServers":
            suggest = "domain_name_servers"
        elif key == "ntpServers":
            suggest = "ntp_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcSubnetDhcpOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcSubnetDhcpOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcSubnetDhcpOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: Optional[str] = None,
                 domain_name_servers: Optional[Sequence[str]] = None,
                 ntp_servers: Optional[Sequence[str]] = None):
        """
        :param str domain_name: Domain name.
        :param Sequence[str] domain_name_servers: Domain name server IP addresses.
        :param Sequence[str] ntp_servers: NTP server IP addresses.
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        Domain name.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[Sequence[str]]:
        """
        Domain name server IP addresses.
        """
        return pulumi.get(self, "domain_name_servers")

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[Sequence[str]]:
        """
        NTP server IP addresses.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class YdbDatabaseDedicatedLocation(dict):
    def __init__(__self__, *,
                 region: Optional['outputs.YdbDatabaseDedicatedLocationRegion'] = None):
        """
        :param 'YdbDatabaseDedicatedLocationRegionArgs' region: Region for the Yandex Database cluster.
               The structure is documented below.
        """
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def region(self) -> Optional['outputs.YdbDatabaseDedicatedLocationRegion']:
        """
        Region for the Yandex Database cluster.
        The structure is documented below.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class YdbDatabaseDedicatedLocationRegion(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Region ID for the Yandex Database cluster.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Region ID for the Yandex Database cluster.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class YdbDatabaseDedicatedScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedScale":
            suggest = "fixed_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbDatabaseDedicatedScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbDatabaseDedicatedScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbDatabaseDedicatedScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_scale: 'outputs.YdbDatabaseDedicatedScalePolicyFixedScale'):
        """
        :param 'YdbDatabaseDedicatedScalePolicyFixedScaleArgs' fixed_scale: Fixed scaling policy for the Yandex Database cluster.
               The structure is documented below.
        """
        pulumi.set(__self__, "fixed_scale", fixed_scale)

    @property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> 'outputs.YdbDatabaseDedicatedScalePolicyFixedScale':
        """
        Fixed scaling policy for the Yandex Database cluster.
        The structure is documented below.
        """
        return pulumi.get(self, "fixed_scale")


@pulumi.output_type
class YdbDatabaseDedicatedScalePolicyFixedScale(dict):
    def __init__(__self__, *,
                 size: int):
        """
        :param int size: Number of instances for the Yandex Database cluster.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Number of instances for the Yandex Database cluster.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class YdbDatabaseDedicatedStorageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupCount":
            suggest = "group_count"
        elif key == "storageTypeId":
            suggest = "storage_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbDatabaseDedicatedStorageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbDatabaseDedicatedStorageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbDatabaseDedicatedStorageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_count: int,
                 storage_type_id: str):
        """
        :param int group_count: Amount of storage groups of selected type for the Yandex Database cluster.
        :param str storage_type_id: Storage type ID for the Yandex Database cluster.
               Available presets can be obtained via `yc ydb storage-type list` command.
        """
        pulumi.set(__self__, "group_count", group_count)
        pulumi.set(__self__, "storage_type_id", storage_type_id)

    @property
    @pulumi.getter(name="groupCount")
    def group_count(self) -> int:
        """
        Amount of storage groups of selected type for the Yandex Database cluster.
        """
        return pulumi.get(self, "group_count")

    @property
    @pulumi.getter(name="storageTypeId")
    def storage_type_id(self) -> str:
        """
        Storage type ID for the Yandex Database cluster.
        Available presets can be obtained via `yc ydb storage-type list` command.
        """
        return pulumi.get(self, "storage_type_id")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendResult(dict):
    def __init__(__self__, *,
                 healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckResult',
                 load_balancing_config: 'outputs.GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult',
                 name: str,
                 port: int,
                 target_group_ids: Sequence[str],
                 tls: 'outputs.GetAlbBackendGroupGrpcBackendTlsResult',
                 weight: int):
        """
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param 'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param str name: - Name of the Backend Group.
        :param int port: Port for incoming traffic.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupGrpcBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckResult':
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'outputs.GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult':
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Name of the Backend Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.GetAlbBackendGroupGrpcBackendTlsResult':
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckResult(dict):
    def __init__(__self__, *,
                 grpc_healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult',
                 healthcheck_port: int,
                 healthy_threshold: int,
                 http_healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult',
                 interval: str,
                 interval_jitter_percent: float,
                 stream_healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult',
                 timeout: str,
                 unhealthy_threshold: int):
        """
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str interval: Interval between health checks.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str timeout: Time to wait for a health check response.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult':
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult':
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult':
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult(dict):
    def __init__(__self__, *,
                 service_name: str):
        """
        :param str service_name: Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult(dict):
    def __init__(__self__, *,
                 host: str,
                 http2: bool,
                 path: str):
        """
        :param str host: Optional "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        :param str path: HTTP path.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Optional "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult(dict):
    def __init__(__self__, *,
                 receive: str,
                 send: str):
        """
        :param str receive: Optional text to search in reply.
        :param str send: Optional message to send. If empty, it's a connect-only health check.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> str:
        """
        Optional text to search in reply.
        """
        return pulumi.get(self, "receive")

    @property
    @pulumi.getter
    def send(self) -> str:
        """
        Optional message to send. If empty, it's a connect-only health check.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult(dict):
    def __init__(__self__, *,
                 locality_aware_routing_percent: int,
                 panic_threshold: int,
                 strict_locality: bool):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendTlsResult(dict):
    def __init__(__self__, *,
                 sni: str,
                 validation_context: 'outputs.GetAlbBackendGroupGrpcBackendTlsValidationContextResult'):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - PEM-encoded trusted CA certificate chain.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'outputs.GetAlbBackendGroupGrpcBackendTlsValidationContextResult':
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendTlsValidationContextResult(dict):
    def __init__(__self__, *,
                 trusted_ca_bytes: str,
                 trusted_ca_id: str):
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> str:
        return pulumi.get(self, "trusted_ca_bytes")

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> str:
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendResult(dict):
    def __init__(__self__, *,
                 healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckResult',
                 http2: bool,
                 load_balancing_config: 'outputs.GetAlbBackendGroupHttpBackendLoadBalancingConfigResult',
                 name: str,
                 port: int,
                 target_group_ids: Sequence[str],
                 tls: 'outputs.GetAlbBackendGroupHttpBackendTlsResult',
                 weight: int):
        """
        :param 'GetAlbBackendGroupHttpBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param bool http2: If set, health checks will use HTTP2.
        :param 'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param str name: - Name of the Backend Group.
        :param int port: Port for incoming traffic.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupHttpBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckResult':
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'outputs.GetAlbBackendGroupHttpBackendLoadBalancingConfigResult':
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Name of the Backend Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.GetAlbBackendGroupHttpBackendTlsResult':
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckResult(dict):
    def __init__(__self__, *,
                 grpc_healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult',
                 healthcheck_port: int,
                 healthy_threshold: int,
                 http_healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult',
                 interval: str,
                 interval_jitter_percent: float,
                 stream_healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult',
                 timeout: str,
                 unhealthy_threshold: int):
        """
        :param 'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str interval: Interval between health checks.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str timeout: Time to wait for a health check response.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult':
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult':
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult':
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult(dict):
    def __init__(__self__, *,
                 service_name: str):
        """
        :param str service_name: Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult(dict):
    def __init__(__self__, *,
                 host: str,
                 http2: bool,
                 path: str):
        """
        :param str host: Optional "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        :param str path: HTTP path.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Optional "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult(dict):
    def __init__(__self__, *,
                 receive: str,
                 send: str):
        """
        :param str receive: Optional text to search in reply.
        :param str send: Optional message to send. If empty, it's a connect-only health check.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> str:
        """
        Optional text to search in reply.
        """
        return pulumi.get(self, "receive")

    @property
    @pulumi.getter
    def send(self) -> str:
        """
        Optional message to send. If empty, it's a connect-only health check.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendLoadBalancingConfigResult(dict):
    def __init__(__self__, *,
                 locality_aware_routing_percent: int,
                 panic_threshold: int,
                 strict_locality: bool):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendTlsResult(dict):
    def __init__(__self__, *,
                 sni: str,
                 validation_context: 'outputs.GetAlbBackendGroupHttpBackendTlsValidationContextResult'):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - PEM-encoded trusted CA certificate chain.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'outputs.GetAlbBackendGroupHttpBackendTlsValidationContextResult':
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendTlsValidationContextResult(dict):
    def __init__(__self__, *,
                 trusted_ca_bytes: str,
                 trusted_ca_id: str):
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> str:
        return pulumi.get(self, "trusted_ca_bytes")

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> str:
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendResult(dict):
    def __init__(__self__, *,
                 healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckResult',
                 load_balancing_config: 'outputs.GetAlbBackendGroupStreamBackendLoadBalancingConfigResult',
                 name: str,
                 port: int,
                 target_group_ids: Sequence[str],
                 tls: 'outputs.GetAlbBackendGroupStreamBackendTlsResult',
                 weight: int):
        """
        :param 'GetAlbBackendGroupStreamBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend. Structure is documented below.
        :param 'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend. Structure is documented below.
        :param str name: - Name of the Backend Group.
        :param int port: Port for incoming traffic.
        :param Sequence[str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupStreamBackendTlsArgs' tls: Tls specification that will be used by this backend. Structure is documented below.
        :param int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckResult':
        """
        Healthcheck specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'outputs.GetAlbBackendGroupStreamBackendLoadBalancingConfigResult':
        """
        Load Balancing Config specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "load_balancing_config")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Name of the Backend Group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.GetAlbBackendGroupStreamBackendTlsResult':
        """
        Tls specification that will be used by this backend. Structure is documented below.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckResult(dict):
    def __init__(__self__, *,
                 grpc_healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult',
                 healthcheck_port: int,
                 healthy_threshold: int,
                 http_healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult',
                 interval: str,
                 interval_jitter_percent: float,
                 stream_healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult',
                 timeout: str,
                 unhealthy_threshold: int):
        """
        :param 'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param int healthcheck_port: Optional alternative port for health checking.
        :param int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str interval: Interval between health checks.
        :param float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        :param str timeout: Time to wait for a health check response.
        :param int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult':
        """
        Grpc Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult':
        """
        Http Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "http_healthcheck")

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval_ms * interval_jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult':
        """
        Stream Healthcheck specification that will be used by this healthcheck. Structure is documented below.
        """
        return pulumi.get(self, "stream_healthcheck")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult(dict):
    def __init__(__self__, *,
                 service_name: str):
        """
        :param str service_name: Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Optional service name for grpc.health.v1.HealthCheckRequest message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult(dict):
    def __init__(__self__, *,
                 host: str,
                 http2: bool,
                 path: str):
        """
        :param str host: Optional "Host" HTTP header value.
        :param bool http2: If set, health checks will use HTTP2.
        :param str path: HTTP path.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Optional "Host" HTTP header value.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult(dict):
    def __init__(__self__, *,
                 receive: str,
                 send: str):
        """
        :param str receive: Optional text to search in reply.
        :param str send: Optional message to send. If empty, it's a connect-only health check.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def receive(self) -> str:
        """
        Optional text to search in reply.
        """
        return pulumi.get(self, "receive")

    @property
    @pulumi.getter
    def send(self) -> str:
        """
        Optional message to send. If empty, it's a connect-only health check.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendLoadBalancingConfigResult(dict):
    def __init__(__self__, *,
                 locality_aware_routing_percent: int,
                 panic_threshold: int,
                 strict_locality: bool):
        """
        :param int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        :param bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading  when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendTlsResult(dict):
    def __init__(__self__, *,
                 sni: str,
                 validation_context: 'outputs.GetAlbBackendGroupStreamBackendTlsValidationContextResult'):
        """
        :param str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
               * `validation_context.0.trusted_ca_id` - Trusted CA certificate ID in the Certificate Manager.
               * `validation_context.0.trusted_ca_bytes` - PEM-encoded trusted CA certificate chain.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        * `validation_context.0.trusted_ca_id` - Trusted CA certificate ID in the Certificate Manager.
        * `validation_context.0.trusted_ca_bytes` - PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'outputs.GetAlbBackendGroupStreamBackendTlsValidationContextResult':
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendTlsValidationContextResult(dict):
    def __init__(__self__, *,
                 trusted_ca_bytes: str,
                 trusted_ca_id: str):
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> str:
        return pulumi.get(self, "trusted_ca_bytes")

    @property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> str:
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class GetAlbLoadBalancerAllocationPolicyResult(dict):
    def __init__(__self__, *,
                 locations: Sequence['outputs.GetAlbLoadBalancerAllocationPolicyLocationResult']):
        pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetAlbLoadBalancerAllocationPolicyLocationResult']:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetAlbLoadBalancerAllocationPolicyLocationResult(dict):
    def __init__(__self__, *,
                 disable_traffic: bool,
                 subnet_id: str,
                 zone_id: str):
        pulumi.set(__self__, "disable_traffic", disable_traffic)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="disableTraffic")
    def disable_traffic(self) -> bool:
        return pulumi.get(self, "disable_traffic")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetAlbLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 endpoints: Sequence['outputs.GetAlbLoadBalancerListenerEndpointResult'],
                 name: str,
                 https: Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpResult']] = None,
                 stream: Optional['outputs.GetAlbLoadBalancerListenerStreamResult'] = None,
                 tls: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlResult']] = None):
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "name", name)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def https(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpResult']]:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def stream(self) -> Optional['outputs.GetAlbLoadBalancerListenerStreamResult']:
        return pulumi.get(self, "stream")

    @property
    @pulumi.getter
    def tls(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlResult']]:
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointResult(dict):
    def __init__(__self__, *,
                 addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressResult'],
                 ports: Sequence[int]):
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressResult']:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressResult(dict):
    def __init__(__self__, *,
                 external_ipv4_addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult'],
                 external_ipv6_addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult'],
                 internal_ipv4_addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult']):
        pulumi.set(__self__, "external_ipv4_addresses", external_ipv4_addresses)
        pulumi.set(__self__, "external_ipv6_addresses", external_ipv6_addresses)
        pulumi.set(__self__, "internal_ipv4_addresses", internal_ipv4_addresses)

    @property
    @pulumi.getter(name="externalIpv4Addresses")
    def external_ipv4_addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult']:
        return pulumi.get(self, "external_ipv4_addresses")

    @property
    @pulumi.getter(name="externalIpv6Addresses")
    def external_ipv6_addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult']:
        return pulumi.get(self, "external_ipv6_addresses")

    @property
    @pulumi.getter(name="internalIpv4Addresses")
    def internal_ipv4_addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult']:
        return pulumi.get(self, "internal_ipv4_addresses")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult(dict):
    def __init__(__self__, *,
                 address: str):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult(dict):
    def __init__(__self__, *,
                 address: str):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult(dict):
    def __init__(__self__, *,
                 address: str,
                 subnet_id: str):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpResult(dict):
    def __init__(__self__, *,
                 handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerResult']] = None,
                 redirects: Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpRedirectResult']] = None):
        if handlers is not None:
            pulumi.set(__self__, "handlers", handlers)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @property
    @pulumi.getter
    def handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerResult']]:
        return pulumi.get(self, "handlers")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpRedirectResult']]:
        return pulumi.get(self, "redirects")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpHandlerResult(dict):
    def __init__(__self__, *,
                 http2_options: Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult'],
                 http_router_id: str,
                 allow_http10: Optional[bool] = None):
        pulumi.set(__self__, "http2_options", http2_options)
        pulumi.set(__self__, "http_router_id", http_router_id)
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult']:
        return pulumi.get(self, "http2_options")

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> str:
        return pulumi.get(self, "http_router_id")

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[bool]:
        return pulumi.get(self, "allow_http10")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult(dict):
    def __init__(__self__, *,
                 max_concurrent_streams: int):
        pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> int:
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpRedirectResult(dict):
    def __init__(__self__, *,
                 http_to_https: bool):
        pulumi.set(__self__, "http_to_https", http_to_https)

    @property
    @pulumi.getter(name="httpToHttps")
    def http_to_https(self) -> bool:
        return pulumi.get(self, "http_to_https")


@pulumi.output_type
class GetAlbLoadBalancerListenerStreamResult(dict):
    def __init__(__self__, *,
                 handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerStreamHandlerResult']] = None):
        if handlers is not None:
            pulumi.set(__self__, "handlers", handlers)

    @property
    @pulumi.getter
    def handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerStreamHandlerResult']]:
        return pulumi.get(self, "handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerStreamHandlerResult(dict):
    def __init__(__self__, *,
                 backend_group_id: str):
        pulumi.set(__self__, "backend_group_id", backend_group_id)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> str:
        return pulumi.get(self, "backend_group_id")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlResult(dict):
    def __init__(__self__, *,
                 default_handlers: Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerResult'],
                 sni_handlers: Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerResult']):
        pulumi.set(__self__, "default_handlers", default_handlers)
        pulumi.set(__self__, "sni_handlers", sni_handlers)

    @property
    @pulumi.getter(name="defaultHandlers")
    def default_handlers(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerResult']:
        return pulumi.get(self, "default_handlers")

    @property
    @pulumi.getter(name="sniHandlers")
    def sni_handlers(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerResult']:
        return pulumi.get(self, "sni_handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerResult(dict):
    def __init__(__self__, *,
                 certificate_ids: Sequence[str],
                 http_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult']] = None,
                 stream_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult']] = None):
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handlers is not None:
            pulumi.set(__self__, "http_handlers", http_handlers)
        if stream_handlers is not None:
            pulumi.set(__self__, "stream_handlers", stream_handlers)

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[str]:
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter(name="httpHandlers")
    def http_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult']]:
        return pulumi.get(self, "http_handlers")

    @property
    @pulumi.getter(name="streamHandlers")
    def stream_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult']]:
        return pulumi.get(self, "stream_handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult(dict):
    def __init__(__self__, *,
                 http2_options: Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult'],
                 http_router_id: str,
                 allow_http10: Optional[bool] = None):
        pulumi.set(__self__, "http2_options", http2_options)
        pulumi.set(__self__, "http_router_id", http_router_id)
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult']:
        return pulumi.get(self, "http2_options")

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> str:
        return pulumi.get(self, "http_router_id")

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[bool]:
        return pulumi.get(self, "allow_http10")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult(dict):
    def __init__(__self__, *,
                 max_concurrent_streams: int):
        pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> int:
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult(dict):
    def __init__(__self__, *,
                 backend_group_id: str):
        pulumi.set(__self__, "backend_group_id", backend_group_id)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> str:
        return pulumi.get(self, "backend_group_id")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerResult(dict):
    def __init__(__self__, *,
                 handlers: Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerResult'],
                 name: str,
                 server_names: Sequence[str]):
        pulumi.set(__self__, "handlers", handlers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_names", server_names)

    @property
    @pulumi.getter
    def handlers(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerResult']:
        return pulumi.get(self, "handlers")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverNames")
    def server_names(self) -> Sequence[str]:
        return pulumi.get(self, "server_names")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerResult(dict):
    def __init__(__self__, *,
                 certificate_ids: Sequence[str],
                 http_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult']] = None,
                 stream_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult']] = None):
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handlers is not None:
            pulumi.set(__self__, "http_handlers", http_handlers)
        if stream_handlers is not None:
            pulumi.set(__self__, "stream_handlers", stream_handlers)

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[str]:
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter(name="httpHandlers")
    def http_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult']]:
        return pulumi.get(self, "http_handlers")

    @property
    @pulumi.getter(name="streamHandlers")
    def stream_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult']]:
        return pulumi.get(self, "stream_handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult(dict):
    def __init__(__self__, *,
                 http2_options: Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult'],
                 http_router_id: str,
                 allow_http10: Optional[bool] = None):
        pulumi.set(__self__, "http2_options", http2_options)
        pulumi.set(__self__, "http_router_id", http_router_id)
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)

    @property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult']:
        return pulumi.get(self, "http2_options")

    @property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> str:
        return pulumi.get(self, "http_router_id")

    @property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[bool]:
        return pulumi.get(self, "allow_http10")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult(dict):
    def __init__(__self__, *,
                 max_concurrent_streams: int):
        pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> int:
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult(dict):
    def __init__(__self__, *,
                 backend_group_id: str):
        pulumi.set(__self__, "backend_group_id", backend_group_id)

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> str:
        return pulumi.get(self, "backend_group_id")


@pulumi.output_type
class GetAlbTargetGroupTargetResult(dict):
    def __init__(__self__, *,
                 ip_address: str,
                 private_ipv4_address: Optional[bool] = None,
                 subnet_id: Optional[str] = None):
        pulumi.set(__self__, "ip_address", ip_address)
        if private_ipv4_address is not None:
            pulumi.set(__self__, "private_ipv4_address", private_ipv4_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="privateIpv4Address")
    def private_ipv4_address(self) -> Optional[bool]:
        return pulumi.get(self, "private_ipv4_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetAlbVirtualHostModifyRequestHeaderResult(dict):
    def __init__(__self__, *,
                 append: str,
                 name: str,
                 remove: bool,
                 replace: str):
        """
        :param str append: Append string to the header value.
        :param str name: Name of the Virtual Host.
        :param bool remove: If set, remove the header.
        :param str replace: New value for a header. Header values support the following
               [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def append(self) -> str:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Virtual Host.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def remove(self) -> bool:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def replace(self) -> str:
        """
        New value for a header. Header values support the following
        [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class GetAlbVirtualHostModifyResponseHeaderResult(dict):
    def __init__(__self__, *,
                 append: str,
                 name: str,
                 remove: bool,
                 replace: str):
        """
        :param str append: Append string to the header value.
        :param str name: Name of the Virtual Host.
        :param bool remove: If set, remove the header.
        :param str replace: New value for a header. Header values support the following
               [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def append(self) -> str:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Virtual Host.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def remove(self) -> bool:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def replace(self) -> str:
        """
        New value for a header. Header values support the following
        [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class GetAlbVirtualHostRouteResult(dict):
    def __init__(__self__, *,
                 grpc_routes: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteResult'],
                 http_routes: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteResult'],
                 name: str):
        """
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteArgs'] grpc_routes: GRPC route resource. The structure is documented below.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteArgs'] http_routes: HTTP route resource. The structure is documented below.
        :param str name: Name of the Virtual Host.
        """
        pulumi.set(__self__, "grpc_routes", grpc_routes)
        pulumi.set(__self__, "http_routes", http_routes)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="grpcRoutes")
    def grpc_routes(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteResult']:
        """
        GRPC route resource. The structure is documented below.
        """
        return pulumi.get(self, "grpc_routes")

    @property
    @pulumi.getter(name="httpRoutes")
    def http_routes(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteResult']:
        """
        HTTP route resource. The structure is documented below.
        """
        return pulumi.get(self, "http_routes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Virtual Host.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteResult(dict):
    def __init__(__self__, *,
                 grpc_matches: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult'],
                 grpc_route_actions: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult'],
                 grpc_status_response_actions: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcMatchArgs'] grpc_matches: Checks "/" prefix by default. The structure is documented below.
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs'] grpc_route_actions: GRPC route action resource. The structure is documented below.
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs'] grpc_status_response_actions: (Required) GRPC status response action resource. The structure is documented below.
        """
        pulumi.set(__self__, "grpc_matches", grpc_matches)
        pulumi.set(__self__, "grpc_route_actions", grpc_route_actions)
        pulumi.set(__self__, "grpc_status_response_actions", grpc_status_response_actions)

    @property
    @pulumi.getter(name="grpcMatches")
    def grpc_matches(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult']:
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        return pulumi.get(self, "grpc_matches")

    @property
    @pulumi.getter(name="grpcRouteActions")
    def grpc_route_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult']:
        """
        GRPC route action resource. The structure is documented below.
        """
        return pulumi.get(self, "grpc_route_actions")

    @property
    @pulumi.getter(name="grpcStatusResponseActions")
    def grpc_status_response_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult']:
        """
        (Required) GRPC status response action resource. The structure is documented below.
        """
        return pulumi.get(self, "grpc_status_response_actions")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult(dict):
    def __init__(__self__, *,
                 fqmns: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs'] fqmns: If not set, all services/methods are assumed. The structure is documented below.
        """
        pulumi.set(__self__, "fqmns", fqmns)

    @property
    @pulumi.getter
    def fqmns(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult']:
        """
        If not set, all services/methods are assumed. The structure is documented below.
        """
        return pulumi.get(self, "fqmns")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 prefix: str):
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult(dict):
    def __init__(__self__, *,
                 auto_host_rewrite: bool,
                 backend_group_id: str,
                 host_rewrite: str,
                 idle_timeout: str,
                 max_timeout: str):
        """
        :param bool auto_host_rewrite: If set, will automatically rewrite host.
        :param str backend_group_id: Backend group to route requests.
        :param str host_rewrite: Host rewrite specifier.
        :param str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It
               is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout to the maximum
               time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param str max_timeout: Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60
               seconds.
        """
        pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        pulumi.set(__self__, "host_rewrite", host_rewrite)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "max_timeout", max_timeout)

    @property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> bool:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> str:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> str:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It
        is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout to the maximum
        time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="maxTimeout")
    def max_timeout(self) -> str:
        """
        Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60
        seconds.
        """
        return pulumi.get(self, "max_timeout")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult(dict):
    def __init__(__self__, *,
                 status: str):
        """
        :param str status: The status of the response. Supported values are: ok, invalid_argumet, not_found, permission_denied,
               unauthenticated, unimplemented, internal, unavailable.
        """
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the response. Supported values are: ok, invalid_argumet, not_found, permission_denied,
        unauthenticated, unimplemented, internal, unavailable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteResult(dict):
    def __init__(__self__, *,
                 direct_response_actions: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult'],
                 http_matches: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchResult'],
                 http_route_actions: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult'],
                 redirect_actions: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteRedirectActionResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteHttpRouteDirectResponseActionArgs'] direct_response_actions: (Required) Direct response action resource. The structure is documented below.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpMatchArgs'] http_matches: Checks "/" prefix by default. The structure is documented below.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpRouteActionArgs'] http_route_actions: HTTP route action resource. The structure is documented below.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteRedirectActionArgs'] redirect_actions: Redirect action resource. The structure is documented below.
        """
        pulumi.set(__self__, "direct_response_actions", direct_response_actions)
        pulumi.set(__self__, "http_matches", http_matches)
        pulumi.set(__self__, "http_route_actions", http_route_actions)
        pulumi.set(__self__, "redirect_actions", redirect_actions)

    @property
    @pulumi.getter(name="directResponseActions")
    def direct_response_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult']:
        """
        (Required) Direct response action resource. The structure is documented below.
        """
        return pulumi.get(self, "direct_response_actions")

    @property
    @pulumi.getter(name="httpMatches")
    def http_matches(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchResult']:
        """
        Checks "/" prefix by default. The structure is documented below.
        """
        return pulumi.get(self, "http_matches")

    @property
    @pulumi.getter(name="httpRouteActions")
    def http_route_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult']:
        """
        HTTP route action resource. The structure is documented below.
        """
        return pulumi.get(self, "http_route_actions")

    @property
    @pulumi.getter(name="redirectActions")
    def redirect_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteRedirectActionResult']:
        """
        Redirect action resource. The structure is documented below.
        """
        return pulumi.get(self, "redirect_actions")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult(dict):
    def __init__(__self__, *,
                 body: str,
                 status: int):
        """
        :param str body: Response body text.
        :param int status: The status of the response. Supported values are: ok, invalid_argumet, not_found, permission_denied,
               unauthenticated, unimplemented, internal, unavailable.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        Response body text.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def status(self) -> int:
        """
        The status of the response. Supported values are: ok, invalid_argumet, not_found, permission_denied,
        unauthenticated, unimplemented, internal, unavailable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpMatchResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence[str],
                 paths: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult']):
        """
        :param Sequence[str] http_methods: List of methods(strings).
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpMatchPathArgs'] paths: If not set, '/' is assumed. The structure is documented below.
        """
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence[str]:
        """
        List of methods(strings).
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult']:
        """
        If not set, '/' is assumed. The structure is documented below.
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult(dict):
    def __init__(__self__, *,
                 exact: str,
                 prefix: str):
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult(dict):
    def __init__(__self__, *,
                 auto_host_rewrite: bool,
                 backend_group_id: str,
                 host_rewrite: str,
                 idle_timeout: str,
                 prefix_rewrite: str,
                 timeout: str,
                 upgrade_types: Sequence[str]):
        """
        :param bool auto_host_rewrite: If set, will automatically rewrite host.
        :param str backend_group_id: Backend group to route requests.
        :param str host_rewrite: Host rewrite specifier.
        :param str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It
               is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout to the maximum
               time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param str prefix_rewrite: If not empty, matched path prefix will be replaced by this value.
        :param str timeout: Specifies the request timeout (overall time request processing is allowed to take) for the route. If not
               set, default is 60 seconds.
        :param Sequence[str] upgrade_types: List of upgrade types. Only specified upgrade types will be allowed. For example,
               "websocket".
        """
        pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        pulumi.set(__self__, "host_rewrite", host_rewrite)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "upgrade_types", upgrade_types)

    @property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> bool:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> str:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> str:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It
        is useful for streaming scenarios - one should set idle_timeout to something meaningful and max_timeout to the maximum
        time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> str:
        """
        If not empty, matched path prefix will be replaced by this value.
        """
        return pulumi.get(self, "prefix_rewrite")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Specifies the request timeout (overall time request processing is allowed to take) for the route. If not
        set, default is 60 seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="upgradeTypes")
    def upgrade_types(self) -> Sequence[str]:
        """
        List of upgrade types. Only specified upgrade types will be allowed. For example,
        "websocket".
        """
        return pulumi.get(self, "upgrade_types")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteRedirectActionResult(dict):
    def __init__(__self__, *,
                 remove_query: bool,
                 replace_host: str,
                 replace_path: str,
                 replace_port: int,
                 replace_prefix: str,
                 replace_scheme: str,
                 response_code: str):
        """
        :param str replace_host: Replaces hostname.
        :param str replace_path: Replace path.
        :param int replace_port: Replaces port.
        :param str replace_prefix: Replace only matched prefix. Example:<br/> match:{ prefix_match: "/some" } <br/>
               redirect: { replace_prefix: "/other" } <br/> will redirect "/something" to "/otherthing".
        :param str replace_scheme: Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port,
               if present.
        :param str response_code: The HTTP status code to use in the redirect response. Supported values are:
               moved_permanently, found, see_other, temporary_redirect, permanent_redirect.
        """
        pulumi.set(__self__, "remove_query", remove_query)
        pulumi.set(__self__, "replace_host", replace_host)
        pulumi.set(__self__, "replace_path", replace_path)
        pulumi.set(__self__, "replace_port", replace_port)
        pulumi.set(__self__, "replace_prefix", replace_prefix)
        pulumi.set(__self__, "replace_scheme", replace_scheme)
        pulumi.set(__self__, "response_code", response_code)

    @property
    @pulumi.getter(name="removeQuery")
    def remove_query(self) -> bool:
        return pulumi.get(self, "remove_query")

    @property
    @pulumi.getter(name="replaceHost")
    def replace_host(self) -> str:
        """
        Replaces hostname.
        """
        return pulumi.get(self, "replace_host")

    @property
    @pulumi.getter(name="replacePath")
    def replace_path(self) -> str:
        """
        Replace path.
        """
        return pulumi.get(self, "replace_path")

    @property
    @pulumi.getter(name="replacePort")
    def replace_port(self) -> int:
        """
        Replaces port.
        """
        return pulumi.get(self, "replace_port")

    @property
    @pulumi.getter(name="replacePrefix")
    def replace_prefix(self) -> str:
        """
        Replace only matched prefix. Example:<br/> match:{ prefix_match: "/some" } <br/>
        redirect: { replace_prefix: "/other" } <br/> will redirect "/something" to "/otherthing".
        """
        return pulumi.get(self, "replace_prefix")

    @property
    @pulumi.getter(name="replaceScheme")
    def replace_scheme(self) -> str:
        """
        Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port,
        if present.
        """
        return pulumi.get(self, "replace_scheme")

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> str:
        """
        The HTTP status code to use in the redirect response. Supported values are:
        moved_permanently, found, see_other, temporary_redirect, permanent_redirect.
        """
        return pulumi.get(self, "response_code")


@pulumi.output_type
class GetCdnOriginGroupOriginResult(dict):
    def __init__(__self__, *,
                 origin_group_id: int,
                 source: str,
                 backup: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        """
        :param int origin_group_id: The ID of a specific origin group.
        """
        pulumi.set(__self__, "origin_group_id", origin_group_id)
        pulumi.set(__self__, "source", source)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="originGroupId")
    def origin_group_id(self) -> int:
        """
        The ID of a specific origin group.
        """
        return pulumi.get(self, "origin_group_id")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def backup(self) -> Optional[bool]:
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetCdnResourceOptionsResult(dict):
    def __init__(__self__, *,
                 allowed_http_methods: Sequence[str],
                 browser_cache_settings: int,
                 cache_http_headers: Sequence[str],
                 cors: Sequence[str],
                 custom_host_header: str,
                 custom_server_name: str,
                 disable_cache: bool,
                 disable_proxy_force_ranges: bool,
                 edge_cache_settings: int,
                 fetched_compressed: bool,
                 forward_host_header: bool,
                 gzip_on: bool,
                 ignore_cookie: bool,
                 ignore_query_params: bool,
                 proxy_cache_methods_set: bool,
                 query_params_blacklists: Sequence[str],
                 query_params_whitelists: Sequence[str],
                 redirect_http_to_https: bool,
                 redirect_https_to_http: bool,
                 slice: bool,
                 static_request_headers: Sequence[str],
                 static_response_headers: Mapping[str, str]):
        """
        :param Sequence[str] allowed_http_methods: HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        :param int browser_cache_settings: set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        :param Sequence[str] cache_http_headers: list HTTP headers that must be included in responses to clients.
        :param Sequence[str] cors: parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        :param str custom_host_header: custom value for the Host header. Your server must be able to process requests with the chosen header.
        :param str custom_server_name: wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        :param bool disable_cache: setup a cache status.
        :param bool disable_proxy_force_ranges: disabling proxy force ranges.
        :param int edge_cache_settings: content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        :param bool fetched_compressed: option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        :param bool forward_host_header: choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        :param bool gzip_on: GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        :param bool ignore_cookie: set for ignoring cookie.
        :param bool ignore_query_params: files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        :param bool proxy_cache_methods_set: allows caching for GET, HEAD and POST requests.
        :param Sequence[str] query_params_blacklists: files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        :param Sequence[str] query_params_whitelists: files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        :param bool redirect_http_to_https: set up a redirect from HTTPS to HTTP.
        :param bool redirect_https_to_http: set up a redirect from HTTP to HTTPS.
        :param bool slice: files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        :param Sequence[str] static_request_headers: set up custom headers that CDN servers send in requests to origins.
        """
        pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        pulumi.set(__self__, "browser_cache_settings", browser_cache_settings)
        pulumi.set(__self__, "cache_http_headers", cache_http_headers)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "custom_host_header", custom_host_header)
        pulumi.set(__self__, "custom_server_name", custom_server_name)
        pulumi.set(__self__, "disable_cache", disable_cache)
        pulumi.set(__self__, "disable_proxy_force_ranges", disable_proxy_force_ranges)
        pulumi.set(__self__, "edge_cache_settings", edge_cache_settings)
        pulumi.set(__self__, "fetched_compressed", fetched_compressed)
        pulumi.set(__self__, "forward_host_header", forward_host_header)
        pulumi.set(__self__, "gzip_on", gzip_on)
        pulumi.set(__self__, "ignore_cookie", ignore_cookie)
        pulumi.set(__self__, "ignore_query_params", ignore_query_params)
        pulumi.set(__self__, "proxy_cache_methods_set", proxy_cache_methods_set)
        pulumi.set(__self__, "query_params_blacklists", query_params_blacklists)
        pulumi.set(__self__, "query_params_whitelists", query_params_whitelists)
        pulumi.set(__self__, "redirect_http_to_https", redirect_http_to_https)
        pulumi.set(__self__, "redirect_https_to_http", redirect_https_to_http)
        pulumi.set(__self__, "slice", slice)
        pulumi.set(__self__, "static_request_headers", static_request_headers)
        pulumi.set(__self__, "static_response_headers", static_response_headers)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Sequence[str]:
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        return pulumi.get(self, "allowed_http_methods")

    @property
    @pulumi.getter(name="browserCacheSettings")
    def browser_cache_settings(self) -> int:
        """
        set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        return pulumi.get(self, "browser_cache_settings")

    @property
    @pulumi.getter(name="cacheHttpHeaders")
    def cache_http_headers(self) -> Sequence[str]:
        """
        list HTTP headers that must be included in responses to clients.
        """
        return pulumi.get(self, "cache_http_headers")

    @property
    @pulumi.getter
    def cors(self) -> Sequence[str]:
        """
        parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="customHostHeader")
    def custom_host_header(self) -> str:
        """
        custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        return pulumi.get(self, "custom_host_header")

    @property
    @pulumi.getter(name="customServerName")
    def custom_server_name(self) -> str:
        """
        wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Read-only.
        """
        return pulumi.get(self, "custom_server_name")

    @property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> bool:
        """
        setup a cache status.
        """
        return pulumi.get(self, "disable_cache")

    @property
    @pulumi.getter(name="disableProxyForceRanges")
    def disable_proxy_force_ranges(self) -> bool:
        """
        disabling proxy force ranges.
        """
        return pulumi.get(self, "disable_proxy_force_ranges")

    @property
    @pulumi.getter(name="edgeCacheSettings")
    def edge_cache_settings(self) -> int:
        """
        content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        return pulumi.get(self, "edge_cache_settings")

    @property
    @pulumi.getter(name="fetchedCompressed")
    def fetched_compressed(self) -> bool:
        """
        option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        return pulumi.get(self, "fetched_compressed")

    @property
    @pulumi.getter(name="forwardHostHeader")
    def forward_host_header(self) -> bool:
        """
        choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        return pulumi.get(self, "forward_host_header")

    @property
    @pulumi.getter(name="gzipOn")
    def gzip_on(self) -> bool:
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        return pulumi.get(self, "gzip_on")

    @property
    @pulumi.getter(name="ignoreCookie")
    def ignore_cookie(self) -> bool:
        """
        set for ignoring cookie.
        """
        return pulumi.get(self, "ignore_cookie")

    @property
    @pulumi.getter(name="ignoreQueryParams")
    def ignore_query_params(self) -> bool:
        """
        files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        return pulumi.get(self, "ignore_query_params")

    @property
    @pulumi.getter(name="proxyCacheMethodsSet")
    def proxy_cache_methods_set(self) -> bool:
        """
        allows caching for GET, HEAD and POST requests.
        """
        return pulumi.get(self, "proxy_cache_methods_set")

    @property
    @pulumi.getter(name="queryParamsBlacklists")
    def query_params_blacklists(self) -> Sequence[str]:
        """
        files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        return pulumi.get(self, "query_params_blacklists")

    @property
    @pulumi.getter(name="queryParamsWhitelists")
    def query_params_whitelists(self) -> Sequence[str]:
        """
        files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        return pulumi.get(self, "query_params_whitelists")

    @property
    @pulumi.getter(name="redirectHttpToHttps")
    def redirect_http_to_https(self) -> bool:
        """
        set up a redirect from HTTPS to HTTP.
        """
        return pulumi.get(self, "redirect_http_to_https")

    @property
    @pulumi.getter(name="redirectHttpsToHttp")
    def redirect_https_to_http(self) -> bool:
        """
        set up a redirect from HTTP to HTTPS.
        """
        return pulumi.get(self, "redirect_https_to_http")

    @property
    @pulumi.getter
    def slice(self) -> bool:
        """
        files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        return pulumi.get(self, "slice")

    @property
    @pulumi.getter(name="staticRequestHeaders")
    def static_request_headers(self) -> Sequence[str]:
        """
        set up custom headers that CDN servers send in requests to origins.
        """
        return pulumi.get(self, "static_request_headers")

    @property
    @pulumi.getter(name="staticResponseHeaders")
    def static_response_headers(self) -> Mapping[str, str]:
        return pulumi.get(self, "static_response_headers")


@pulumi.output_type
class GetCdnResourceSslCertificateResult(dict):
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 certificate_manager_id: Optional[str] = None):
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if certificate_manager_id is not None:
            pulumi.set(__self__, "certificate_manager_id", certificate_manager_id)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="certificateManagerId")
    def certificate_manager_id(self) -> Optional[str]:
        return pulumi.get(self, "certificate_manager_id")


@pulumi.output_type
class GetComputeDiskDiskPlacementPolicyResult(dict):
    def __init__(__self__, *,
                 disk_placement_group_id: str):
        pulumi.set(__self__, "disk_placement_group_id", disk_placement_group_id)

    @property
    @pulumi.getter(name="diskPlacementGroupId")
    def disk_placement_group_id(self) -> str:
        return pulumi.get(self, "disk_placement_group_id")


@pulumi.output_type
class GetComputeInstanceBootDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: bool,
                 device_name: str,
                 disk_id: str,
                 initialize_params: Sequence['outputs.GetComputeInstanceBootDiskInitializeParamResult'],
                 mode: str):
        """
        :param bool auto_delete: Specifies whether the disk is auto-deleted when the instance is deleted.
        :param str device_name: This value can be used to reference the device from within the instance for mounting, resizing, and so on.
        :param str disk_id: ID of the disk that is attached to the instance.
        :param Sequence['GetComputeInstanceBootDiskInitializeParamArgs'] initialize_params: Parameters used for creating a disk alongside the instance. The structure is documented below.
        :param str mode: Access to the Disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> bool:
        """
        Specifies whether the disk is auto-deleted when the instance is deleted.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        This value can be used to reference the device from within the instance for mounting, resizing, and so on.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        ID of the disk that is attached to the instance.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetComputeInstanceBootDiskInitializeParamResult']:
        """
        Parameters used for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Access to the Disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetComputeInstanceBootDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 block_size: int,
                 description: str,
                 image_id: str,
                 name: str,
                 size: int,
                 snapshot_id: str,
                 type: str):
        """
        :param int block_size: The block size of the disk in bytes.
        :param str description: Description of the boot disk.
        :param str image_id: A disk image to initialize this disk from.
        :param str name: Name of the instance.
        :param int size: Size of the disk in GB.
        :param str snapshot_id: A snapshot to initialize this disk from.
        :param str type: Disk type.
        """
        pulumi.set(__self__, "block_size", block_size)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> int:
        """
        The block size of the disk in bytes.
        """
        return pulumi.get(self, "block_size")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        A disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        A snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceGroupAllocationPolicyResult(dict):
    def __init__(__self__, *,
                 zones: Sequence[str]):
        """
        :param Sequence[str] zones: A list of availability zones.
        """
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        A list of availability zones.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetComputeInstanceGroupApplicationBalancerStateResult(dict):
    def __init__(__self__, *,
                 status_message: str,
                 target_group_id: str):
        """
        :param str status_message: The status message of the target group.
        :param str target_group_id: The ID of the target group.
        """
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class GetComputeInstanceGroupApplicationLoadBalancerResult(dict):
    def __init__(__self__, *,
                 max_opening_traffic_duration: int,
                 status_message: str,
                 target_group_description: str,
                 target_group_id: str,
                 target_group_labels: Mapping[str, str],
                 target_group_name: str):
        """
        :param int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param str status_message: The status message of the target group.
        :param str target_group_description: A description of the target group.
        :param str target_group_id: The ID of the target group.
        :param Mapping[str, str] target_group_labels: A set of key/value label pairs.
        :param str target_group_name: The name of the target group.
        """
        pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_description", target_group_description)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "target_group_labels", target_group_labels)
        pulumi.set(__self__, "target_group_name", target_group_name)

    @property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> int:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> str:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Mapping[str, str]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> str:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class GetComputeInstanceGroupDeployPolicyResult(dict):
    def __init__(__self__, *,
                 max_creating: int,
                 max_deleting: int,
                 max_expansion: int,
                 max_unavailable: int,
                 startup_duration: int,
                 strategy: str):
        """
        :param int max_creating: The maximum number of instances that can be created at the same time.
        :param int max_deleting: The maximum number of instances that can be deleted at the same time.
        :param int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        :param int max_unavailable: The maximum number of running instances that can be taken offline (stopped or deleted) at the same time
               during the update process.
        :param int startup_duration: The amount of time in seconds to allow for an instance to start.
        :param str strategy: Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups
               can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead,
               it will wait until the instance stops itself or becomes unhealthy.
        """
        pulumi.set(__self__, "max_creating", max_creating)
        pulumi.set(__self__, "max_deleting", max_deleting)
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        pulumi.set(__self__, "startup_duration", startup_duration)
        pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="maxCreating")
    def max_creating(self) -> int:
        """
        The maximum number of instances that can be created at the same time.
        """
        return pulumi.get(self, "max_creating")

    @property
    @pulumi.getter(name="maxDeleting")
    def max_deleting(self) -> int:
        """
        The maximum number of instances that can be deleted at the same time.
        """
        return pulumi.get(self, "max_deleting")

    @property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        """
        return pulumi.get(self, "max_expansion")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        """
        The maximum number of running instances that can be taken offline (stopped or deleted) at the same time
        during the update process.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter(name="startupDuration")
    def startup_duration(self) -> int:
        """
        The amount of time in seconds to allow for an instance to start.
        """
        return pulumi.get(self, "startup_duration")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups
        can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead,
        it will wait until the instance stops itself or becomes unhealthy.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetComputeInstanceGroupHealthCheckResult(dict):
    def __init__(__self__, *,
                 healthy_threshold: int,
                 http_options: Sequence['outputs.GetComputeInstanceGroupHealthCheckHttpOptionResult'],
                 interval: int,
                 tcp_options: Sequence['outputs.GetComputeInstanceGroupHealthCheckTcpOptionResult'],
                 timeout: int,
                 unhealthy_threshold: int):
        """
        :param int healthy_threshold: The number of successful health checks before the managed instance is declared healthy.
        :param Sequence['GetComputeInstanceGroupHealthCheckHttpOptionArgs'] http_options: HTTP check options. The structure is documented below.
        :param int interval: The interval between health checks in seconds.
        :param Sequence['GetComputeInstanceGroupHealthCheckTcpOptionArgs'] tcp_options: TCP check options. The structure is documented below.
        :param int timeout: Timeout for the managed instance to return a response for the health check in seconds.
        :param int unhealthy_threshold: The number of failed health checks before the managed instance is declared unhealthy.
        """
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_options", http_options)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "tcp_options", tcp_options)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        The number of successful health checks before the managed instance is declared healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Sequence['outputs.GetComputeInstanceGroupHealthCheckHttpOptionResult']:
        """
        HTTP check options. The structure is documented below.
        """
        return pulumi.get(self, "http_options")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The interval between health checks in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Sequence['outputs.GetComputeInstanceGroupHealthCheckTcpOptionResult']:
        """
        TCP check options. The structure is documented below.
        """
        return pulumi.get(self, "tcp_options")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        Timeout for the managed instance to return a response for the health check in seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        The number of failed health checks before the managed instance is declared unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetComputeInstanceGroupHealthCheckHttpOptionResult(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        """
        :param str path: The URL path used for health check requests.
        :param int port: The port to use for TCP health checks.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The URL path used for health check requests.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to use for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetComputeInstanceGroupHealthCheckTcpOptionResult(dict):
    def __init__(__self__, *,
                 port: int):
        """
        :param int port: The port to use for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to use for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetComputeInstanceGroupInstanceResult(dict):
    def __init__(__self__, *,
                 fqdn: str,
                 instance_id: str,
                 name: str,
                 network_interfaces: Sequence['outputs.GetComputeInstanceGroupInstanceNetworkInterfaceResult'],
                 status: str,
                 status_changed_at: str,
                 status_message: str,
                 zone_id: str):
        """
        :param str fqdn: The Fully Qualified Domain Name.
        :param str instance_id: The ID of the instance.
        :param str name: The name of the managed instance.
        :param Sequence['GetComputeInstanceGroupInstanceNetworkInterfaceArgs'] network_interfaces: An array with the network interfaces attached to the managed instance. The structure is documented below.
               * `status_changed_at` -The timestamp when the status of the managed instance was last changed.
        :param str status: The status of the instance.
        :param str status_message: The status message of the target group.
        :param str zone_id: The ID of the availability zone where the instance resides.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_changed_at", status_changed_at)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The Fully Qualified Domain Name.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The ID of the instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the managed instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceNetworkInterfaceResult']:
        """
        An array with the network interfaces attached to the managed instance. The structure is documented below.
        * `status_changed_at` -The timestamp when the status of the managed instance was last changed.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the instance.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusChangedAt")
    def status_changed_at(self) -> str:
        return pulumi.get(self, "status_changed_at")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The ID of the availability zone where the instance resides.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetComputeInstanceGroupInstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 index: int,
                 ip_address: str,
                 ipv4: bool,
                 ipv6: bool,
                 ipv6_address: str,
                 mac_address: str,
                 nat: bool,
                 nat_ip_address: str,
                 nat_ip_version: str,
                 subnet_id: str):
        """
        :param int index: The index of the network interface as generated by the server.
        :param str ip_address: The private IP address to assign to the instance. If empty, the address is automatically assigned from the specified subnet.
        :param bool ipv4: Is IPv4 address assigned.
        :param str ipv6_address: Manual set static IPv6 address.
        :param str mac_address: The MAC address assigned to the network interface.
        :param bool nat: The instance's public address for accessing the internet over NAT.
        :param str nat_ip_address: The public IP address of the instance.
        :param str nat_ip_version: The IP version for the public address.
        :param str subnet_id: The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The index of the network interface as generated by the server.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The private IP address to assign to the instance. If empty, the address is automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def ipv4(self) -> bool:
        """
        Is IPv4 address assigned.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The MAC address assigned to the network interface.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def nat(self) -> bool:
        """
        The instance's public address for accessing the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> str:
        """
        The public IP address of the instance.
        """
        return pulumi.get(self, "nat_ip_address")

    @property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> str:
        """
        The IP version for the public address.
        """
        return pulumi.get(self, "nat_ip_version")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateResult(dict):
    def __init__(__self__, *,
                 boot_disks: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskResult'],
                 description: str,
                 hostname: str,
                 labels: Mapping[str, str],
                 metadata: Mapping[str, str],
                 name: str,
                 network_interfaces: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult'],
                 network_settings: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkSettingResult'],
                 platform_id: str,
                 resources: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateResourceResult'],
                 scheduling_policies: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult'],
                 secondary_disks: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult'],
                 service_account_id: str,
                 placement_policy: Optional['outputs.GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult'] = None):
        """
        :param Sequence['GetComputeInstanceGroupInstanceTemplateBootDiskArgs'] boot_disks: The specifications for boot disk that will be attached to the instance. The structure is documented below.
        :param str description: A description of the boot disk.
        :param str hostname: Hostname temaplate for the instance.
        :param Mapping[str, str] labels: A map of labels applied to this instance.
               * `resources.0.memory` - The memory size allocated to the instance.
               * `resources.0.cores` - Number of CPU cores allocated to the instance.
               * `resources.0.core_fraction` - Baseline core performance as a percent.
               * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        :param Mapping[str, str] metadata: The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
        :param str name: The name of the managed instance.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: An array with the network interfaces attached to the managed instance. The structure is documented below.
               * `status_changed_at` -The timestamp when the status of the managed instance was last changed.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkSettingArgs'] network_settings: Network acceleration settings. The structure is documented below.
        :param str platform_id: The ID of the hardware platform configuration for the instance.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs'] scheduling_policies: The scheduling policy for the instance. The structure is documented below.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateSecondaryDiskArgs'] secondary_disks: An array with the secondary disks that will be attached to the instance. The structure is documented below.
        :param str service_account_id: The service account ID for the instance.
        """
        pulumi.set(__self__, "boot_disks", boot_disks)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "network_settings", network_settings)
        pulumi.set(__self__, "platform_id", platform_id)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "scheduling_policies", scheduling_policies)
        pulumi.set(__self__, "secondary_disks", secondary_disks)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)

    @property
    @pulumi.getter(name="bootDisks")
    def boot_disks(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskResult']:
        """
        The specifications for boot disk that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "boot_disks")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Hostname temaplate for the instance.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        A map of labels applied to this instance.
        * `resources.0.memory` - The memory size allocated to the instance.
        * `resources.0.cores` - Number of CPU cores allocated to the instance.
        * `resources.0.core_fraction` - Baseline core performance as a percent.
        * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def metadata(self) -> Mapping[str, str]:
        """
        The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the managed instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult']:
        """
        An array with the network interfaces attached to the managed instance. The structure is documented below.
        * `status_changed_at` -The timestamp when the status of the managed instance was last changed.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="networkSettings")
    def network_settings(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkSettingResult']:
        """
        Network acceleration settings. The structure is documented below.
        """
        return pulumi.get(self, "network_settings")

    @property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> str:
        """
        The ID of the hardware platform configuration for the instance.
        """
        return pulumi.get(self, "platform_id")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateResourceResult']:
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="schedulingPolicies")
    def scheduling_policies(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult']:
        """
        The scheduling policy for the instance. The structure is documented below.
        """
        return pulumi.get(self, "scheduling_policies")

    @property
    @pulumi.getter(name="secondaryDisks")
    def secondary_disks(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult']:
        """
        An array with the secondary disks that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "secondary_disks")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> str:
        """
        The service account ID for the instance.
        """
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional['outputs.GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult']:
        return pulumi.get(self, "placement_policy")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateBootDiskResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 disk_id: str,
                 initialize_params: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult'],
                 mode: str):
        """
        :param str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param str disk_id: ID of the existing disk. To set use variables.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamArgs'] initialize_params: The parameters used for creating a disk alongside the instance. The structure is documented below.
        :param str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult']:
        """
        The parameters used for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 description: str,
                 image_id: str,
                 size: int,
                 snapshot_id: str,
                 type: str):
        """
        :param str description: A description of the boot disk.
        :param str image_id: The disk image to initialize this disk from.
        :param int size: The size of the disk in GB.
        :param str snapshot_id: The snapshot to initialize this disk from.
        :param str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 dns_records: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult'],
                 ip_address: str,
                 ipv4: bool,
                 ipv6: bool,
                 ipv6_address: str,
                 ipv6_dns_records: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult'],
                 nat: bool,
                 nat_dns_records: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult'],
                 nat_ip_address: str,
                 network_id: str,
                 security_group_ids: Sequence[str],
                 subnet_ids: Sequence[str]):
        """
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs'] dns_records: List of dns records.  The structure is documented below.
        :param str ip_address: The private IP address to assign to the instance. If empty, the address is automatically assigned from the specified subnet.
        :param bool ipv4: Is IPv4 address assigned.
        :param str ipv6_address: Manual set static IPv6 address.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of ipv6 dns records.  The structure is documented below.
        :param bool nat: The instance's public address for accessing the internet over NAT.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of nat dns records.  The structure is documented below.
        :param str nat_ip_address: The public IP address of the instance.
        :param str network_id: The ID of the network.
        :param Sequence[str] security_group_ids: Security group ids for network interface.
        :param Sequence[str] subnet_ids: The IDs of the subnets.
        """
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult']:
        """
        List of dns records.  The structure is documented below.
        """
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The private IP address to assign to the instance. If empty, the address is automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def ipv4(self) -> bool:
        """
        Is IPv4 address assigned.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult']:
        """
        List of ipv6 dns records.  The structure is documented below.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @property
    @pulumi.getter
    def nat(self) -> bool:
        """
        The instance's public address for accessing the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult']:
        """
        List of nat dns records.  The structure is documented below.
        """
        return pulumi.get(self, "nat_dns_records")

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> str:
        """
        The public IP address of the instance.
        """
        return pulumi.get(self, "nat_ip_address")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        The ID of the network.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: str,
                 fqdn: str,
                 ptr: bool,
                 ttl: int):
        """
        :param str dns_zone_id: DNS zone id (if not set, private zone is used).
        :param str fqdn: The Fully Qualified Domain Name.
        :param bool ptr: When set to true, also create PTR DNS record.
        :param int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> str:
        """
        DNS zone id (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The Fully Qualified Domain Name.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ptr(self) -> bool:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: str,
                 fqdn: str,
                 ptr: bool,
                 ttl: int):
        """
        :param str dns_zone_id: DNS zone id (if not set, private zone is used).
        :param str fqdn: The Fully Qualified Domain Name.
        :param bool ptr: When set to true, also create PTR DNS record.
        :param int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> str:
        """
        DNS zone id (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The Fully Qualified Domain Name.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ptr(self) -> bool:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: str,
                 fqdn: str,
                 ptr: bool,
                 ttl: int):
        """
        :param str dns_zone_id: DNS zone id (if not set, private zone is used).
        :param str fqdn: The Fully Qualified Domain Name.
        :param bool ptr: When set to true, also create PTR DNS record.
        :param int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> str:
        """
        DNS zone id (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The Fully Qualified Domain Name.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ptr(self) -> bool:
        """
        When set to true, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkSettingResult(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult(dict):
    def __init__(__self__, *,
                 placement_group_id: str):
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateResourceResult(dict):
    def __init__(__self__, *,
                 core_fraction: int,
                 cores: int,
                 gpus: int,
                 memory: float):
        pulumi.set(__self__, "core_fraction", core_fraction)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> int:
        return pulumi.get(self, "core_fraction")

    @property
    @pulumi.getter
    def cores(self) -> int:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def gpus(self) -> int:
        return pulumi.get(self, "gpus")

    @property
    @pulumi.getter
    def memory(self) -> float:
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult(dict):
    def __init__(__self__, *,
                 preemptible: bool):
        """
        :param bool preemptible: Specifies if the instance is preemptible. Defaults to false.
        """
        pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> bool:
        """
        Specifies if the instance is preemptible. Defaults to false.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 disk_id: str,
                 initialize_params: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult'],
                 mode: str):
        """
        :param str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param str disk_id: ID of the existing disk. To set use variables.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamArgs'] initialize_params: The parameters used for creating a disk alongside the instance. The structure is documented below.
        :param str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult']:
        """
        The parameters used for creating a disk alongside the instance. The structure is documented below.
        """
        return pulumi.get(self, "initialize_params")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 description: str,
                 image_id: str,
                 size: int,
                 snapshot_id: str,
                 type: str):
        """
        :param str description: A description of the boot disk.
        :param str image_id: The disk image to initialize this disk from.
        :param int size: The size of the disk in GB.
        :param str snapshot_id: The snapshot to initialize this disk from.
        :param str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceGroupLoadBalancerResult(dict):
    def __init__(__self__, *,
                 max_opening_traffic_duration: int,
                 status_message: str,
                 target_group_description: str,
                 target_group_id: str,
                 target_group_labels: Mapping[str, str],
                 target_group_name: str):
        """
        :param int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param str status_message: The status message of the target group.
        :param str target_group_description: A description of the target group.
        :param str target_group_id: The ID of the target group.
        :param Mapping[str, str] target_group_labels: A set of key/value label pairs.
        :param str target_group_name: The name of the target group.
        """
        pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_description", target_group_description)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "target_group_labels", target_group_labels)
        pulumi.set(__self__, "target_group_name", target_group_name)

    @property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> int:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> str:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Mapping[str, str]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> str:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class GetComputeInstanceGroupLoadBalancerStateResult(dict):
    def __init__(__self__, *,
                 status_message: str,
                 target_group_id: str):
        """
        :param str status_message: The status message of the target group.
        :param str target_group_id: The ID of the target group.
        """
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyResult(dict):
    def __init__(__self__, *,
                 auto_scales: Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleResult'],
                 fixed_scales: Sequence['outputs.GetComputeInstanceGroupScalePolicyFixedScaleResult'],
                 test_auto_scales: Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleResult']):
        """
        :param Sequence['GetComputeInstanceGroupScalePolicyAutoScaleArgs'] auto_scales: The auto scaling policy of the instance group. The structure is documented below.
        :param Sequence['GetComputeInstanceGroupScalePolicyFixedScaleArgs'] fixed_scales: The fixed scaling policy of the instance group. The structure is documented below.
        :param Sequence['GetComputeInstanceGroupScalePolicyTestAutoScaleArgs'] test_auto_scales: The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
        """
        pulumi.set(__self__, "auto_scales", auto_scales)
        pulumi.set(__self__, "fixed_scales", fixed_scales)
        pulumi.set(__self__, "test_auto_scales", test_auto_scales)

    @property
    @pulumi.getter(name="autoScales")
    def auto_scales(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleResult']:
        """
        The auto scaling policy of the instance group. The structure is documented below.
        """
        return pulumi.get(self, "auto_scales")

    @property
    @pulumi.getter(name="fixedScales")
    def fixed_scales(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyFixedScaleResult']:
        """
        The fixed scaling policy of the instance group. The structure is documented below.
        """
        return pulumi.get(self, "fixed_scales")

    @property
    @pulumi.getter(name="testAutoScales")
    def test_auto_scales(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleResult']:
        """
        The test auto scaling policy of the instance group. Use it to test how the auto scale works. The structure is documented below.
        """
        return pulumi.get(self, "test_auto_scales")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyAutoScaleResult(dict):
    def __init__(__self__, *,
                 cpu_utilization_target: float,
                 custom_rules: Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult'],
                 initial_size: int,
                 max_size: int,
                 measurement_duration: int,
                 min_zone_size: int,
                 stabilization_duration: int,
                 warmup_duration: int):
        """
        :param float cpu_utilization_target: Target CPU load level.
        :param Sequence['GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules. The structure is documented below.
        :param int initial_size: The initial number of instances in the instance group.
        :param int max_size: The maximum number of virtual machines in the group.
        :param int measurement_duration: The amount of time, in seconds, that metrics are averaged for.
               If the average value at the end of the interval is higher than the `cpu_utilization_target`,
               the instance group will increase the number of virtual machines in the group.
        :param int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param int stabilization_duration: The minimum time interval, in seconds, to monitor the load before
               an instance group can reduce the number of virtual machines in the group. During this time, the group
               will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time,
               traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        pulumi.set(__self__, "custom_rules", custom_rules)
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        pulumi.set(__self__, "min_zone_size", min_zone_size)
        pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> float:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult']:
        """
        A list of custom rules. The structure is documented below.
        """
        return pulumi.get(self, "custom_rules")

    @property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> int:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> int:
        """
        The amount of time, in seconds, that metrics are averaged for.
        If the average value at the end of the interval is higher than the `cpu_utilization_target`,
        the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> int:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> int:
        """
        The minimum time interval, in seconds, to monitor the load before
        an instance group can reduce the number of virtual machines in the group. During this time, the group
        will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> int:
        """
        The warm-up time of the virtual machine, in seconds. During this time,
        traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult(dict):
    def __init__(__self__, *,
                 folder_id: str,
                 labels: Mapping[str, str],
                 metric_name: str,
                 metric_type: str,
                 rule_type: str,
                 service: str,
                 target: float):
        """
        :param str folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param Mapping[str, str] labels: A map of labels applied to this instance.
               * `resources.0.memory` - The memory size allocated to the instance.
               * `resources.0.cores` - Number of CPU cores allocated to the instance.
               * `resources.0.core_fraction` - Baseline core performance as a percent.
               * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        :param str metric_name: The name of metric.
        :param str metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param str rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
               First, Instance Groups calculates the average metric value for each instance,
               then averages the values for instances in one availability zone.
               This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
               This type of metric must have the `zone_id` label.
        :param str service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        :param float target: Target metric value level.
        """
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> str:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        A map of labels applied to this instance.
        * `resources.0.memory` - The memory size allocated to the instance.
        * `resources.0.cores` - Number of CPU cores allocated to the instance.
        * `resources.0.core_fraction` - Baseline core performance as a percent.
        * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
        First, Instance Groups calculates the average metric value for each instance,
        then averages the values for instances in one availability zone.
        This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
        This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyFixedScaleResult(dict):
    def __init__(__self__, *,
                 size: int):
        """
        :param int size: The size of the disk in GB.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyTestAutoScaleResult(dict):
    def __init__(__self__, *,
                 cpu_utilization_target: float,
                 custom_rules: Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult'],
                 initial_size: int,
                 max_size: int,
                 measurement_duration: int,
                 min_zone_size: int,
                 stabilization_duration: int,
                 warmup_duration: int):
        """
        :param float cpu_utilization_target: Target CPU load level.
        :param Sequence['GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules. The structure is documented below.
        :param int initial_size: The initial number of instances in the instance group.
        :param int max_size: The maximum number of virtual machines in the group.
        :param int measurement_duration: The amount of time, in seconds, that metrics are averaged for.
               If the average value at the end of the interval is higher than the `cpu_utilization_target`,
               the instance group will increase the number of virtual machines in the group.
        :param int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param int stabilization_duration: The minimum time interval, in seconds, to monitor the load before
               an instance group can reduce the number of virtual machines in the group. During this time, the group
               will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time,
               traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        pulumi.set(__self__, "custom_rules", custom_rules)
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        pulumi.set(__self__, "min_zone_size", min_zone_size)
        pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> float:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult']:
        """
        A list of custom rules. The structure is documented below.
        """
        return pulumi.get(self, "custom_rules")

    @property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> int:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> int:
        """
        The amount of time, in seconds, that metrics are averaged for.
        If the average value at the end of the interval is higher than the `cpu_utilization_target`,
        the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> int:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> int:
        """
        The minimum time interval, in seconds, to monitor the load before
        an instance group can reduce the number of virtual machines in the group. During this time, the group
        will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> int:
        """
        The warm-up time of the virtual machine, in seconds. During this time,
        traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult(dict):
    def __init__(__self__, *,
                 folder_id: str,
                 labels: Mapping[str, str],
                 metric_name: str,
                 metric_type: str,
                 rule_type: str,
                 service: str,
                 target: float):
        """
        :param str folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param Mapping[str, str] labels: A map of labels applied to this instance.
               * `resources.0.memory` - The memory size allocated to the instance.
               * `resources.0.cores` - Number of CPU cores allocated to the instance.
               * `resources.0.core_fraction` - Baseline core performance as a percent.
               * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        :param str metric_name: The name of metric.
        :param str metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param str rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
               First, Instance Groups calculates the average metric value for each instance,
               then averages the values for instances in one availability zone.
               This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
               This type of metric must have the `zone_id` label.
        :param str service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        :param float target: Target metric value level.
        """
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> str:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        A map of labels applied to this instance.
        * `resources.0.memory` - The memory size allocated to the instance.
        * `resources.0.cores` - Number of CPU cores allocated to the instance.
        * `resources.0.core_fraction` - Baseline core performance as a percent.
        * `resources.0.gpus` - Number of GPU cores allocated to the instance.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> str:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance.
        First, Instance Groups calculates the average metric value for each instance,
        then averages the values for instances in one availability zone.
        This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone.
        This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 dns_records: Sequence['outputs.GetComputeInstanceNetworkInterfaceDnsRecordResult'],
                 index: int,
                 ip_address: str,
                 ipv4: bool,
                 ipv6: bool,
                 ipv6_address: str,
                 ipv6_dns_records: Sequence['outputs.GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult'],
                 mac_address: str,
                 nat: bool,
                 nat_dns_records: Sequence['outputs.GetComputeInstanceNetworkInterfaceNatDnsRecordResult'],
                 nat_ip_address: str,
                 nat_ip_version: str,
                 security_group_ids: Sequence[str],
                 subnet_id: str):
        """
        :param Sequence['GetComputeInstanceNetworkInterfaceDnsRecordArgs'] dns_records: List of configurations for creating ipv4 DNS records. The structure is documented below.
        :param int index: The index of the network interface, generated by the server.
        :param str ip_address: The assignd private IP address to the network interface.
        :param bool ipv4: Show if IPv4 address is assigned to the network interface.
        :param Sequence['GetComputeInstanceNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of configurations for creating ipv6 DNS records. The structure is documented below.
        :param str mac_address: MAC address that is assigned to the network interface.
        :param bool nat: Assigned for the instance's public address that is used to access the internet over NAT.
        :param Sequence['GetComputeInstanceNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of configurations for creating ipv4 NAT DNS records. The structure is documented below.
        :param str nat_ip_address: Public IP address of the instance.
        :param str nat_ip_version: IP version for the public address.
        :param Sequence[str] security_group_ids: Security group ids for network interface.
        :param str subnet_id: ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Sequence['outputs.GetComputeInstanceNetworkInterfaceDnsRecordResult']:
        """
        List of configurations for creating ipv4 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "dns_records")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The index of the network interface, generated by the server.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The assignd private IP address to the network interface.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def ipv4(self) -> bool:
        """
        Show if IPv4 address is assigned to the network interface.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Sequence['outputs.GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult']:
        """
        List of configurations for creating ipv6 DNS records. The structure is documented below.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        MAC address that is assigned to the network interface.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def nat(self) -> bool:
        """
        Assigned for the instance's public address that is used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Sequence['outputs.GetComputeInstanceNetworkInterfaceNatDnsRecordResult']:
        """
        List of configurations for creating ipv4 NAT DNS records. The structure is documented below.
        """
        return pulumi.get(self, "nat_dns_records")

    @property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> str:
        """
        Public IP address of the instance.
        """
        return pulumi.get(self, "nat_ip_address")

    @property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> str:
        """
        IP version for the public address.
        """
        return pulumi.get(self, "nat_ip_version")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: str,
                 fqdn: str,
                 ptr: bool,
                 ttl: int):
        """
        :param str dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param str fqdn: DNS record FQDN.
        :param bool ptr: When set to true, also create a TR DNS record.
        :param int ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> str:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ptr(self) -> bool:
        """
        When set to true, also create a TR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: str,
                 fqdn: str,
                 ptr: bool,
                 ttl: int):
        """
        :param str dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param str fqdn: DNS record FQDN.
        :param bool ptr: When set to true, also create a TR DNS record.
        :param int ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> str:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ptr(self) -> bool:
        """
        When set to true, also create a TR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceNatDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: str,
                 fqdn: str,
                 ptr: bool,
                 ttl: int):
        """
        :param str dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param str fqdn: DNS record FQDN.
        :param bool ptr: When set to true, also create a TR DNS record.
        :param int ttl: DNS record TTL. in seconds
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> str:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ptr(self) -> bool:
        """
        When set to true, also create a TR DNS record.
        """
        return pulumi.get(self, "ptr")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        DNS record TTL. in seconds
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstancePlacementPolicyResult(dict):
    def __init__(__self__, *,
                 placement_group_id: str):
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class GetComputeInstanceResourceResult(dict):
    def __init__(__self__, *,
                 core_fraction: int,
                 cores: int,
                 gpus: int,
                 memory: float):
        pulumi.set(__self__, "core_fraction", core_fraction)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> int:
        return pulumi.get(self, "core_fraction")

    @property
    @pulumi.getter
    def cores(self) -> int:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def gpus(self) -> int:
        return pulumi.get(self, "gpus")

    @property
    @pulumi.getter
    def memory(self) -> float:
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetComputeInstanceSchedulingPolicyResult(dict):
    def __init__(__self__, *,
                 preemptible: Optional[bool] = None):
        """
        :param bool preemptible: (Optional) Specifies if the instance is preemptible. Defaults to false.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[bool]:
        """
        (Optional) Specifies if the instance is preemptible. Defaults to false.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetComputeInstanceSecondaryDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: bool,
                 device_name: str,
                 disk_id: str,
                 mode: str):
        """
        :param bool auto_delete: Specifies whether the disk is auto-deleted when the instance is deleted.
        :param str device_name: This value can be used to reference the device from within the instance for mounting, resizing, and so on.
        :param str disk_id: ID of the disk that is attached to the instance.
        :param str mode: Access to the Disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> bool:
        """
        Specifies whether the disk is auto-deleted when the instance is deleted.
        """
        return pulumi.get(self, "auto_delete")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        This value can be used to reference the device from within the instance for mounting, resizing, and so on.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        ID of the disk that is attached to the instance.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Access to the Disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetDataprocClusterClusterConfigResult(dict):
    def __init__(__self__, *,
                 hadoops: Sequence['outputs.GetDataprocClusterClusterConfigHadoopResult'],
                 subcluster_specs: Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResult'],
                 version_id: str):
        """
        :param Sequence['GetDataprocClusterClusterConfigHadoopArgs'] hadoops: Data Proc specific options. The structure is documented below.
        :param Sequence['GetDataprocClusterClusterConfigSubclusterSpecArgs'] subcluster_specs: Configuration of the Data Proc subcluster. The structure is documented below.
        :param str version_id: Version of Data Proc image.
        """
        pulumi.set(__self__, "hadoops", hadoops)
        pulumi.set(__self__, "subcluster_specs", subcluster_specs)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter
    def hadoops(self) -> Sequence['outputs.GetDataprocClusterClusterConfigHadoopResult']:
        """
        Data Proc specific options. The structure is documented below.
        """
        return pulumi.get(self, "hadoops")

    @property
    @pulumi.getter(name="subclusterSpecs")
    def subcluster_specs(self) -> Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResult']:
        """
        Configuration of the Data Proc subcluster. The structure is documented below.
        """
        return pulumi.get(self, "subcluster_specs")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        """
        Version of Data Proc image.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class GetDataprocClusterClusterConfigHadoopResult(dict):
    def __init__(__self__, *,
                 properties: Mapping[str, str],
                 services: Sequence[str],
                 ssh_public_keys: Sequence[str]):
        """
        :param Mapping[str, str] properties: A set of key/value pairs used to configure cluster services.
        :param Sequence[str] services: List of services launched on Data Proc cluster.
        :param Sequence[str] ssh_public_keys: List of SSH public keys distributed to the hosts of the cluster.
        """
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @property
    @pulumi.getter
    def properties(self) -> Mapping[str, str]:
        """
        A set of key/value pairs used to configure cluster services.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def services(self) -> Sequence[str]:
        """
        List of services launched on Data Proc cluster.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[str]:
        """
        List of SSH public keys distributed to the hosts of the cluster.
        """
        return pulumi.get(self, "ssh_public_keys")


@pulumi.output_type
class GetDataprocClusterClusterConfigSubclusterSpecResult(dict):
    def __init__(__self__, *,
                 autoscaling_configs: Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult'],
                 hosts_count: int,
                 id: str,
                 name: str,
                 resources: Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResourceResult'],
                 role: str,
                 subnet_id: str):
        """
        :param Sequence['GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs'] autoscaling_configs: Optional autoscaling configuration for compute subclusters.
        :param int hosts_count: Number of hosts within Data Proc subcluster.
        :param str id: ID of the Data Proc subcluster.
        :param str name: The name of the Data Proc cluster.
        :param Sequence['GetDataprocClusterClusterConfigSubclusterSpecResourceArgs'] resources: Resources allocated to each host of the Data Proc subcluster. The structure is documented below.
        :param str role: Role of the subcluster in the Data Proc cluster.
        :param str subnet_id: The ID of the subnet, to which hosts of the subcluster belong.
        """
        pulumi.set(__self__, "autoscaling_configs", autoscaling_configs)
        pulumi.set(__self__, "hosts_count", hosts_count)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="autoscalingConfigs")
    def autoscaling_configs(self) -> Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult']:
        """
        Optional autoscaling configuration for compute subclusters.
        """
        return pulumi.get(self, "autoscaling_configs")

    @property
    @pulumi.getter(name="hostsCount")
    def hosts_count(self) -> int:
        """
        Number of hosts within Data Proc subcluster.
        """
        return pulumi.get(self, "hosts_count")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the Data Proc subcluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Data Proc cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResourceResult']:
        """
        Resources allocated to each host of the Data Proc subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role of the subcluster in the Data Proc cluster.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which hosts of the subcluster belong.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult(dict):
    def __init__(__self__, *,
                 cpu_utilization_target: float,
                 decommission_timeout: int,
                 max_hosts_count: int,
                 measurement_duration: int,
                 preemptible: bool,
                 stabilization_duration: int,
                 warmup_duration: int):
        """
        :param float cpu_utilization_target: Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        :param int decommission_timeout: Timeout to gracefully decommission nodes during downscaling. In seconds.
        :param int max_hosts_count: Maximum number of nodes in autoscaling subclusters.
        :param int measurement_duration: Time in seconds allotted for averaging metrics.
        :param bool preemptible: Bool flag -- whether to use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://cloud.yandex.com/docs/compute/concepts/preemptible-vm).
        :param int stabilization_duration: Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        :param int warmup_duration: The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        pulumi.set(__self__, "decommission_timeout", decommission_timeout)
        pulumi.set(__self__, "max_hosts_count", max_hosts_count)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        pulumi.set(__self__, "preemptible", preemptible)
        pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        pulumi.set(__self__, "warmup_duration", warmup_duration)

    @property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> float:
        """
        Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @property
    @pulumi.getter(name="decommissionTimeout")
    def decommission_timeout(self) -> int:
        """
        Timeout to gracefully decommission nodes during downscaling. In seconds.
        """
        return pulumi.get(self, "decommission_timeout")

    @property
    @pulumi.getter(name="maxHostsCount")
    def max_hosts_count(self) -> int:
        """
        Maximum number of nodes in autoscaling subclusters.
        """
        return pulumi.get(self, "max_hosts_count")

    @property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> int:
        """
        Time in seconds allotted for averaging metrics.
        """
        return pulumi.get(self, "measurement_duration")

    @property
    @pulumi.getter
    def preemptible(self) -> bool:
        """
        Bool flag -- whether to use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://cloud.yandex.com/docs/compute/concepts/preemptible-vm).
        """
        return pulumi.get(self, "preemptible")

    @property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> int:
        """
        Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        """
        return pulumi.get(self, "stabilization_duration")

    @property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> int:
        """
        The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class GetDataprocClusterClusterConfigSubclusterSpecResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of a host.
        :param str resource_preset_id: The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://cloud.yandex.com/docs/data-proc/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of a host.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        """
        The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://cloud.yandex.com/docs/data-proc/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetFunctionScalingPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 tag: str,
                 zone_instances_limit: Optional[int] = None,
                 zone_requests_limit: Optional[int] = None):
        pulumi.set(__self__, "tag", tag)
        if zone_instances_limit is not None:
            pulumi.set(__self__, "zone_instances_limit", zone_instances_limit)
        if zone_requests_limit is not None:
            pulumi.set(__self__, "zone_requests_limit", zone_requests_limit)

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zoneInstancesLimit")
    def zone_instances_limit(self) -> Optional[int]:
        return pulumi.get(self, "zone_instances_limit")

    @property
    @pulumi.getter(name="zoneRequestsLimit")
    def zone_requests_limit(self) -> Optional[int]:
        return pulumi.get(self, "zone_requests_limit")


@pulumi.output_type
class GetFunctionTriggerDlqResult(dict):
    def __init__(__self__, *,
                 queue_id: str,
                 service_account_id: str):
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> str:
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetFunctionTriggerFunctionResult(dict):
    def __init__(__self__, *,
                 id: str,
                 retry_attempts: str,
                 retry_interval: str,
                 service_account_id: str,
                 tag: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retry_attempts", retry_attempts)
        pulumi.set(__self__, "retry_interval", retry_interval)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> str:
        return pulumi.get(self, "retry_attempts")

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> str:
        return pulumi.get(self, "retry_interval")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> str:
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetFunctionTriggerIotResult(dict):
    def __init__(__self__, *,
                 device_id: str,
                 registry_id: str,
                 topic: str):
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "registry_id", registry_id)
        pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> str:
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> str:
        return pulumi.get(self, "registry_id")

    @property
    @pulumi.getter
    def topic(self) -> str:
        return pulumi.get(self, "topic")


@pulumi.output_type
class GetFunctionTriggerLogGroupResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: str,
                 batch_size: str,
                 log_group_ids: Sequence[str]):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "log_group_ids", log_group_ids)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> str:
        return pulumi.get(self, "batch_cutoff")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> str:
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="logGroupIds")
    def log_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "log_group_ids")


@pulumi.output_type
class GetFunctionTriggerLoggingResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: str,
                 batch_size: str,
                 group_id: str,
                 levels: Sequence[str],
                 resource_ids: Sequence[str],
                 resource_types: Sequence[str]):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "resource_ids", resource_ids)
        pulumi.set(__self__, "resource_types", resource_types)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> str:
        return pulumi.get(self, "batch_cutoff")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> str:
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def levels(self) -> Sequence[str]:
        return pulumi.get(self, "levels")

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Sequence[str]:
        return pulumi.get(self, "resource_ids")

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Sequence[str]:
        return pulumi.get(self, "resource_types")


@pulumi.output_type
class GetFunctionTriggerMessageQueueResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: str,
                 batch_size: str,
                 queue_id: str,
                 service_account_id: str,
                 visibility_timeout: str):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> str:
        return pulumi.get(self, "batch_cutoff")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> str:
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> str:
        return pulumi.get(self, "queue_id")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> str:
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> str:
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class GetFunctionTriggerObjectStorageResult(dict):
    def __init__(__self__, *,
                 bucket_id: str,
                 create: bool,
                 delete: bool,
                 prefix: str,
                 suffix: str,
                 update: bool):
        pulumi.set(__self__, "bucket_id", bucket_id)
        pulumi.set(__self__, "create", create)
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "suffix", suffix)
        pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter(name="bucketId")
    def bucket_id(self) -> str:
        return pulumi.get(self, "bucket_id")

    @property
    @pulumi.getter
    def create(self) -> bool:
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> bool:
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")

    @property
    @pulumi.getter
    def update(self) -> bool:
        return pulumi.get(self, "update")


@pulumi.output_type
class GetFunctionTriggerTimerResult(dict):
    def __init__(__self__, *,
                 cron_expression: str):
        pulumi.set(__self__, "cron_expression", cron_expression)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")


@pulumi.output_type
class GetIamPolicyBindingResult(dict):
    def __init__(__self__, *,
                 members: Sequence[str],
                 role: str):
        """
        :param Sequence[str] members: An array of identities that will be granted the privilege in the `role`.
               Each entry can have one of the following values:
               * **userAccount:{user_id}**: A unique user ID that represents a specific Yandex account.
               * **serviceAccount:{service_account_id}**: A unique service account ID.
        :param str role: The role/permission that will be granted to the members.
               See the [IAM Roles] documentation for a complete list of roles.
        """
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def members(self) -> Sequence[str]:
        """
        An array of identities that will be granted the privilege in the `role`.
        Each entry can have one of the following values:
        * **userAccount:{user_id}**: A unique user ID that represents a specific Yandex account.
        * **serviceAccount:{service_account_id}**: A unique service account ID.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role/permission that will be granted to the members.
        See the [IAM Roles] documentation for a complete list of roles.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetKubernetesClusterKmsProviderResult(dict):
    def __init__(__self__, *,
                 key_id: str):
        """
        :param str key_id: KMS key ID.
        """
        pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        """
        KMS key ID.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class GetKubernetesClusterMasterResult(dict):
    def __init__(__self__, *,
                 cluster_ca_certificate: str,
                 external_v4_address: str,
                 external_v4_endpoint: str,
                 internal_v4_address: str,
                 internal_v4_endpoint: str,
                 maintenance_policies: Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyResult'],
                 public_ip: bool,
                 regionals: Sequence['outputs.GetKubernetesClusterMasterRegionalResult'],
                 security_group_ids: Sequence[str],
                 version: str,
                 version_infos: Sequence['outputs.GetKubernetesClusterMasterVersionInfoResult'],
                 zonals: Sequence['outputs.GetKubernetesClusterMasterZonalResult']):
        """
        :param str cluster_ca_certificate: PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        :param str external_v4_address: An IPv4 external network address that is assigned to the master.
        :param str external_v4_endpoint: External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        :param str internal_v4_address: An IPv4 internal network address that is assigned to the master.
        :param str internal_v4_endpoint: Internal endpoint that can be used to connect to the master from cloud networks.
        :param Sequence['GetKubernetesClusterMasterMaintenancePolicyArgs'] maintenance_policies: Maintenance policy for Kubernetes master. The structure is documented below.
        :param bool public_ip: Boolean flag. When `true`, Kubernetes master have visible ipv4 address.
        :param Sequence['GetKubernetesClusterMasterRegionalArgs'] regionals: Information about cluster regional master. The structure is documented below.
        :param Sequence[str] security_group_ids: A list of security groups IDs of the Kubernetes cluster.
        :param str version: Version of Kubernetes master.
        :param Sequence['GetKubernetesClusterMasterVersionInfoArgs'] version_infos: Information about cluster version. The structure is documented below.
        :param Sequence['GetKubernetesClusterMasterZonalArgs'] zonals: Information about cluster zonal master. The structure is documented below.
        """
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "external_v4_address", external_v4_address)
        pulumi.set(__self__, "external_v4_endpoint", external_v4_endpoint)
        pulumi.set(__self__, "internal_v4_address", internal_v4_address)
        pulumi.set(__self__, "internal_v4_endpoint", internal_v4_endpoint)
        pulumi.set(__self__, "maintenance_policies", maintenance_policies)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "regionals", regionals)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_infos", version_infos)
        pulumi.set(__self__, "zonals", zonals)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> str:
        """
        PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="externalV4Address")
    def external_v4_address(self) -> str:
        """
        An IPv4 external network address that is assigned to the master.
        """
        return pulumi.get(self, "external_v4_address")

    @property
    @pulumi.getter(name="externalV4Endpoint")
    def external_v4_endpoint(self) -> str:
        """
        External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        return pulumi.get(self, "external_v4_endpoint")

    @property
    @pulumi.getter(name="internalV4Address")
    def internal_v4_address(self) -> str:
        """
        An IPv4 internal network address that is assigned to the master.
        """
        return pulumi.get(self, "internal_v4_address")

    @property
    @pulumi.getter(name="internalV4Endpoint")
    def internal_v4_endpoint(self) -> str:
        """
        Internal endpoint that can be used to connect to the master from cloud networks.
        """
        return pulumi.get(self, "internal_v4_endpoint")

    @property
    @pulumi.getter(name="maintenancePolicies")
    def maintenance_policies(self) -> Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyResult']:
        """
        Maintenance policy for Kubernetes master. The structure is documented below.
        """
        return pulumi.get(self, "maintenance_policies")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> bool:
        """
        Boolean flag. When `true`, Kubernetes master have visible ipv4 address.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def regionals(self) -> Sequence['outputs.GetKubernetesClusterMasterRegionalResult']:
        """
        Information about cluster regional master. The structure is documented below.
        """
        return pulumi.get(self, "regionals")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        A list of security groups IDs of the Kubernetes cluster.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of Kubernetes master.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionInfos")
    def version_infos(self) -> Sequence['outputs.GetKubernetesClusterMasterVersionInfoResult']:
        """
        Information about cluster version. The structure is documented below.
        """
        return pulumi.get(self, "version_infos")

    @property
    @pulumi.getter
    def zonals(self) -> Sequence['outputs.GetKubernetesClusterMasterZonalResult']:
        """
        Information about cluster zonal master. The structure is documented below.
        """
        return pulumi.get(self, "zonals")


@pulumi.output_type
class GetKubernetesClusterMasterMaintenancePolicyResult(dict):
    def __init__(__self__, *,
                 auto_upgrade: bool,
                 maintenance_windows: Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult']):
        """
        :param bool auto_upgrade: Boolean flag that specifies if master can be upgraded automatically.
        :param Sequence['GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: Set of day intervals, when maintenance is allowed, when update for master is allowed.
               When omitted, it defaults to any time.
        """
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> bool:
        """
        Boolean flag that specifies if master can be upgraded automatically.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult']:
        """
        Set of day intervals, when maintenance is allowed, when update for master is allowed.
        When omitted, it defaults to any time.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 duration: str,
                 start_time: str):
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def day(self) -> str:
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def duration(self) -> str:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetKubernetesClusterMasterRegionalResult(dict):
    def __init__(__self__, *,
                 region: str):
        """
        :param str region: ID of the availability region where the master compute instances resides.
        """
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        ID of the availability region where the master compute instances resides.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetKubernetesClusterMasterVersionInfoResult(dict):
    def __init__(__self__, *,
                 current_version: str,
                 new_revision_available: bool,
                 new_revision_summary: str,
                 version_deprecated: bool):
        """
        :param str current_version: Current Kubernetes version, major.minor (e.g. 1.15).
        :param bool new_revision_available: True/false flag.
               Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
               as some internal component updates - new features or bug fixes in yandex-specific
               components either on the master or nodes.
        :param str new_revision_summary: Human readable description of the changes to be applied
               when updating to the latest revision. Empty if new_revision_available is false.
        :param bool version_deprecated: True/false flag. The current version is on the deprecation schedule,
               component (master or node group) should be upgraded.
        """
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "new_revision_available", new_revision_available)
        pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        pulumi.set(__self__, "version_deprecated", version_deprecated)

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> str:
        """
        Current Kubernetes version, major.minor (e.g. 1.15).
        """
        return pulumi.get(self, "current_version")

    @property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> bool:
        """
        True/false flag.
        Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
        as some internal component updates - new features or bug fixes in yandex-specific
        components either on the master or nodes.
        """
        return pulumi.get(self, "new_revision_available")

    @property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> str:
        """
        Human readable description of the changes to be applied
        when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> bool:
        """
        True/false flag. The current version is on the deprecation schedule,
        component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class GetKubernetesClusterMasterZonalResult(dict):
    def __init__(__self__, *,
                 zone: str):
        """
        :param str zone: ID of the availability zone where the master compute instance resides.
        """
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        ID of the availability zone where the master compute instance resides.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetKubernetesClusterNetworkImplementationResult(dict):
    def __init__(__self__, *,
                 cilias: Sequence['outputs.GetKubernetesClusterNetworkImplementationCiliaResult']):
        """
        :param Sequence['GetKubernetesClusterNetworkImplementationCiliaArgs'] cilias: Cilium network implementation configuration. No options exist.
        """
        pulumi.set(__self__, "cilias", cilias)

    @property
    @pulumi.getter
    def cilias(self) -> Sequence['outputs.GetKubernetesClusterNetworkImplementationCiliaResult']:
        """
        Cilium network implementation configuration. No options exist.
        """
        return pulumi.get(self, "cilias")


@pulumi.output_type
class GetKubernetesClusterNetworkImplementationCiliaResult(dict):
    def __init__(__self__, *,
                 routing_mode: str):
        pulumi.set(__self__, "routing_mode", routing_mode)

    @property
    @pulumi.getter(name="routingMode")
    def routing_mode(self) -> str:
        return pulumi.get(self, "routing_mode")


@pulumi.output_type
class GetKubernetesNodeGroupAllocationPolicyResult(dict):
    def __init__(__self__, *,
                 locations: Sequence['outputs.GetKubernetesNodeGroupAllocationPolicyLocationResult']):
        """
        :param Sequence['GetKubernetesNodeGroupAllocationPolicyLocationArgs'] locations: Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
        """
        pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetKubernetesNodeGroupAllocationPolicyLocationResult']:
        """
        Repeated field, that specify subnets (zones), that will be used by node group compute instances. The structure is documented below.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetKubernetesNodeGroupAllocationPolicyLocationResult(dict):
    def __init__(__self__, *,
                 subnet_id: str,
                 zone: str):
        """
        :param str subnet_id: ID of the subnet, that will be used by one compute instance in node group.
        :param str zone: ID of the availability zone where for one compute instance in node group.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        ID of the subnet, that will be used by one compute instance in node group.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        ID of the availability zone where for one compute instance in node group.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetKubernetesNodeGroupDeployPolicyResult(dict):
    def __init__(__self__, *,
                 max_expansion: int,
                 max_unavailable: int):
        """
        :param int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        :param int max_unavailable: The maximum number of running instances that can be taken offline during update.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        """
        return pulumi.get(self, "max_expansion")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        """
        The maximum number of running instances that can be taken offline during update.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateResult(dict):
    def __init__(__self__, *,
                 boot_disks: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateBootDiskResult'],
                 container_runtime: 'outputs.GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult',
                 metadata: Mapping[str, str],
                 nat: bool,
                 network_acceleration_type: str,
                 network_interfaces: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult'],
                 platform_id: str,
                 resources: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateResourceResult'],
                 scheduling_policies: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult'],
                 placement_policies: Optional[Sequence['outputs.GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult']] = None):
        """
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateBootDiskArgs'] boot_disks: The specifications for boot disks that will be attached to the instance. The structure is documented below.
        :param 'GetKubernetesNodeGroupInstanceTemplateContainerRuntimeArgs' container_runtime: Container runtime configuration. The structure is documented below.
               ---
        :param Mapping[str, str] metadata: The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
        :param bool nat: A public address that can be used to access the internet over NAT.
        :param str network_acceleration_type: Type of network acceleration. Values: `standard`, `software_accelerated`.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: An array with the network interfaces that will be attached to the instance. The structure is documented below.
        :param str platform_id: The ID of the hardware platform configuration for the instance.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs'] scheduling_policies: The scheduling policy for the instances in node group. The structure is documented below.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplatePlacementPolicyArgs'] placement_policies: (Optional) The placement policy configuration. The structure is documented below.
        """
        pulumi.set(__self__, "boot_disks", boot_disks)
        pulumi.set(__self__, "container_runtime", container_runtime)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "network_acceleration_type", network_acceleration_type)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "platform_id", platform_id)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "scheduling_policies", scheduling_policies)
        if placement_policies is not None:
            pulumi.set(__self__, "placement_policies", placement_policies)

    @property
    @pulumi.getter(name="bootDisks")
    def boot_disks(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateBootDiskResult']:
        """
        The specifications for boot disks that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "boot_disks")

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> 'outputs.GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult':
        """
        Container runtime configuration. The structure is documented below.
        ---
        """
        return pulumi.get(self, "container_runtime")

    @property
    @pulumi.getter
    def metadata(self) -> Mapping[str, str]:
        """
        The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def nat(self) -> bool:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="networkAccelerationType")
    def network_acceleration_type(self) -> str:
        """
        Type of network acceleration. Values: `standard`, `software_accelerated`.
        """
        return pulumi.get(self, "network_acceleration_type")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult']:
        """
        An array with the network interfaces that will be attached to the instance. The structure is documented below.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> str:
        """
        The ID of the hardware platform configuration for the instance.
        """
        return pulumi.get(self, "platform_id")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateResourceResult']:
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="schedulingPolicies")
    def scheduling_policies(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult']:
        """
        The scheduling policy for the instances in node group. The structure is documented below.
        """
        return pulumi.get(self, "scheduling_policies")

    @property
    @pulumi.getter(name="placementPolicies")
    def placement_policies(self) -> Optional[Sequence['outputs.GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult']]:
        """
        (Optional) The placement policy configuration. The structure is documented below.
        """
        return pulumi.get(self, "placement_policies")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateBootDiskResult(dict):
    def __init__(__self__, *,
                 size: int,
                 type: str):
        """
        :param int size: The number of instances in the node group.
        :param str type: Type of container runtime. Values: `docker`, `containerd`.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The number of instances in the node group.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Type of container runtime. Values: `docker`, `containerd`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 ipv4: bool,
                 ipv6: bool,
                 nat: bool,
                 security_group_ids: Sequence[str],
                 subnet_ids: Sequence[str]):
        """
        :param bool ipv4: Indicates whether the IPv4 address has been assigned.
        :param bool ipv6: Indicates whether the IPv6 address has been assigned.
        :param bool nat: A public address that can be used to access the internet over NAT.
        :param Sequence[str] security_group_ids: Security group ids for network interface.
        :param Sequence[str] subnet_ids: The IDs of the subnets.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter
    def ipv4(self) -> bool:
        """
        Indicates whether the IPv4 address has been assigned.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        """
        Indicates whether the IPv6 address has been assigned.
        """
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter
    def nat(self) -> bool:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult(dict):
    def __init__(__self__, *,
                 placement_group_id: str):
        """
        :param str placement_group_id: (Optional) Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        """
        (Optional) Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateResourceResult(dict):
    def __init__(__self__, *,
                 core_fraction: int,
                 cores: int,
                 gpus: int,
                 memory: float):
        pulumi.set(__self__, "core_fraction", core_fraction)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> int:
        return pulumi.get(self, "core_fraction")

    @property
    @pulumi.getter
    def cores(self) -> int:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def gpus(self) -> int:
        return pulumi.get(self, "gpus")

    @property
    @pulumi.getter
    def memory(self) -> float:
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult(dict):
    def __init__(__self__, *,
                 preemptible: bool):
        """
        :param bool preemptible: Specifies if the instance is preemptible. Defaults to false.
               ---
        """
        pulumi.set(__self__, "preemptible", preemptible)

    @property
    @pulumi.getter
    def preemptible(self) -> bool:
        """
        Specifies if the instance is preemptible. Defaults to false.
        ---
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetKubernetesNodeGroupMaintenancePolicyResult(dict):
    def __init__(__self__, *,
                 auto_repair: bool,
                 auto_upgrade: bool,
                 maintenance_windows: Sequence['outputs.GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult']):
        """
        :param bool auto_repair: Boolean flag.
        :param bool auto_upgrade: Boolean flag.
        :param Sequence['GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: Set of day intervals, when maintenance is allowed for this node group.
               When omitted, it defaults to any time.
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> bool:
        """
        Boolean flag.
        """
        return pulumi.get(self, "auto_repair")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> bool:
        """
        Boolean flag.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult']:
        """
        Set of day intervals, when maintenance is allowed for this node group.
        When omitted, it defaults to any time.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 duration: str,
                 start_time: str):
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def day(self) -> str:
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def duration(self) -> str:
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetKubernetesNodeGroupScalePolicyResult(dict):
    def __init__(__self__, *,
                 auto_scales: Sequence['outputs.GetKubernetesNodeGroupScalePolicyAutoScaleResult'],
                 fixed_scales: Sequence['outputs.GetKubernetesNodeGroupScalePolicyFixedScaleResult']):
        """
        :param Sequence['GetKubernetesNodeGroupScalePolicyAutoScaleArgs'] auto_scales: Scale policy for an autoscaled node group. The structure is documented below.
        :param Sequence['GetKubernetesNodeGroupScalePolicyFixedScaleArgs'] fixed_scales: Scale policy for a fixed scale node group. The structure is documented below.
        """
        pulumi.set(__self__, "auto_scales", auto_scales)
        pulumi.set(__self__, "fixed_scales", fixed_scales)

    @property
    @pulumi.getter(name="autoScales")
    def auto_scales(self) -> Sequence['outputs.GetKubernetesNodeGroupScalePolicyAutoScaleResult']:
        """
        Scale policy for an autoscaled node group. The structure is documented below.
        """
        return pulumi.get(self, "auto_scales")

    @property
    @pulumi.getter(name="fixedScales")
    def fixed_scales(self) -> Sequence['outputs.GetKubernetesNodeGroupScalePolicyFixedScaleResult']:
        """
        Scale policy for a fixed scale node group. The structure is documented below.
        """
        return pulumi.get(self, "fixed_scales")


@pulumi.output_type
class GetKubernetesNodeGroupScalePolicyAutoScaleResult(dict):
    def __init__(__self__, *,
                 initial: int,
                 max: int,
                 min: int):
        """
        :param int initial: Initial number of instances in the node group.
        :param int max: Maximum number of instances in the node group.
        :param int min: Minimum number of instances in the node group.
        """
        pulumi.set(__self__, "initial", initial)
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def initial(self) -> int:
        """
        Initial number of instances in the node group.
        """
        return pulumi.get(self, "initial")

    @property
    @pulumi.getter
    def max(self) -> int:
        """
        Maximum number of instances in the node group.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> int:
        """
        Minimum number of instances in the node group.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetKubernetesNodeGroupScalePolicyFixedScaleResult(dict):
    def __init__(__self__, *,
                 size: int):
        """
        :param int size: The number of instances in the node group.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The number of instances in the node group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetKubernetesNodeGroupVersionInfoResult(dict):
    def __init__(__self__, *,
                 current_version: str,
                 new_revision_available: bool,
                 new_revision_summary: str,
                 version_deprecated: bool):
        """
        :param str current_version: Current Kubernetes version, major.minor (e.g. 1.15).
        :param bool new_revision_available: True/false flag.
               Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
               as some internal component updates - new features or bug fixes in yandex-specific
               components either on the master or nodes.
        :param str new_revision_summary: Human readable description of the changes to be applied
               when updating to the latest revision. Empty if new_revision_available is false.
        :param bool version_deprecated: True/false flag. The current version is on the deprecation schedule,
               component (master or node group) should be upgraded.
        """
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "new_revision_available", new_revision_available)
        pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        pulumi.set(__self__, "version_deprecated", version_deprecated)

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> str:
        """
        Current Kubernetes version, major.minor (e.g. 1.15).
        """
        return pulumi.get(self, "current_version")

    @property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> bool:
        """
        True/false flag.
        Newer revisions may include Kubernetes patches (e.g 1.15.1 > 1.15.2) as well
        as some internal component updates - new features or bug fixes in yandex-specific
        components either on the master or nodes.
        """
        return pulumi.get(self, "new_revision_available")

    @property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> str:
        """
        Human readable description of the changes to be applied
        when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> bool:
        """
        True/false flag. The current version is on the deprecation schedule,
        component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupResult(dict):
    def __init__(__self__, *,
                 healthchecks: Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult'],
                 target_group_id: str):
        """
        :param str target_group_id: ID of the target group that attached to the network load balancer.
               * `healthcheck.0.name` - Name of the health check.
               * `healthcheck.0.interval` - The interval between health checks.
               * `healthcheck.0.timeout` - Timeout for a target to return a response for the health check.
               * `healthcheck.0.unhealthy_threshold` - Number of failed health checks before changing the status to `UNHEALTHY`.
               * `healthcheck.0.healthy_threshold` - Number of successful health checks required in order to set the `HEALTHY` status for the target.
               * `healthcheck.0.tcp_options.0.port` - Port to use for TCP health checks.
               * `healthcheck.0.http_options.0.port` - Port to use for HTTP health checks.
               * `healthcheck.0.http_options.0.path` - URL path to use for HTTP health checks.
        """
        pulumi.set(__self__, "healthchecks", healthchecks)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @property
    @pulumi.getter
    def healthchecks(self) -> Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult']:
        return pulumi.get(self, "healthchecks")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        ID of the target group that attached to the network load balancer.
        * `healthcheck.0.name` - Name of the health check.
        * `healthcheck.0.interval` - The interval between health checks.
        * `healthcheck.0.timeout` - Timeout for a target to return a response for the health check.
        * `healthcheck.0.unhealthy_threshold` - Number of failed health checks before changing the status to `UNHEALTHY`.
        * `healthcheck.0.healthy_threshold` - Number of successful health checks required in order to set the `HEALTHY` status for the target.
        * `healthcheck.0.tcp_options.0.port` - Port to use for TCP health checks.
        * `healthcheck.0.http_options.0.port` - Port to use for HTTP health checks.
        * `healthcheck.0.http_options.0.path` - URL path to use for HTTP health checks.
        """
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult(dict):
    def __init__(__self__, *,
                 healthy_threshold: int,
                 http_options: Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult'],
                 interval: int,
                 name: str,
                 tcp_options: Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult'],
                 timeout: int,
                 unhealthy_threshold: int):
        """
        :param str name: - Name of the network load balancer.
        """
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_options", http_options)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tcp_options", tcp_options)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult']:
        return pulumi.get(self, "http_options")

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Name of the network load balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult']:
        return pulumi.get(self, "tcp_options")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        """
        :param int port: Port for incoming traffic.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult(dict):
    def __init__(__self__, *,
                 port: int):
        """
        :param int port: Port for incoming traffic.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetLbNetworkLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 external_address_specs: Sequence['outputs.GetLbNetworkLoadBalancerListenerExternalAddressSpecResult'],
                 internal_address_specs: Sequence['outputs.GetLbNetworkLoadBalancerListenerInternalAddressSpecResult'],
                 name: str,
                 port: int,
                 protocol: str,
                 target_port: int):
        """
        :param str name: - Name of the network load balancer.
        :param int port: Port for incoming traffic.
        :param str protocol: Protocol for incoming traffic.
        :param int target_port: Port of a target. 
               * `external_address_spec.0.address` - External IP address of a listener.
               * `external_address_spec.0.ip_version` - IP version of the external addresses.
               * `internal_address_spec.0.subnet_id` - Subnet ID to which the internal IP address belongs
               * `internal_address_spec.0.address` - Internal IP address of a listener.
               * `internal_address_spec.0.ip_version` - IP version of the internal addresses.
        """
        pulumi.set(__self__, "external_address_specs", external_address_specs)
        pulumi.set(__self__, "internal_address_specs", internal_address_specs)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter(name="externalAddressSpecs")
    def external_address_specs(self) -> Sequence['outputs.GetLbNetworkLoadBalancerListenerExternalAddressSpecResult']:
        return pulumi.get(self, "external_address_specs")

    @property
    @pulumi.getter(name="internalAddressSpecs")
    def internal_address_specs(self) -> Sequence['outputs.GetLbNetworkLoadBalancerListenerInternalAddressSpecResult']:
        return pulumi.get(self, "internal_address_specs")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - Name of the network load balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol for incoming traffic.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> int:
        """
        Port of a target. 
        * `external_address_spec.0.address` - External IP address of a listener.
        * `external_address_spec.0.ip_version` - IP version of the external addresses.
        * `internal_address_spec.0.subnet_id` - Subnet ID to which the internal IP address belongs
        * `internal_address_spec.0.address` - Internal IP address of a listener.
        * `internal_address_spec.0.ip_version` - IP version of the internal addresses.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetLbNetworkLoadBalancerListenerExternalAddressSpecResult(dict):
    def __init__(__self__, *,
                 address: str,
                 ip_version: str):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ip_version", ip_version)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> str:
        return pulumi.get(self, "ip_version")


@pulumi.output_type
class GetLbNetworkLoadBalancerListenerInternalAddressSpecResult(dict):
    def __init__(__self__, *,
                 address: str,
                 ip_version: str,
                 subnet_id: str):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> str:
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetLbTargetGroupTargetResult(dict):
    def __init__(__self__, *,
                 address: str,
                 subnet_id: str):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetMdbClickhouseClusterAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: bool,
                 metrika: bool,
                 serverless: bool,
                 web_sql: bool):
        """
        :param bool data_lens: Allow access for Web SQL.
        :param bool metrika: Allow access for Yandex.Metrika.
        :param bool serverless: Allow access for Serverless.
        :param bool web_sql: Allow access for DataLens.
        """
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "metrika", metrika)
        pulumi.set(__self__, "serverless", serverless)
        pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> bool:
        """
        Allow access for Web SQL.
        """
        return pulumi.get(self, "data_lens")

    @property
    @pulumi.getter
    def metrika(self) -> bool:
        """
        Allow access for Yandex.Metrika.
        """
        return pulumi.get(self, "metrika")

    @property
    @pulumi.getter
    def serverless(self) -> bool:
        """
        Allow access for Serverless.
        """
        return pulumi.get(self, "serverless")

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> bool:
        """
        Allow access for DataLens.
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class GetMdbClickhouseClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: int,
                 minutes: int):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetMdbClickhouseClusterClickhouseConfigResult',
                 resources: Sequence['outputs.GetMdbClickhouseClusterClickhouseResourceResult']):
        """
        :param 'GetMdbClickhouseClusterClickhouseConfigArgs' config: Main ClickHouse cluster configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseResourceArgs'] resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigResult':
        """
        Main ClickHouse cluster configuration. The structure is documented below.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbClickhouseClusterClickhouseResourceResult']:
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigResult(dict):
    def __init__(__self__, *,
                 kafkas: Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaResult'],
                 merge_tree: 'outputs.GetMdbClickhouseClusterClickhouseConfigMergeTreeResult',
                 rabbitmq: 'outputs.GetMdbClickhouseClusterClickhouseConfigRabbitmqResult',
                 background_pool_size: Optional[int] = None,
                 background_schedule_pool_size: Optional[int] = None,
                 compressions: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigCompressionResult']] = None,
                 geobase_uri: Optional[str] = None,
                 graphite_rollups: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult']] = None,
                 kafka_topics: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult']] = None,
                 keep_alive_timeout: Optional[int] = None,
                 log_level: Optional[str] = None,
                 mark_cache_size: Optional[int] = None,
                 max_concurrent_queries: Optional[int] = None,
                 max_connections: Optional[int] = None,
                 max_partition_size_to_drop: Optional[int] = None,
                 max_table_size_to_drop: Optional[int] = None,
                 metric_log_enabled: Optional[bool] = None,
                 metric_log_retention_size: Optional[int] = None,
                 metric_log_retention_time: Optional[int] = None,
                 part_log_retention_size: Optional[int] = None,
                 part_log_retention_time: Optional[int] = None,
                 query_log_retention_size: Optional[int] = None,
                 query_log_retention_time: Optional[int] = None,
                 query_thread_log_enabled: Optional[bool] = None,
                 query_thread_log_retention_size: Optional[int] = None,
                 query_thread_log_retention_time: Optional[int] = None,
                 text_log_enabled: Optional[bool] = None,
                 text_log_level: Optional[str] = None,
                 text_log_retention_size: Optional[int] = None,
                 text_log_retention_time: Optional[int] = None,
                 timezone: Optional[str] = None,
                 trace_log_enabled: Optional[bool] = None,
                 trace_log_retention_size: Optional[int] = None,
                 trace_log_retention_time: Optional[int] = None,
                 uncompressed_cache_size: Optional[int] = None):
        """
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaArgs'] kafkas: Kafka connection configuration. The structure is documented below.
        :param 'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs' merge_tree: MergeTree engine configuration. The structure is documented below.
        :param 'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs' rabbitmq: RabbitMQ connection configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigCompressionArgs'] compressions: Data compression configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs'] graphite_rollups: Graphite rollup configuration. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs'] kafka_topics: Kafka topic connection configuration. The structure is documented below.
        """
        pulumi.set(__self__, "kafkas", kafkas)
        pulumi.set(__self__, "merge_tree", merge_tree)
        pulumi.set(__self__, "rabbitmq", rabbitmq)
        if background_pool_size is not None:
            pulumi.set(__self__, "background_pool_size", background_pool_size)
        if background_schedule_pool_size is not None:
            pulumi.set(__self__, "background_schedule_pool_size", background_schedule_pool_size)
        if compressions is not None:
            pulumi.set(__self__, "compressions", compressions)
        if geobase_uri is not None:
            pulumi.set(__self__, "geobase_uri", geobase_uri)
        if graphite_rollups is not None:
            pulumi.set(__self__, "graphite_rollups", graphite_rollups)
        if kafka_topics is not None:
            pulumi.set(__self__, "kafka_topics", kafka_topics)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if mark_cache_size is not None:
            pulumi.set(__self__, "mark_cache_size", mark_cache_size)
        if max_concurrent_queries is not None:
            pulumi.set(__self__, "max_concurrent_queries", max_concurrent_queries)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_partition_size_to_drop is not None:
            pulumi.set(__self__, "max_partition_size_to_drop", max_partition_size_to_drop)
        if max_table_size_to_drop is not None:
            pulumi.set(__self__, "max_table_size_to_drop", max_table_size_to_drop)
        if metric_log_enabled is not None:
            pulumi.set(__self__, "metric_log_enabled", metric_log_enabled)
        if metric_log_retention_size is not None:
            pulumi.set(__self__, "metric_log_retention_size", metric_log_retention_size)
        if metric_log_retention_time is not None:
            pulumi.set(__self__, "metric_log_retention_time", metric_log_retention_time)
        if part_log_retention_size is not None:
            pulumi.set(__self__, "part_log_retention_size", part_log_retention_size)
        if part_log_retention_time is not None:
            pulumi.set(__self__, "part_log_retention_time", part_log_retention_time)
        if query_log_retention_size is not None:
            pulumi.set(__self__, "query_log_retention_size", query_log_retention_size)
        if query_log_retention_time is not None:
            pulumi.set(__self__, "query_log_retention_time", query_log_retention_time)
        if query_thread_log_enabled is not None:
            pulumi.set(__self__, "query_thread_log_enabled", query_thread_log_enabled)
        if query_thread_log_retention_size is not None:
            pulumi.set(__self__, "query_thread_log_retention_size", query_thread_log_retention_size)
        if query_thread_log_retention_time is not None:
            pulumi.set(__self__, "query_thread_log_retention_time", query_thread_log_retention_time)
        if text_log_enabled is not None:
            pulumi.set(__self__, "text_log_enabled", text_log_enabled)
        if text_log_level is not None:
            pulumi.set(__self__, "text_log_level", text_log_level)
        if text_log_retention_size is not None:
            pulumi.set(__self__, "text_log_retention_size", text_log_retention_size)
        if text_log_retention_time is not None:
            pulumi.set(__self__, "text_log_retention_time", text_log_retention_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if trace_log_enabled is not None:
            pulumi.set(__self__, "trace_log_enabled", trace_log_enabled)
        if trace_log_retention_size is not None:
            pulumi.set(__self__, "trace_log_retention_size", trace_log_retention_size)
        if trace_log_retention_time is not None:
            pulumi.set(__self__, "trace_log_retention_time", trace_log_retention_time)
        if uncompressed_cache_size is not None:
            pulumi.set(__self__, "uncompressed_cache_size", uncompressed_cache_size)

    @property
    @pulumi.getter
    def kafkas(self) -> Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaResult']:
        """
        Kafka connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafkas")

    @property
    @pulumi.getter(name="mergeTree")
    def merge_tree(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigMergeTreeResult':
        """
        MergeTree engine configuration. The structure is documented below.
        """
        return pulumi.get(self, "merge_tree")

    @property
    @pulumi.getter
    def rabbitmq(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigRabbitmqResult':
        """
        RabbitMQ connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "rabbitmq")

    @property
    @pulumi.getter(name="backgroundPoolSize")
    def background_pool_size(self) -> Optional[int]:
        return pulumi.get(self, "background_pool_size")

    @property
    @pulumi.getter(name="backgroundSchedulePoolSize")
    def background_schedule_pool_size(self) -> Optional[int]:
        return pulumi.get(self, "background_schedule_pool_size")

    @property
    @pulumi.getter
    def compressions(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigCompressionResult']]:
        """
        Data compression configuration. The structure is documented below.
        """
        return pulumi.get(self, "compressions")

    @property
    @pulumi.getter(name="geobaseUri")
    def geobase_uri(self) -> Optional[str]:
        return pulumi.get(self, "geobase_uri")

    @property
    @pulumi.getter(name="graphiteRollups")
    def graphite_rollups(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult']]:
        """
        Graphite rollup configuration. The structure is documented below.
        """
        return pulumi.get(self, "graphite_rollups")

    @property
    @pulumi.getter(name="kafkaTopics")
    def kafka_topics(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult']]:
        """
        Kafka topic connection configuration. The structure is documented below.
        """
        return pulumi.get(self, "kafka_topics")

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[int]:
        return pulumi.get(self, "keep_alive_timeout")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="markCacheSize")
    def mark_cache_size(self) -> Optional[int]:
        return pulumi.get(self, "mark_cache_size")

    @property
    @pulumi.getter(name="maxConcurrentQueries")
    def max_concurrent_queries(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrent_queries")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxPartitionSizeToDrop")
    def max_partition_size_to_drop(self) -> Optional[int]:
        return pulumi.get(self, "max_partition_size_to_drop")

    @property
    @pulumi.getter(name="maxTableSizeToDrop")
    def max_table_size_to_drop(self) -> Optional[int]:
        return pulumi.get(self, "max_table_size_to_drop")

    @property
    @pulumi.getter(name="metricLogEnabled")
    def metric_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "metric_log_enabled")

    @property
    @pulumi.getter(name="metricLogRetentionSize")
    def metric_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "metric_log_retention_size")

    @property
    @pulumi.getter(name="metricLogRetentionTime")
    def metric_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "metric_log_retention_time")

    @property
    @pulumi.getter(name="partLogRetentionSize")
    def part_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "part_log_retention_size")

    @property
    @pulumi.getter(name="partLogRetentionTime")
    def part_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "part_log_retention_time")

    @property
    @pulumi.getter(name="queryLogRetentionSize")
    def query_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "query_log_retention_size")

    @property
    @pulumi.getter(name="queryLogRetentionTime")
    def query_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "query_log_retention_time")

    @property
    @pulumi.getter(name="queryThreadLogEnabled")
    def query_thread_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "query_thread_log_enabled")

    @property
    @pulumi.getter(name="queryThreadLogRetentionSize")
    def query_thread_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "query_thread_log_retention_size")

    @property
    @pulumi.getter(name="queryThreadLogRetentionTime")
    def query_thread_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "query_thread_log_retention_time")

    @property
    @pulumi.getter(name="textLogEnabled")
    def text_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "text_log_enabled")

    @property
    @pulumi.getter(name="textLogLevel")
    def text_log_level(self) -> Optional[str]:
        return pulumi.get(self, "text_log_level")

    @property
    @pulumi.getter(name="textLogRetentionSize")
    def text_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "text_log_retention_size")

    @property
    @pulumi.getter(name="textLogRetentionTime")
    def text_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "text_log_retention_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="traceLogEnabled")
    def trace_log_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "trace_log_enabled")

    @property
    @pulumi.getter(name="traceLogRetentionSize")
    def trace_log_retention_size(self) -> Optional[int]:
        return pulumi.get(self, "trace_log_retention_size")

    @property
    @pulumi.getter(name="traceLogRetentionTime")
    def trace_log_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "trace_log_retention_time")

    @property
    @pulumi.getter(name="uncompressedCacheSize")
    def uncompressed_cache_size(self) -> Optional[int]:
        return pulumi.get(self, "uncompressed_cache_size")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigCompressionResult(dict):
    def __init__(__self__, *,
                 method: str,
                 min_part_size: int,
                 min_part_size_ratio: float):
        """
        :param str method: Method: Compression method. Two methods are available: LZ4 and zstd.
        :param int min_part_size: Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        :param float min_part_size_ratio: Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "min_part_size", min_part_size)
        pulumi.set(__self__, "min_part_size_ratio", min_part_size_ratio)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Method: Compression method. Two methods are available: LZ4 and zstd.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="minPartSize")
    def min_part_size(self) -> int:
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        return pulumi.get(self, "min_part_size")

    @property
    @pulumi.getter(name="minPartSizeRatio")
    def min_part_size_ratio(self) -> float:
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        return pulumi.get(self, "min_part_size_ratio")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 patterns: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult']] = None):
        """
        :param str name: The name of the ClickHouse cluster.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs'] patterns: Set of thinning rules.
        """
        pulumi.set(__self__, "name", name)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult']]:
        """
        Set of thinning rules.
        """
        return pulumi.get(self, "patterns")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult(dict):
    def __init__(__self__, *,
                 function: str,
                 regexp: Optional[str] = None,
                 retentions: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult']] = None):
        """
        :param str function: Aggregation function name.
        :param str regexp: Regular expression that the metric name must match.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs'] retentions: Retain parameters.
        """
        pulumi.set(__self__, "function", function)
        if regexp is not None:
            pulumi.set(__self__, "regexp", regexp)
        if retentions is not None:
            pulumi.set(__self__, "retentions", retentions)

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        Aggregation function name.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def regexp(self) -> Optional[str]:
        """
        Regular expression that the metric name must match.
        """
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def retentions(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult']]:
        """
        Retain parameters.
        """
        return pulumi.get(self, "retentions")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult(dict):
    def __init__(__self__, *,
                 age: int,
                 precision: int):
        """
        :param int age: Minimum data age in seconds.
        :param int precision: Accuracy of determining the age of the data in seconds.
        """
        pulumi.set(__self__, "age", age)
        pulumi.set(__self__, "precision", precision)

    @property
    @pulumi.getter
    def age(self) -> int:
        """
        Minimum data age in seconds.
        """
        return pulumi.get(self, "age")

    @property
    @pulumi.getter
    def precision(self) -> int:
        """
        Accuracy of determining the age of the data in seconds.
        """
        return pulumi.get(self, "precision")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigKafkaResult(dict):
    def __init__(__self__, *,
                 sasl_mechanism: Optional[str] = None,
                 sasl_password: Optional[str] = None,
                 sasl_username: Optional[str] = None,
                 security_protocol: Optional[str] = None):
        """
        :param str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param str sasl_password: User password on kafka server.
        :param str sasl_username: Username on kafka server.
        :param str security_protocol: Security protocol used to connect to kafka server.
        """
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult(dict):
    def __init__(__self__, *,
                 name: str,
                 settings: Optional['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult'] = None):
        """
        :param str name: The name of the ClickHouse cluster.
        :param 'GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs' settings: Kafka connection settngs sanem as `kafka` block.
        """
        pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult']:
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult(dict):
    def __init__(__self__, *,
                 sasl_mechanism: Optional[str] = None,
                 sasl_password: Optional[str] = None,
                 sasl_username: Optional[str] = None,
                 security_protocol: Optional[str] = None):
        """
        :param str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param str sasl_password: User password on kafka server.
        :param str sasl_username: Username on kafka server.
        :param str security_protocol: Security protocol used to connect to kafka server.
        """
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigMergeTreeResult(dict):
    def __init__(__self__, *,
                 max_bytes_to_merge_at_min_space_in_pool: Optional[int] = None,
                 max_replicated_merges_in_queue: Optional[int] = None,
                 number_of_free_entries_in_pool_to_lower_max_size_of_merge: Optional[int] = None,
                 parts_to_delay_insert: Optional[int] = None,
                 parts_to_throw_insert: Optional[int] = None,
                 replicated_deduplication_window: Optional[int] = None,
                 replicated_deduplication_window_seconds: Optional[int] = None):
        """
        :param int max_bytes_to_merge_at_min_space_in_pool: Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        :param int max_replicated_merges_in_queue: Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        :param int number_of_free_entries_in_pool_to_lower_max_size_of_merge: Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        :param int parts_to_delay_insert: Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        :param int parts_to_throw_insert: Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        :param int replicated_deduplication_window: Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        :param int replicated_deduplication_window_seconds: Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        if max_bytes_to_merge_at_min_space_in_pool is not None:
            pulumi.set(__self__, "max_bytes_to_merge_at_min_space_in_pool", max_bytes_to_merge_at_min_space_in_pool)
        if max_replicated_merges_in_queue is not None:
            pulumi.set(__self__, "max_replicated_merges_in_queue", max_replicated_merges_in_queue)
        if number_of_free_entries_in_pool_to_lower_max_size_of_merge is not None:
            pulumi.set(__self__, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", number_of_free_entries_in_pool_to_lower_max_size_of_merge)
        if parts_to_delay_insert is not None:
            pulumi.set(__self__, "parts_to_delay_insert", parts_to_delay_insert)
        if parts_to_throw_insert is not None:
            pulumi.set(__self__, "parts_to_throw_insert", parts_to_throw_insert)
        if replicated_deduplication_window is not None:
            pulumi.set(__self__, "replicated_deduplication_window", replicated_deduplication_window)
        if replicated_deduplication_window_seconds is not None:
            pulumi.set(__self__, "replicated_deduplication_window_seconds", replicated_deduplication_window_seconds)

    @property
    @pulumi.getter(name="maxBytesToMergeAtMinSpaceInPool")
    def max_bytes_to_merge_at_min_space_in_pool(self) -> Optional[int]:
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_min_space_in_pool")

    @property
    @pulumi.getter(name="maxReplicatedMergesInQueue")
    def max_replicated_merges_in_queue(self) -> Optional[int]:
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        return pulumi.get(self, "max_replicated_merges_in_queue")

    @property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge")
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self) -> Optional[int]:
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge")

    @property
    @pulumi.getter(name="partsToDelayInsert")
    def parts_to_delay_insert(self) -> Optional[int]:
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table.
        """
        return pulumi.get(self, "parts_to_delay_insert")

    @property
    @pulumi.getter(name="partsToThrowInsert")
    def parts_to_throw_insert(self) -> Optional[int]:
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        return pulumi.get(self, "parts_to_throw_insert")

    @property
    @pulumi.getter(name="replicatedDeduplicationWindow")
    def replicated_deduplication_window(self) -> Optional[int]:
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window")

    @property
    @pulumi.getter(name="replicatedDeduplicationWindowSeconds")
    def replicated_deduplication_window_seconds(self) -> Optional[int]:
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window_seconds")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigRabbitmqResult(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: RabbitMQ user password.
        :param str username: RabbitMQ username.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        RabbitMQ username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a ClickHouse or ZooKeeper host, in gigabytes.
        :param str disk_type_id: Type of the storage of ClickHouse or ZooKeeper hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a ClickHouse or ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of ClickHouse or ZooKeeper hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbClickhouseClusterCloudStorageResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: (Required) Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        (Required) Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetMdbClickhouseClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the ClickHouse cluster.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbClickhouseClusterFormatSchemaResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 uri: str):
        """
        :param str name: The name of the ClickHouse cluster.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetMdbClickhouseClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: bool,
                 fqdn: str,
                 shard_name: str,
                 subnet_id: str,
                 type: str,
                 zone: str):
        """
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation.
        :param str fqdn: The fully qualified domain name of the host.
        :param str shard_name: The name of the shard to which the host belongs.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str zone: The availability zone where the ClickHouse host will be created.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "shard_name", shard_name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        """
        Sets whether the host should get a public IP address on creation.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> str:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the ClickHouse host will be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbClickhouseClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 hour: int,
                 type: str):
        """
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbClickhouseClusterMlModelResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 uri: str):
        """
        :param str name: The name of the ClickHouse cluster.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetMdbClickhouseClusterShardGroupResult(dict):
    def __init__(__self__, *,
                 description: str,
                 name: str,
                 shard_names: Sequence[str]):
        """
        :param str description: Description of the shard group.
        :param str name: The name of the ClickHouse cluster.
        :param Sequence[str] shard_names: List of shards names that belong to the shard group.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "shard_names", shard_names)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the shard group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="shardNames")
    def shard_names(self) -> Sequence[str]:
        """
        List of shards names that belong to the shard group.
        """
        return pulumi.get(self, "shard_names")


@pulumi.output_type
class GetMdbClickhouseClusterUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence['outputs.GetMdbClickhouseClusterUserPermissionResult'],
                 quotas: Sequence['outputs.GetMdbClickhouseClusterUserQuotaResult'],
                 settings: 'outputs.GetMdbClickhouseClusterUserSettingsResult'):
        """
        :param str name: The name of the ClickHouse cluster.
        :param Sequence['GetMdbClickhouseClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        :param Sequence['GetMdbClickhouseClusterUserQuotaArgs'] quotas: Set of user quotas. The structure is documented below.
        :param 'GetMdbClickhouseClusterUserSettingsArgs' settings: Kafka connection settngs sanem as `kafka` block.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "quotas", quotas)
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ClickHouse cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbClickhouseClusterUserPermissionResult']:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def quotas(self) -> Sequence['outputs.GetMdbClickhouseClusterUserQuotaResult']:
        """
        Set of user quotas. The structure is documented below.
        """
        return pulumi.get(self, "quotas")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetMdbClickhouseClusterUserSettingsResult':
        """
        Kafka connection settngs sanem as `kafka` block.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetMdbClickhouseClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: str):
        """
        :param str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetMdbClickhouseClusterUserQuotaResult(dict):
    def __init__(__self__, *,
                 errors: int,
                 execution_time: int,
                 interval_duration: int,
                 queries: int,
                 read_rows: int,
                 result_rows: int):
        """
        :param int errors: The number of queries that threw exception.
        :param int execution_time: The total query execution time, in milliseconds (wall time).
        :param int interval_duration: Duration of interval for quota in milliseconds.
        :param int queries: The total number of queries.
        :param int read_rows: The total number of source rows read from tables for running the query, on all remote servers.
        :param int result_rows: The total number of rows given as the result.
        """
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "execution_time", execution_time)
        pulumi.set(__self__, "interval_duration", interval_duration)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "read_rows", read_rows)
        pulumi.set(__self__, "result_rows", result_rows)

    @property
    @pulumi.getter
    def errors(self) -> int:
        """
        The number of queries that threw exception.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> int:
        """
        The total query execution time, in milliseconds (wall time).
        """
        return pulumi.get(self, "execution_time")

    @property
    @pulumi.getter(name="intervalDuration")
    def interval_duration(self) -> int:
        """
        Duration of interval for quota in milliseconds.
        """
        return pulumi.get(self, "interval_duration")

    @property
    @pulumi.getter
    def queries(self) -> int:
        """
        The total number of queries.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="readRows")
    def read_rows(self) -> int:
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        return pulumi.get(self, "read_rows")

    @property
    @pulumi.getter(name="resultRows")
    def result_rows(self) -> int:
        """
        The total number of rows given as the result.
        """
        return pulumi.get(self, "result_rows")


@pulumi.output_type
class GetMdbClickhouseClusterUserSettingsResult(dict):
    def __init__(__self__, *,
                 add_http_cors_header: bool,
                 allow_ddl: bool,
                 compile: bool,
                 compile_expressions: bool,
                 connect_timeout: int,
                 count_distinct_implementation: str,
                 distinct_overflow_mode: str,
                 distributed_aggregation_memory_efficient: bool,
                 distributed_ddl_task_timeout: int,
                 distributed_product_mode: str,
                 empty_result_for_aggregation_by_empty_set: bool,
                 enable_http_compression: bool,
                 fallback_to_stale_replicas_for_distributed_queries: bool,
                 force_index_by_date: bool,
                 force_primary_key: bool,
                 group_by_overflow_mode: str,
                 group_by_two_level_threshold: int,
                 group_by_two_level_threshold_bytes: int,
                 http_connection_timeout: int,
                 http_headers_progress_interval: int,
                 http_receive_timeout: int,
                 http_send_timeout: int,
                 input_format_defaults_for_omitted_fields: bool,
                 input_format_values_interpret_expressions: bool,
                 insert_quorum: int,
                 insert_quorum_timeout: int,
                 join_overflow_mode: str,
                 join_use_nulls: bool,
                 joined_subquery_requires_alias: bool,
                 low_cardinality_allow_in_native_format: bool,
                 max_ast_depth: int,
                 max_ast_elements: int,
                 max_block_size: int,
                 max_bytes_before_external_group_by: int,
                 max_bytes_before_external_sort: int,
                 max_bytes_in_distinct: int,
                 max_bytes_in_join: int,
                 max_bytes_in_set: int,
                 max_bytes_to_read: int,
                 max_bytes_to_sort: int,
                 max_bytes_to_transfer: int,
                 max_columns_to_read: int,
                 max_execution_time: int,
                 max_expanded_ast_elements: int,
                 max_insert_block_size: int,
                 max_memory_usage: int,
                 max_memory_usage_for_user: int,
                 max_network_bandwidth: int,
                 max_network_bandwidth_for_user: int,
                 max_query_size: int,
                 max_replica_delay_for_distributed_queries: int,
                 max_result_bytes: int,
                 max_result_rows: int,
                 max_rows_in_distinct: int,
                 max_rows_in_join: int,
                 max_rows_in_set: int,
                 max_rows_to_group_by: int,
                 max_rows_to_read: int,
                 max_rows_to_sort: int,
                 max_rows_to_transfer: int,
                 max_temporary_columns: int,
                 max_temporary_non_const_columns: int,
                 max_threads: int,
                 merge_tree_max_bytes_to_use_cache: int,
                 merge_tree_max_rows_to_use_cache: int,
                 merge_tree_min_bytes_for_concurrent_read: int,
                 merge_tree_min_rows_for_concurrent_read: int,
                 min_bytes_to_use_direct_io: int,
                 min_count_to_compile: int,
                 min_count_to_compile_expression: int,
                 min_execution_speed: int,
                 min_execution_speed_bytes: int,
                 min_insert_block_size_bytes: int,
                 min_insert_block_size_rows: int,
                 output_format_json_quote64bit_integers: bool,
                 output_format_json_quote_denormals: bool,
                 priority: int,
                 quota_mode: str,
                 read_overflow_mode: str,
                 readonly: int,
                 receive_timeout: int,
                 replication_alter_partitions_sync: int,
                 result_overflow_mode: str,
                 select_sequential_consistency: bool,
                 send_progress_in_http_headers: bool,
                 send_timeout: int,
                 set_overflow_mode: str,
                 skip_unavailable_shards: bool,
                 sort_overflow_mode: str,
                 timeout_overflow_mode: str,
                 transfer_overflow_mode: str,
                 transform_null_in: bool,
                 use_uncompressed_cache: bool):
        """
        :param bool add_http_cors_header: Include CORS headers in HTTP responces.
        :param bool allow_ddl: Allows or denies DDL queries.
        :param bool compile: Enable compilation of queries.
        :param bool compile_expressions: Turn on expression compilation.
        :param int connect_timeout: Connect timeout in milliseconds on the socket used for communicating with the client.
        :param str count_distinct_implementation: Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT …) construction.
        :param str distinct_overflow_mode: Sets behaviour on overflow when using DISTINCT. Possible values:
        :param bool distributed_aggregation_memory_efficient: Determine the behavior of distributed subqueries.
        :param int distributed_ddl_task_timeout: Timeout for DDL queries, in milliseconds.
        :param str distributed_product_mode: Changes the behaviour of distributed subqueries.
        :param bool empty_result_for_aggregation_by_empty_set: Allows to retunr empty result.
        :param bool enable_http_compression: Enables or disables data compression in the response to an HTTP request.
        :param bool fallback_to_stale_replicas_for_distributed_queries: Forces a query to an out-of-date replica if updated data is not available.
        :param bool force_index_by_date: Disables query execution if the index can’t be used by date.
        :param bool force_primary_key: Disables query execution if indexing by the primary key is not possible.
        :param str group_by_overflow_mode: Sets behaviour on overflow while GROUP BY operation. Possible values:
        :param int group_by_two_level_threshold: Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        :param int group_by_two_level_threshold_bytes: Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        :param int http_connection_timeout: Timeout for HTTP connection in milliseconds.
        :param int http_headers_progress_interval: Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        :param int http_receive_timeout: Timeout for HTTP connection in milliseconds.
        :param int http_send_timeout: Timeout for HTTP connection in milliseconds.
        :param bool input_format_defaults_for_omitted_fields: When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        :param bool input_format_values_interpret_expressions: Enables or disables the full SQL parser if the fast stream parser can’t parse the data.
        :param int insert_quorum: Enables the quorum writes.
        :param int insert_quorum_timeout: Write to a quorum timeout in milliseconds.
        :param str join_overflow_mode: Sets behaviour on overflow in JOIN. Possible values:
        :param bool join_use_nulls: Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        :param bool joined_subquery_requires_alias: Require aliases for subselects and table functions in FROM that more than one table is present.
        :param bool low_cardinality_allow_in_native_format: Allows or restricts using the LowCardinality data type with the Native format.
        :param int max_ast_depth: Maximum abstract syntax tree depth.
        :param int max_ast_elements: Maximum abstract syntax tree elements.
        :param int max_block_size: A recommendation for what size of the block (in a count of rows) to load from tables.
        :param int max_bytes_before_external_group_by: Limit in bytes for using memoru for GROUP BY before using swap on disk.
        :param int max_bytes_before_external_sort: This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        :param int max_bytes_in_distinct: Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        :param int max_bytes_in_join: Limit on maximum size of the hash table for JOIN, in bytes.
        :param int max_bytes_in_set: Limit on the number of bytes in the set resulting from the execution of the IN section.
        :param int max_bytes_to_read: Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        :param int max_bytes_to_sort: Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        :param int max_bytes_to_transfer: Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param int max_columns_to_read: Limits the maximum number of columns that can be read from a table in a single query.
        :param int max_execution_time: Limits the maximum query execution time in milliseconds.
        :param int max_expanded_ast_elements: Maximum abstract syntax tree depth after after expansion of aliases.
        :param int max_insert_block_size: The size of blocks (in a count of rows) to form for insertion into a table.
        :param int max_memory_usage: Limits the maximum memory usage (in bytes) for processing queries on a single server.
        :param int max_memory_usage_for_user: Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        :param int max_network_bandwidth: Limits the speed of the data exchange over the network in bytes per second.
        :param int max_network_bandwidth_for_user: Limits the speed of the data exchange over the network in bytes per second.
        :param int max_query_size: The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        :param int max_replica_delay_for_distributed_queries: Disables lagging replicas for distributed queries.
        :param int max_result_bytes: Limits the number of bytes in the result.
        :param int max_result_rows: Limits the number of rows in the result.
        :param int max_rows_in_distinct: Limits the maximum number of different rows when using DISTINCT.
        :param int max_rows_in_join: Limit on maximum size of the hash table for JOIN, in rows.
        :param int max_rows_in_set: Limit on the number of rows in the set resulting from the execution of the IN section.
        :param int max_rows_to_group_by: Limits the maximum number of unique keys received from aggregation function.
        :param int max_rows_to_read: Limits the maximum number of rows that can be read from a table when running a query.
        :param int max_rows_to_sort: Limits the maximum number of rows that can be read from a table for sorting.
        :param int max_rows_to_transfer: Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param int max_temporary_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        :param int max_temporary_non_const_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        :param int max_threads: The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        :param int merge_tree_max_bytes_to_use_cache: If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesn’t use the cache of uncompressed blocks.
        :param int merge_tree_max_rows_to_use_cache: If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesn’t use the cache of uncompressed blocks.
        :param int merge_tree_min_bytes_for_concurrent_read: If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        :param int merge_tree_min_rows_for_concurrent_read: If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        :param int min_bytes_to_use_direct_io: The minimum data volume required for using direct I/O access to the storage disk.
        :param int min_count_to_compile: How many times to potentially use a compiled chunk of code before running compilation.
        :param int min_count_to_compile_expression: A query waits for expression compilation process to complete prior to continuing execution.
        :param int min_execution_speed: Minimal execution speed in rows per second.
        :param int min_execution_speed_bytes: Minimal execution speed in bytes per second.
        :param int min_insert_block_size_bytes: Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        :param int min_insert_block_size_rows: Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        :param bool output_format_json_quote64bit_integers: If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        :param bool output_format_json_quote_denormals: Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        :param int priority: Query priority.
        :param str quota_mode: Quota accounting mode.
        :param str read_overflow_mode: Sets behaviour on overflow while read. Possible values:
        :param int readonly: Restricts permissions for reading data, write data and change settings queries.
        :param int receive_timeout: Receive timeout in milliseconds on the socket used for communicating with the client.
        :param int replication_alter_partitions_sync: For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        :param str result_overflow_mode: Sets behaviour on overflow in result. Possible values:
        :param bool select_sequential_consistency: Enables or disables sequential consistency for SELECT queries.
        :param bool send_progress_in_http_headers: Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        :param int send_timeout: Send timeout in milliseconds on the socket used for communicating with the client.
        :param str set_overflow_mode: Sets behaviour on overflow in the set resulting. Possible values:
        :param bool skip_unavailable_shards: Enables or disables silently skipping of unavailable shards.
        :param str sort_overflow_mode: Sets behaviour on overflow while sort. Possible values:
        :param str timeout_overflow_mode: Sets behaviour on overflow. Possible values:
        :param str transfer_overflow_mode: Sets behaviour on overflow. Possible values:
        :param bool transform_null_in: Enables equality of NULL values for IN operator.
        :param bool use_uncompressed_cache: Whether to use a cache of uncompressed blocks.
        """
        pulumi.set(__self__, "add_http_cors_header", add_http_cors_header)
        pulumi.set(__self__, "allow_ddl", allow_ddl)
        pulumi.set(__self__, "compile", compile)
        pulumi.set(__self__, "compile_expressions", compile_expressions)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "count_distinct_implementation", count_distinct_implementation)
        pulumi.set(__self__, "distinct_overflow_mode", distinct_overflow_mode)
        pulumi.set(__self__, "distributed_aggregation_memory_efficient", distributed_aggregation_memory_efficient)
        pulumi.set(__self__, "distributed_ddl_task_timeout", distributed_ddl_task_timeout)
        pulumi.set(__self__, "distributed_product_mode", distributed_product_mode)
        pulumi.set(__self__, "empty_result_for_aggregation_by_empty_set", empty_result_for_aggregation_by_empty_set)
        pulumi.set(__self__, "enable_http_compression", enable_http_compression)
        pulumi.set(__self__, "fallback_to_stale_replicas_for_distributed_queries", fallback_to_stale_replicas_for_distributed_queries)
        pulumi.set(__self__, "force_index_by_date", force_index_by_date)
        pulumi.set(__self__, "force_primary_key", force_primary_key)
        pulumi.set(__self__, "group_by_overflow_mode", group_by_overflow_mode)
        pulumi.set(__self__, "group_by_two_level_threshold", group_by_two_level_threshold)
        pulumi.set(__self__, "group_by_two_level_threshold_bytes", group_by_two_level_threshold_bytes)
        pulumi.set(__self__, "http_connection_timeout", http_connection_timeout)
        pulumi.set(__self__, "http_headers_progress_interval", http_headers_progress_interval)
        pulumi.set(__self__, "http_receive_timeout", http_receive_timeout)
        pulumi.set(__self__, "http_send_timeout", http_send_timeout)
        pulumi.set(__self__, "input_format_defaults_for_omitted_fields", input_format_defaults_for_omitted_fields)
        pulumi.set(__self__, "input_format_values_interpret_expressions", input_format_values_interpret_expressions)
        pulumi.set(__self__, "insert_quorum", insert_quorum)
        pulumi.set(__self__, "insert_quorum_timeout", insert_quorum_timeout)
        pulumi.set(__self__, "join_overflow_mode", join_overflow_mode)
        pulumi.set(__self__, "join_use_nulls", join_use_nulls)
        pulumi.set(__self__, "joined_subquery_requires_alias", joined_subquery_requires_alias)
        pulumi.set(__self__, "low_cardinality_allow_in_native_format", low_cardinality_allow_in_native_format)
        pulumi.set(__self__, "max_ast_depth", max_ast_depth)
        pulumi.set(__self__, "max_ast_elements", max_ast_elements)
        pulumi.set(__self__, "max_block_size", max_block_size)
        pulumi.set(__self__, "max_bytes_before_external_group_by", max_bytes_before_external_group_by)
        pulumi.set(__self__, "max_bytes_before_external_sort", max_bytes_before_external_sort)
        pulumi.set(__self__, "max_bytes_in_distinct", max_bytes_in_distinct)
        pulumi.set(__self__, "max_bytes_in_join", max_bytes_in_join)
        pulumi.set(__self__, "max_bytes_in_set", max_bytes_in_set)
        pulumi.set(__self__, "max_bytes_to_read", max_bytes_to_read)
        pulumi.set(__self__, "max_bytes_to_sort", max_bytes_to_sort)
        pulumi.set(__self__, "max_bytes_to_transfer", max_bytes_to_transfer)
        pulumi.set(__self__, "max_columns_to_read", max_columns_to_read)
        pulumi.set(__self__, "max_execution_time", max_execution_time)
        pulumi.set(__self__, "max_expanded_ast_elements", max_expanded_ast_elements)
        pulumi.set(__self__, "max_insert_block_size", max_insert_block_size)
        pulumi.set(__self__, "max_memory_usage", max_memory_usage)
        pulumi.set(__self__, "max_memory_usage_for_user", max_memory_usage_for_user)
        pulumi.set(__self__, "max_network_bandwidth", max_network_bandwidth)
        pulumi.set(__self__, "max_network_bandwidth_for_user", max_network_bandwidth_for_user)
        pulumi.set(__self__, "max_query_size", max_query_size)
        pulumi.set(__self__, "max_replica_delay_for_distributed_queries", max_replica_delay_for_distributed_queries)
        pulumi.set(__self__, "max_result_bytes", max_result_bytes)
        pulumi.set(__self__, "max_result_rows", max_result_rows)
        pulumi.set(__self__, "max_rows_in_distinct", max_rows_in_distinct)
        pulumi.set(__self__, "max_rows_in_join", max_rows_in_join)
        pulumi.set(__self__, "max_rows_in_set", max_rows_in_set)
        pulumi.set(__self__, "max_rows_to_group_by", max_rows_to_group_by)
        pulumi.set(__self__, "max_rows_to_read", max_rows_to_read)
        pulumi.set(__self__, "max_rows_to_sort", max_rows_to_sort)
        pulumi.set(__self__, "max_rows_to_transfer", max_rows_to_transfer)
        pulumi.set(__self__, "max_temporary_columns", max_temporary_columns)
        pulumi.set(__self__, "max_temporary_non_const_columns", max_temporary_non_const_columns)
        pulumi.set(__self__, "max_threads", max_threads)
        pulumi.set(__self__, "merge_tree_max_bytes_to_use_cache", merge_tree_max_bytes_to_use_cache)
        pulumi.set(__self__, "merge_tree_max_rows_to_use_cache", merge_tree_max_rows_to_use_cache)
        pulumi.set(__self__, "merge_tree_min_bytes_for_concurrent_read", merge_tree_min_bytes_for_concurrent_read)
        pulumi.set(__self__, "merge_tree_min_rows_for_concurrent_read", merge_tree_min_rows_for_concurrent_read)
        pulumi.set(__self__, "min_bytes_to_use_direct_io", min_bytes_to_use_direct_io)
        pulumi.set(__self__, "min_count_to_compile", min_count_to_compile)
        pulumi.set(__self__, "min_count_to_compile_expression", min_count_to_compile_expression)
        pulumi.set(__self__, "min_execution_speed", min_execution_speed)
        pulumi.set(__self__, "min_execution_speed_bytes", min_execution_speed_bytes)
        pulumi.set(__self__, "min_insert_block_size_bytes", min_insert_block_size_bytes)
        pulumi.set(__self__, "min_insert_block_size_rows", min_insert_block_size_rows)
        pulumi.set(__self__, "output_format_json_quote64bit_integers", output_format_json_quote64bit_integers)
        pulumi.set(__self__, "output_format_json_quote_denormals", output_format_json_quote_denormals)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "quota_mode", quota_mode)
        pulumi.set(__self__, "read_overflow_mode", read_overflow_mode)
        pulumi.set(__self__, "readonly", readonly)
        pulumi.set(__self__, "receive_timeout", receive_timeout)
        pulumi.set(__self__, "replication_alter_partitions_sync", replication_alter_partitions_sync)
        pulumi.set(__self__, "result_overflow_mode", result_overflow_mode)
        pulumi.set(__self__, "select_sequential_consistency", select_sequential_consistency)
        pulumi.set(__self__, "send_progress_in_http_headers", send_progress_in_http_headers)
        pulumi.set(__self__, "send_timeout", send_timeout)
        pulumi.set(__self__, "set_overflow_mode", set_overflow_mode)
        pulumi.set(__self__, "skip_unavailable_shards", skip_unavailable_shards)
        pulumi.set(__self__, "sort_overflow_mode", sort_overflow_mode)
        pulumi.set(__self__, "timeout_overflow_mode", timeout_overflow_mode)
        pulumi.set(__self__, "transfer_overflow_mode", transfer_overflow_mode)
        pulumi.set(__self__, "transform_null_in", transform_null_in)
        pulumi.set(__self__, "use_uncompressed_cache", use_uncompressed_cache)

    @property
    @pulumi.getter(name="addHttpCorsHeader")
    def add_http_cors_header(self) -> bool:
        """
        Include CORS headers in HTTP responces.
        """
        return pulumi.get(self, "add_http_cors_header")

    @property
    @pulumi.getter(name="allowDdl")
    def allow_ddl(self) -> bool:
        """
        Allows or denies DDL queries.
        """
        return pulumi.get(self, "allow_ddl")

    @property
    @pulumi.getter
    def compile(self) -> bool:
        """
        Enable compilation of queries.
        """
        return pulumi.get(self, "compile")

    @property
    @pulumi.getter(name="compileExpressions")
    def compile_expressions(self) -> bool:
        """
        Turn on expression compilation.
        """
        return pulumi.get(self, "compile_expressions")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="countDistinctImplementation")
    def count_distinct_implementation(self) -> str:
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT …) construction.
        """
        return pulumi.get(self, "count_distinct_implementation")

    @property
    @pulumi.getter(name="distinctOverflowMode")
    def distinct_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow when using DISTINCT. Possible values:
        """
        return pulumi.get(self, "distinct_overflow_mode")

    @property
    @pulumi.getter(name="distributedAggregationMemoryEfficient")
    def distributed_aggregation_memory_efficient(self) -> bool:
        """
        Determine the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_aggregation_memory_efficient")

    @property
    @pulumi.getter(name="distributedDdlTaskTimeout")
    def distributed_ddl_task_timeout(self) -> int:
        """
        Timeout for DDL queries, in milliseconds.
        """
        return pulumi.get(self, "distributed_ddl_task_timeout")

    @property
    @pulumi.getter(name="distributedProductMode")
    def distributed_product_mode(self) -> str:
        """
        Changes the behaviour of distributed subqueries.
        """
        return pulumi.get(self, "distributed_product_mode")

    @property
    @pulumi.getter(name="emptyResultForAggregationByEmptySet")
    def empty_result_for_aggregation_by_empty_set(self) -> bool:
        """
        Allows to retunr empty result.
        """
        return pulumi.get(self, "empty_result_for_aggregation_by_empty_set")

    @property
    @pulumi.getter(name="enableHttpCompression")
    def enable_http_compression(self) -> bool:
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        return pulumi.get(self, "enable_http_compression")

    @property
    @pulumi.getter(name="fallbackToStaleReplicasForDistributedQueries")
    def fallback_to_stale_replicas_for_distributed_queries(self) -> bool:
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        return pulumi.get(self, "fallback_to_stale_replicas_for_distributed_queries")

    @property
    @pulumi.getter(name="forceIndexByDate")
    def force_index_by_date(self) -> bool:
        """
        Disables query execution if the index can’t be used by date.
        """
        return pulumi.get(self, "force_index_by_date")

    @property
    @pulumi.getter(name="forcePrimaryKey")
    def force_primary_key(self) -> bool:
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        return pulumi.get(self, "force_primary_key")

    @property
    @pulumi.getter(name="groupByOverflowMode")
    def group_by_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow while GROUP BY operation. Possible values:
        """
        return pulumi.get(self, "group_by_overflow_mode")

    @property
    @pulumi.getter(name="groupByTwoLevelThreshold")
    def group_by_two_level_threshold(self) -> int:
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold")

    @property
    @pulumi.getter(name="groupByTwoLevelThresholdBytes")
    def group_by_two_level_threshold_bytes(self) -> int:
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold_bytes")

    @property
    @pulumi.getter(name="httpConnectionTimeout")
    def http_connection_timeout(self) -> int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_connection_timeout")

    @property
    @pulumi.getter(name="httpHeadersProgressInterval")
    def http_headers_progress_interval(self) -> int:
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        return pulumi.get(self, "http_headers_progress_interval")

    @property
    @pulumi.getter(name="httpReceiveTimeout")
    def http_receive_timeout(self) -> int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_receive_timeout")

    @property
    @pulumi.getter(name="httpSendTimeout")
    def http_send_timeout(self) -> int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_send_timeout")

    @property
    @pulumi.getter(name="inputFormatDefaultsForOmittedFields")
    def input_format_defaults_for_omitted_fields(self) -> bool:
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        return pulumi.get(self, "input_format_defaults_for_omitted_fields")

    @property
    @pulumi.getter(name="inputFormatValuesInterpretExpressions")
    def input_format_values_interpret_expressions(self) -> bool:
        """
        Enables or disables the full SQL parser if the fast stream parser can’t parse the data.
        """
        return pulumi.get(self, "input_format_values_interpret_expressions")

    @property
    @pulumi.getter(name="insertQuorum")
    def insert_quorum(self) -> int:
        """
        Enables the quorum writes.
        """
        return pulumi.get(self, "insert_quorum")

    @property
    @pulumi.getter(name="insertQuorumTimeout")
    def insert_quorum_timeout(self) -> int:
        """
        Write to a quorum timeout in milliseconds.
        """
        return pulumi.get(self, "insert_quorum_timeout")

    @property
    @pulumi.getter(name="joinOverflowMode")
    def join_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow in JOIN. Possible values:
        """
        return pulumi.get(self, "join_overflow_mode")

    @property
    @pulumi.getter(name="joinUseNulls")
    def join_use_nulls(self) -> bool:
        """
        Sets the type of JOIN behaviour. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        return pulumi.get(self, "join_use_nulls")

    @property
    @pulumi.getter(name="joinedSubqueryRequiresAlias")
    def joined_subquery_requires_alias(self) -> bool:
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        return pulumi.get(self, "joined_subquery_requires_alias")

    @property
    @pulumi.getter(name="lowCardinalityAllowInNativeFormat")
    def low_cardinality_allow_in_native_format(self) -> bool:
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        return pulumi.get(self, "low_cardinality_allow_in_native_format")

    @property
    @pulumi.getter(name="maxAstDepth")
    def max_ast_depth(self) -> int:
        """
        Maximum abstract syntax tree depth.
        """
        return pulumi.get(self, "max_ast_depth")

    @property
    @pulumi.getter(name="maxAstElements")
    def max_ast_elements(self) -> int:
        """
        Maximum abstract syntax tree elements.
        """
        return pulumi.get(self, "max_ast_elements")

    @property
    @pulumi.getter(name="maxBlockSize")
    def max_block_size(self) -> int:
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        return pulumi.get(self, "max_block_size")

    @property
    @pulumi.getter(name="maxBytesBeforeExternalGroupBy")
    def max_bytes_before_external_group_by(self) -> int:
        """
        Limit in bytes for using memoru for GROUP BY before using swap on disk.
        """
        return pulumi.get(self, "max_bytes_before_external_group_by")

    @property
    @pulumi.getter(name="maxBytesBeforeExternalSort")
    def max_bytes_before_external_sort(self) -> int:
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        return pulumi.get(self, "max_bytes_before_external_sort")

    @property
    @pulumi.getter(name="maxBytesInDistinct")
    def max_bytes_in_distinct(self) -> int:
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        return pulumi.get(self, "max_bytes_in_distinct")

    @property
    @pulumi.getter(name="maxBytesInJoin")
    def max_bytes_in_join(self) -> int:
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        return pulumi.get(self, "max_bytes_in_join")

    @property
    @pulumi.getter(name="maxBytesInSet")
    def max_bytes_in_set(self) -> int:
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_bytes_in_set")

    @property
    @pulumi.getter(name="maxBytesToRead")
    def max_bytes_to_read(self) -> int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_bytes_to_read")

    @property
    @pulumi.getter(name="maxBytesToSort")
    def max_bytes_to_sort(self) -> int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_bytes_to_sort")

    @property
    @pulumi.getter(name="maxBytesToTransfer")
    def max_bytes_to_transfer(self) -> int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_bytes_to_transfer")

    @property
    @pulumi.getter(name="maxColumnsToRead")
    def max_columns_to_read(self) -> int:
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        return pulumi.get(self, "max_columns_to_read")

    @property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> int:
        """
        Limits the maximum query execution time in milliseconds.
        """
        return pulumi.get(self, "max_execution_time")

    @property
    @pulumi.getter(name="maxExpandedAstElements")
    def max_expanded_ast_elements(self) -> int:
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        return pulumi.get(self, "max_expanded_ast_elements")

    @property
    @pulumi.getter(name="maxInsertBlockSize")
    def max_insert_block_size(self) -> int:
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        return pulumi.get(self, "max_insert_block_size")

    @property
    @pulumi.getter(name="maxMemoryUsage")
    def max_memory_usage(self) -> int:
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage")

    @property
    @pulumi.getter(name="maxMemoryUsageForUser")
    def max_memory_usage_for_user(self) -> int:
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage_for_user")

    @property
    @pulumi.getter(name="maxNetworkBandwidth")
    def max_network_bandwidth(self) -> int:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth")

    @property
    @pulumi.getter(name="maxNetworkBandwidthForUser")
    def max_network_bandwidth_for_user(self) -> int:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth_for_user")

    @property
    @pulumi.getter(name="maxQuerySize")
    def max_query_size(self) -> int:
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        return pulumi.get(self, "max_query_size")

    @property
    @pulumi.getter(name="maxReplicaDelayForDistributedQueries")
    def max_replica_delay_for_distributed_queries(self) -> int:
        """
        Disables lagging replicas for distributed queries.
        """
        return pulumi.get(self, "max_replica_delay_for_distributed_queries")

    @property
    @pulumi.getter(name="maxResultBytes")
    def max_result_bytes(self) -> int:
        """
        Limits the number of bytes in the result.
        """
        return pulumi.get(self, "max_result_bytes")

    @property
    @pulumi.getter(name="maxResultRows")
    def max_result_rows(self) -> int:
        """
        Limits the number of rows in the result.
        """
        return pulumi.get(self, "max_result_rows")

    @property
    @pulumi.getter(name="maxRowsInDistinct")
    def max_rows_in_distinct(self) -> int:
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        return pulumi.get(self, "max_rows_in_distinct")

    @property
    @pulumi.getter(name="maxRowsInJoin")
    def max_rows_in_join(self) -> int:
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        return pulumi.get(self, "max_rows_in_join")

    @property
    @pulumi.getter(name="maxRowsInSet")
    def max_rows_in_set(self) -> int:
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_rows_in_set")

    @property
    @pulumi.getter(name="maxRowsToGroupBy")
    def max_rows_to_group_by(self) -> int:
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        return pulumi.get(self, "max_rows_to_group_by")

    @property
    @pulumi.getter(name="maxRowsToRead")
    def max_rows_to_read(self) -> int:
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_rows_to_read")

    @property
    @pulumi.getter(name="maxRowsToSort")
    def max_rows_to_sort(self) -> int:
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_rows_to_sort")

    @property
    @pulumi.getter(name="maxRowsToTransfer")
    def max_rows_to_transfer(self) -> int:
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_rows_to_transfer")

    @property
    @pulumi.getter(name="maxTemporaryColumns")
    def max_temporary_columns(self) -> int:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        return pulumi.get(self, "max_temporary_columns")

    @property
    @pulumi.getter(name="maxTemporaryNonConstColumns")
    def max_temporary_non_const_columns(self) -> int:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        return pulumi.get(self, "max_temporary_non_const_columns")

    @property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> int:
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        return pulumi.get(self, "max_threads")

    @property
    @pulumi.getter(name="mergeTreeMaxBytesToUseCache")
    def merge_tree_max_bytes_to_use_cache(self) -> int:
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesn’t use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_bytes_to_use_cache")

    @property
    @pulumi.getter(name="mergeTreeMaxRowsToUseCache")
    def merge_tree_max_rows_to_use_cache(self) -> int:
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesn’t use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_rows_to_use_cache")

    @property
    @pulumi.getter(name="mergeTreeMinBytesForConcurrentRead")
    def merge_tree_min_bytes_for_concurrent_read(self) -> int:
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        return pulumi.get(self, "merge_tree_min_bytes_for_concurrent_read")

    @property
    @pulumi.getter(name="mergeTreeMinRowsForConcurrentRead")
    def merge_tree_min_rows_for_concurrent_read(self) -> int:
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        return pulumi.get(self, "merge_tree_min_rows_for_concurrent_read")

    @property
    @pulumi.getter(name="minBytesToUseDirectIo")
    def min_bytes_to_use_direct_io(self) -> int:
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        return pulumi.get(self, "min_bytes_to_use_direct_io")

    @property
    @pulumi.getter(name="minCountToCompile")
    def min_count_to_compile(self) -> int:
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        return pulumi.get(self, "min_count_to_compile")

    @property
    @pulumi.getter(name="minCountToCompileExpression")
    def min_count_to_compile_expression(self) -> int:
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        return pulumi.get(self, "min_count_to_compile_expression")

    @property
    @pulumi.getter(name="minExecutionSpeed")
    def min_execution_speed(self) -> int:
        """
        Minimal execution speed in rows per second.
        """
        return pulumi.get(self, "min_execution_speed")

    @property
    @pulumi.getter(name="minExecutionSpeedBytes")
    def min_execution_speed_bytes(self) -> int:
        """
        Minimal execution speed in bytes per second.
        """
        return pulumi.get(self, "min_execution_speed_bytes")

    @property
    @pulumi.getter(name="minInsertBlockSizeBytes")
    def min_insert_block_size_bytes(self) -> int:
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_bytes")

    @property
    @pulumi.getter(name="minInsertBlockSizeRows")
    def min_insert_block_size_rows(self) -> int:
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_rows")

    @property
    @pulumi.getter(name="outputFormatJsonQuote64bitIntegers")
    def output_format_json_quote64bit_integers(self) -> bool:
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        return pulumi.get(self, "output_format_json_quote64bit_integers")

    @property
    @pulumi.getter(name="outputFormatJsonQuoteDenormals")
    def output_format_json_quote_denormals(self) -> bool:
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        return pulumi.get(self, "output_format_json_quote_denormals")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Query priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="quotaMode")
    def quota_mode(self) -> str:
        """
        Quota accounting mode.
        """
        return pulumi.get(self, "quota_mode")

    @property
    @pulumi.getter(name="readOverflowMode")
    def read_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow while read. Possible values:
        """
        return pulumi.get(self, "read_overflow_mode")

    @property
    @pulumi.getter
    def readonly(self) -> int:
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter(name="receiveTimeout")
    def receive_timeout(self) -> int:
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "receive_timeout")

    @property
    @pulumi.getter(name="replicationAlterPartitionsSync")
    def replication_alter_partitions_sync(self) -> int:
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        return pulumi.get(self, "replication_alter_partitions_sync")

    @property
    @pulumi.getter(name="resultOverflowMode")
    def result_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow in result. Possible values:
        """
        return pulumi.get(self, "result_overflow_mode")

    @property
    @pulumi.getter(name="selectSequentialConsistency")
    def select_sequential_consistency(self) -> bool:
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        return pulumi.get(self, "select_sequential_consistency")

    @property
    @pulumi.getter(name="sendProgressInHttpHeaders")
    def send_progress_in_http_headers(self) -> bool:
        """
        Enables or disables X-ClickHouse-Progress HTTP response headers in clickhouse-server responses.
        """
        return pulumi.get(self, "send_progress_in_http_headers")

    @property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> int:
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "send_timeout")

    @property
    @pulumi.getter(name="setOverflowMode")
    def set_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow in the set resulting. Possible values:
        """
        return pulumi.get(self, "set_overflow_mode")

    @property
    @pulumi.getter(name="skipUnavailableShards")
    def skip_unavailable_shards(self) -> bool:
        """
        Enables or disables silently skipping of unavailable shards.
        """
        return pulumi.get(self, "skip_unavailable_shards")

    @property
    @pulumi.getter(name="sortOverflowMode")
    def sort_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow while sort. Possible values:
        """
        return pulumi.get(self, "sort_overflow_mode")

    @property
    @pulumi.getter(name="timeoutOverflowMode")
    def timeout_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "timeout_overflow_mode")

    @property
    @pulumi.getter(name="transferOverflowMode")
    def transfer_overflow_mode(self) -> str:
        """
        Sets behaviour on overflow. Possible values:
        """
        return pulumi.get(self, "transfer_overflow_mode")

    @property
    @pulumi.getter(name="transformNullIn")
    def transform_null_in(self) -> bool:
        """
        Enables equality of NULL values for IN operator.
        """
        return pulumi.get(self, "transform_null_in")

    @property
    @pulumi.getter(name="useUncompressedCache")
    def use_uncompressed_cache(self) -> bool:
        """
        Whether to use a cache of uncompressed blocks.
        """
        return pulumi.get(self, "use_uncompressed_cache")


@pulumi.output_type
class GetMdbClickhouseClusterZookeeperResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetMdbClickhouseClusterZookeeperResourceResult']):
        """
        :param Sequence['GetMdbClickhouseClusterZookeeperResourceArgs'] resources: Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbClickhouseClusterZookeeperResourceResult']:
        """
        Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbClickhouseClusterZookeeperResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a ClickHouse or ZooKeeper host, in gigabytes.
        :param str disk_type_id: Type of the storage of ClickHouse or ZooKeeper hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a ClickHouse or ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of ClickHouse or ZooKeeper hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbElasticSearchClusterConfigResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 data_nodes: Sequence['outputs.GetMdbElasticSearchClusterConfigDataNodeResult'],
                 edition: str,
                 master_node: 'outputs.GetMdbElasticSearchClusterConfigMasterNodeResult',
                 plugins: Sequence[str],
                 version: str):
        """
        :param Sequence['GetMdbElasticSearchClusterConfigDataNodeArgs'] data_nodes: Configuration for Elasticsearch data nodes subcluster. The structure is documented below.
        :param str edition: Edition of Elasticsearch. For more information, see [the official documentation](https://cloud.yandex.com/en-ru/docs/managed-elasticsearch/concepts/es-editions).
        :param 'GetMdbElasticSearchClusterConfigMasterNodeArgs' master_node: Configuration for Elasticsearch master nodes subcluster. The structure is documented below.
        :param Sequence[str] plugins: A set of requested Elasticsearch plugins.
        :param str version: Version of Elasticsearch.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "data_nodes", data_nodes)
        pulumi.set(__self__, "edition", edition)
        pulumi.set(__self__, "master_node", master_node)
        pulumi.set(__self__, "plugins", plugins)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="dataNodes")
    def data_nodes(self) -> Sequence['outputs.GetMdbElasticSearchClusterConfigDataNodeResult']:
        """
        Configuration for Elasticsearch data nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "data_nodes")

    @property
    @pulumi.getter
    def edition(self) -> str:
        """
        Edition of Elasticsearch. For more information, see [the official documentation](https://cloud.yandex.com/en-ru/docs/managed-elasticsearch/concepts/es-editions).
        """
        return pulumi.get(self, "edition")

    @property
    @pulumi.getter(name="masterNode")
    def master_node(self) -> 'outputs.GetMdbElasticSearchClusterConfigMasterNodeResult':
        """
        Configuration for Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "master_node")

    @property
    @pulumi.getter
    def plugins(self) -> Sequence[str]:
        """
        A set of requested Elasticsearch plugins.
        """
        return pulumi.get(self, "plugins")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of Elasticsearch.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbElasticSearchClusterConfigDataNodeResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetMdbElasticSearchClusterConfigDataNodeResourceResult']):
        """
        :param Sequence['GetMdbElasticSearchClusterConfigDataNodeResourceArgs'] resources: Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbElasticSearchClusterConfigDataNodeResourceResult']:
        """
        Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbElasticSearchClusterConfigDataNodeResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a Elasticsearch host, in gigabytes.
        :param str disk_type_id: Type of the storage of Elasticsearch hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a Elasticsearch host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of Elasticsearch hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbElasticSearchClusterConfigMasterNodeResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetMdbElasticSearchClusterConfigMasterNodeResourceResult']):
        """
        :param Sequence['GetMdbElasticSearchClusterConfigMasterNodeResourceArgs'] resources: Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbElasticSearchClusterConfigMasterNodeResourceResult']:
        """
        Resources allocated to hosts of the Elasticsearch master nodes subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbElasticSearchClusterConfigMasterNodeResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a Elasticsearch host, in gigabytes.
        :param str disk_type_id: Type of the storage of Elasticsearch hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a Elasticsearch host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of Elasticsearch hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbElasticSearchClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: bool,
                 fqdn: str,
                 name: str,
                 subnet_id: str,
                 type: str,
                 zone: str):
        """
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation.
        :param str fqdn: The fully qualified domain name of the host.
        :param str name: The name of the Elasticsearch cluster.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param str type: Type of a maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour need to be specified with the weekly window.
        :param str zone: The availability zone where the Elasticsearch host will be created.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        """
        Sets whether the host should get a public IP address on creation.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Elasticsearch cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour need to be specified with the weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the Elasticsearch host will be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbElasticSearchClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 hour: int,
                 type: str):
        """
        :param str day: Day of the week for a maintenance window if the window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of the day in UTC time zone (1-24) for a maintenance window if the window type is weekly.
        :param str type: Type of a maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour need to be specified with the weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Day of the week for a maintenance window if the window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        Hour of the day in UTC time zone (1-24) for a maintenance window if the window type is weekly.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour need to be specified with the weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbGreenplumClusterAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: bool,
                 web_sql: bool):
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> bool:
        return pulumi.get(self, "data_lens")

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> bool:
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class GetMdbGreenplumClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: int,
                 minutes: int):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> int:
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbGreenplumClusterMasterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: bool,
                 fqdn: str):
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetMdbGreenplumClusterMasterSubclusterResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetMdbGreenplumClusterMasterSubclusterResourceResult']):
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbGreenplumClusterMasterSubclusterResourceResult']:
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbGreenplumClusterMasterSubclusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbGreenplumClusterSegmentHostResult(dict):
    def __init__(__self__, *,
                 fqdn: str):
        pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetMdbGreenplumClusterSegmentSubclusterResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetMdbGreenplumClusterSegmentSubclusterResourceResult']):
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbGreenplumClusterSegmentSubclusterResourceResult']:
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbGreenplumClusterSegmentSubclusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbKafkaClusterConfigResult(dict):
    def __init__(__self__, *,
                 kafka: 'outputs.GetMdbKafkaClusterConfigKafkaResult',
                 version: str,
                 zones: Sequence[str],
                 zookeeper: 'outputs.GetMdbKafkaClusterConfigZookeeperResult',
                 assign_public_ip: Optional[bool] = None,
                 brokers_count: Optional[int] = None,
                 schema_registry: Optional[bool] = None,
                 unmanaged_topics: Optional[bool] = None):
        """
        :param 'GetMdbKafkaClusterConfigKafkaArgs' kafka: (Optional) Configuration of the Kafka subcluster. The structure is documented below.
        :param str version: (Required) Version of the Kafka server software.
        :param Sequence[str] zones: (Optional) List of availability zones.
        :param 'GetMdbKafkaClusterConfigZookeeperArgs' zookeeper: (Optional) Configuration of the ZooKeeper subcluster. The structure is documented below.
        :param bool assign_public_ip: The flag that defines whether a public IP address is assigned to the node.
        :param int brokers_count: (Optional) Count of brokers per availability zone.
        :param bool schema_registry: (Optional) Enables managed schema registry on cluster. Can be either `true` or `false`.
        :param bool unmanaged_topics: (Optional) Allows to use Kafka AdminAPI to manage topics. Can be either `true` or `false`.
        """
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zones", zones)
        pulumi.set(__self__, "zookeeper", zookeeper)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if brokers_count is not None:
            pulumi.set(__self__, "brokers_count", brokers_count)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if unmanaged_topics is not None:
            pulumi.set(__self__, "unmanaged_topics", unmanaged_topics)

    @property
    @pulumi.getter
    def kafka(self) -> 'outputs.GetMdbKafkaClusterConfigKafkaResult':
        """
        (Optional) Configuration of the Kafka subcluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        (Required) Version of the Kafka server software.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        (Optional) List of availability zones.
        """
        return pulumi.get(self, "zones")

    @property
    @pulumi.getter
    def zookeeper(self) -> 'outputs.GetMdbKafkaClusterConfigZookeeperResult':
        """
        (Optional) Configuration of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "zookeeper")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="brokersCount")
    def brokers_count(self) -> Optional[int]:
        """
        (Optional) Count of brokers per availability zone.
        """
        return pulumi.get(self, "brokers_count")

    @property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[bool]:
        """
        (Optional) Enables managed schema registry on cluster. Can be either `true` or `false`.
        """
        return pulumi.get(self, "schema_registry")

    @property
    @pulumi.getter(name="unmanagedTopics")
    def unmanaged_topics(self) -> Optional[bool]:
        """
        (Optional) Allows to use Kafka AdminAPI to manage topics. Can be either `true` or `false`.
        """
        return pulumi.get(self, "unmanaged_topics")


@pulumi.output_type
class GetMdbKafkaClusterConfigKafkaResult(dict):
    def __init__(__self__, *,
                 resources: 'outputs.GetMdbKafkaClusterConfigKafkaResourcesResult',
                 kafka_config: Optional['outputs.GetMdbKafkaClusterConfigKafkaKafkaConfigResult'] = None):
        """
        :param 'GetMdbKafkaClusterConfigKafkaResourcesArgs' resources: (Optional) Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        :param 'GetMdbKafkaClusterConfigKafkaKafkaConfigArgs' kafka_config: (Optional) User-defined settings for the Kafka cluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)
        if kafka_config is not None:
            pulumi.set(__self__, "kafka_config", kafka_config)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbKafkaClusterConfigKafkaResourcesResult':
        """
        (Optional) Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="kafkaConfig")
    def kafka_config(self) -> Optional['outputs.GetMdbKafkaClusterConfigKafkaKafkaConfigResult']:
        """
        (Optional) User-defined settings for the Kafka cluster. The structure is documented below.
        """
        return pulumi.get(self, "kafka_config")


@pulumi.output_type
class GetMdbKafkaClusterConfigKafkaKafkaConfigResult(dict):
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[bool] = None,
                 compression_type: Optional[str] = None,
                 default_replication_factor: Optional[str] = None,
                 log_flush_interval_messages: Optional[str] = None,
                 log_flush_interval_ms: Optional[str] = None,
                 log_flush_scheduler_interval_ms: Optional[str] = None,
                 log_preallocate: Optional[bool] = None,
                 log_retention_bytes: Optional[str] = None,
                 log_retention_hours: Optional[str] = None,
                 log_retention_minutes: Optional[str] = None,
                 log_retention_ms: Optional[str] = None,
                 log_segment_bytes: Optional[str] = None,
                 num_partitions: Optional[str] = None,
                 socket_receive_buffer_bytes: Optional[str] = None,
                 socket_send_buffer_bytes: Optional[str] = None):
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_flush_scheduler_interval_ms is not None:
            pulumi.set(__self__, "log_flush_scheduler_interval_ms", log_flush_scheduler_interval_ms)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_minutes is not None:
            pulumi.set(__self__, "log_retention_minutes", log_retention_minutes)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if socket_receive_buffer_bytes is not None:
            pulumi.set(__self__, "socket_receive_buffer_bytes", socket_receive_buffer_bytes)
        if socket_send_buffer_bytes is not None:
            pulumi.set(__self__, "socket_send_buffer_bytes", socket_send_buffer_bytes)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[bool]:
        return pulumi.get(self, "auto_create_topics_enable")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[str]:
        return pulumi.get(self, "default_replication_factor")

    @property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_messages")

    @property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_interval_ms")

    @property
    @pulumi.getter(name="logFlushSchedulerIntervalMs")
    def log_flush_scheduler_interval_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_flush_scheduler_interval_ms")

    @property
    @pulumi.getter(name="logPreallocate")
    def log_preallocate(self) -> Optional[bool]:
        return pulumi.get(self, "log_preallocate")

    @property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_bytes")

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_hours")

    @property
    @pulumi.getter(name="logRetentionMinutes")
    def log_retention_minutes(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_minutes")

    @property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "log_retention_ms")

    @property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "log_segment_bytes")

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[str]:
        return pulumi.get(self, "num_partitions")

    @property
    @pulumi.getter(name="socketReceiveBufferBytes")
    def socket_receive_buffer_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_receive_buffer_bytes")

    @property
    @pulumi.getter(name="socketSendBufferBytes")
    def socket_send_buffer_bytes(self) -> Optional[str]:
        return pulumi.get(self, "socket_send_buffer_bytes")


@pulumi.output_type
class GetMdbKafkaClusterConfigKafkaResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: (Optional) Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param str disk_type_id: (Optional) Type of the storage of ZooKeeper hosts.
               For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        (Optional) Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        (Optional) Type of the storage of ZooKeeper hosts.
        For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbKafkaClusterConfigZookeeperResult(dict):
    def __init__(__self__, *,
                 resources: 'outputs.GetMdbKafkaClusterConfigZookeeperResourcesResult'):
        """
        :param 'GetMdbKafkaClusterConfigZookeeperResourcesArgs' resources: (Optional) Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbKafkaClusterConfigZookeeperResourcesResult':
        """
        (Optional) Resources allocated to hosts of the ZooKeeper subcluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbKafkaClusterConfigZookeeperResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: (Optional) Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param str disk_type_id: (Optional) Type of the storage of ZooKeeper hosts.
               For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        (Optional) Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        (Optional) Type of the storage of ZooKeeper hosts.
        For more information see [the official documentation](https://cloud.yandex.com/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbKafkaClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: bool,
                 health: str,
                 name: str,
                 role: str,
                 subnet_id: str,
                 zone_id: str):
        """
        :param bool assign_public_ip: The flag that defines whether a public IP address is assigned to the node.
        :param str health: Health of the host.
        :param str name: The name of the Kafka cluster.
        :param str role: Role of the host in the cluster.
        :param str subnet_id: The ID of the subnet, to which the host belongs.
        :param str zone_id: The availability zone where the Kafka host was created.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def health(self) -> str:
        """
        Health of the host.
        """
        return pulumi.get(self, "health")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Kafka cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role of the host in the cluster.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The availability zone where the Kafka host was created.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetMdbKafkaClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 hour: int,
                 type: str):
        """
        :param str day: Day of the week (in `DDD` format). Value is one of: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param int hour: Hour of the day in UTC (in `HH` format). Value is between 1 and 24.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Day of the week (in `DDD` format). Value is one of: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        Hour of the day in UTC (in `HH` format). Value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbKafkaClusterTopicResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 name: str,
                 partitions: int,
                 replication_factor: int,
                 topic_config: Optional['outputs.GetMdbKafkaClusterTopicTopicConfigResult'] = None):
        """
        :param str cluster_id: The ID of the Kafka cluster.
        :param str name: The name of the Kafka cluster.
        :param int partitions: (Required) The number of the topic's partitions.
        :param int replication_factor: (Required) Amount of data copies (replicas) for the topic in the cluster.
        :param 'GetMdbKafkaClusterTopicTopicConfigArgs' topic_config: (Required) User-defined settings for the topic. The structure is documented below.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replication_factor", replication_factor)
        if topic_config is not None:
            pulumi.set(__self__, "topic_config", topic_config)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The ID of the Kafka cluster.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Kafka cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> int:
        """
        (Required) The number of the topic's partitions.
        """
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> int:
        """
        (Required) Amount of data copies (replicas) for the topic in the cluster.
        """
        return pulumi.get(self, "replication_factor")

    @property
    @pulumi.getter(name="topicConfig")
    def topic_config(self) -> Optional['outputs.GetMdbKafkaClusterTopicTopicConfigResult']:
        """
        (Required) User-defined settings for the topic. The structure is documented below.
        """
        return pulumi.get(self, "topic_config")


@pulumi.output_type
class GetMdbKafkaClusterTopicTopicConfigResult(dict):
    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 compression_type: Optional[str] = None,
                 delete_retention_ms: Optional[str] = None,
                 file_delete_delay_ms: Optional[str] = None,
                 flush_messages: Optional[str] = None,
                 flush_ms: Optional[str] = None,
                 max_message_bytes: Optional[str] = None,
                 min_compaction_lag_ms: Optional[str] = None,
                 min_insync_replicas: Optional[str] = None,
                 preallocate: Optional[bool] = None,
                 retention_bytes: Optional[str] = None,
                 retention_ms: Optional[str] = None,
                 segment_bytes: Optional[str] = None):
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[str]:
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[str]:
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[str]:
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[str]:
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[str]:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[bool]:
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[str]:
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[str]:
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[str]:
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class GetMdbKafkaClusterUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permissions: Optional[Sequence['outputs.GetMdbKafkaClusterUserPermissionResult']] = None):
        """
        :param str name: The name of the Kafka cluster.
        :param str password: (Required) The password of the user.
        :param Sequence['GetMdbKafkaClusterUserPermissionArgs'] permissions: (Optional) Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Kafka cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        (Required) The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.GetMdbKafkaClusterUserPermissionResult']]:
        """
        (Optional) Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetMdbKafkaClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 role: str,
                 topic_name: str):
        """
        :param str role: Role of the host in the cluster.
        :param str topic_name: (Required) The name of the topic that the permission grants access to.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role of the host in the cluster.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> str:
        """
        (Required) The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class GetMdbKafkaTopicTopicConfigResult(dict):
    def __init__(__self__, *,
                 cleanup_policy: str,
                 compression_type: str,
                 delete_retention_ms: str,
                 file_delete_delay_ms: str,
                 flush_messages: str,
                 flush_ms: str,
                 max_message_bytes: str,
                 min_compaction_lag_ms: str,
                 min_insync_replicas: str,
                 preallocate: bool,
                 retention_bytes: str,
                 retention_ms: str,
                 segment_bytes: str):
        pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        pulumi.set(__self__, "compression_type", compression_type)
        pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        pulumi.set(__self__, "flush_messages", flush_messages)
        pulumi.set(__self__, "flush_ms", flush_ms)
        pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        pulumi.set(__self__, "preallocate", preallocate)
        pulumi.set(__self__, "retention_bytes", retention_bytes)
        pulumi.set(__self__, "retention_ms", retention_ms)
        pulumi.set(__self__, "segment_bytes", segment_bytes)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> str:
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> str:
        return pulumi.get(self, "compression_type")

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> str:
        return pulumi.get(self, "delete_retention_ms")

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> str:
        return pulumi.get(self, "file_delete_delay_ms")

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> str:
        return pulumi.get(self, "flush_messages")

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> str:
        return pulumi.get(self, "flush_ms")

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> str:
        return pulumi.get(self, "max_message_bytes")

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> str:
        return pulumi.get(self, "min_compaction_lag_ms")

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> str:
        return pulumi.get(self, "min_insync_replicas")

    @property
    @pulumi.getter
    def preallocate(self) -> bool:
        return pulumi.get(self, "preallocate")

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> str:
        return pulumi.get(self, "retention_bytes")

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> str:
        return pulumi.get(self, "retention_ms")

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> str:
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigResult(dict):
    def __init__(__self__, *,
                 accesses: Sequence['outputs.GetMdbMongodbClusterClusterConfigAccessResult'],
                 backup_window_starts: Sequence['outputs.GetMdbMongodbClusterClusterConfigBackupWindowStartResult'],
                 feature_compatibility_version: str,
                 version: str):
        """
        :param Sequence['GetMdbMongodbClusterClusterConfigAccessArgs'] accesses: Access policy to MongoDB cluster. The structure is documented below.
        :param Sequence['GetMdbMongodbClusterClusterConfigBackupWindowStartArgs'] backup_window_starts: Time to start the daily backup, in the UTC timezone. The structure is documented below.
        :param str feature_compatibility_version: Feature compatibility version of MongoDB.
        :param str version: Version of MongoDB (either 5.0, 4.4, 4.2, 4.0 or 3.6).
        """
        pulumi.set(__self__, "accesses", accesses)
        pulumi.set(__self__, "backup_window_starts", backup_window_starts)
        pulumi.set(__self__, "feature_compatibility_version", feature_compatibility_version)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def accesses(self) -> Sequence['outputs.GetMdbMongodbClusterClusterConfigAccessResult']:
        """
        Access policy to MongoDB cluster. The structure is documented below.
        """
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter(name="backupWindowStarts")
    def backup_window_starts(self) -> Sequence['outputs.GetMdbMongodbClusterClusterConfigBackupWindowStartResult']:
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        return pulumi.get(self, "backup_window_starts")

    @property
    @pulumi.getter(name="featureCompatibilityVersion")
    def feature_compatibility_version(self) -> str:
        """
        Feature compatibility version of MongoDB.
        """
        return pulumi.get(self, "feature_compatibility_version")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of MongoDB (either 5.0, 4.4, 4.2, 4.0 or 3.6).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: bool):
        """
        :param bool data_lens: Shows whether cluster has access to data lens.
        """
        pulumi.set(__self__, "data_lens", data_lens)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> bool:
        """
        Shows whether cluster has access to data lens.
        """
        return pulumi.get(self, "data_lens")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbMongodbClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the MongoDB cluster.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the MongoDB cluster.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbMongodbClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: bool,
                 health: str,
                 name: str,
                 role: str,
                 shard_name: str,
                 subnet_id: str,
                 type: str,
                 zone_id: str):
        """
        :param bool assign_public_ip: Has assigned public IP.
        :param str health: The health of the host.
        :param str name: The name of the MongoDB cluster.
        :param str role: The role of the cluster (either PRIMARY or SECONDARY).
        :param str shard_name: The name of the shard to which the host belongs.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must
               be a part of the network to which the cluster belongs.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param str zone_id: The availability zone where the MongoDB host will be created.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "shard_name", shard_name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        """
        Has assigned public IP.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def health(self) -> str:
        """
        The health of the host.
        """
        return pulumi.get(self, "health")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the MongoDB cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role of the cluster (either PRIMARY or SECONDARY).
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> str:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must
        be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The availability zone where the MongoDB host will be created.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetMdbMongodbClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 hour: int,
                 type: str):
        """
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbMongodbClusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        The ID of the storage type. For more information, see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/storage)
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMongodbClusterUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence['outputs.GetMdbMongodbClusterUserPermissionResult']):
        """
        :param str name: The name of the MongoDB cluster.
        :param Sequence['GetMdbMongodbClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the MongoDB cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbMongodbClusterUserPermissionResult']:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetMdbMongodbClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        :param Sequence[str] roles: (Optional) List of strings. The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        (Optional) List of strings. The roles of the user in this database. For more information see [the official documentation](https://cloud.yandex.com/docs/managed-mongodb/concepts/users-and-roles).
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetMdbMysqlClusterAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: bool,
                 web_sql: bool):
        """
        :param bool data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param bool web_sql: Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> bool:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> bool:
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class GetMdbMysqlClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: Optional[int] = None,
                 minutes: Optional[int] = None):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbMysqlClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the MySQL cluster.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the MySQL cluster.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbMysqlClusterHostResult(dict):
    def __init__(__self__, *,
                 fqdn: str,
                 replication_source: str,
                 subnet_id: str,
                 zone: str,
                 assign_public_ip: Optional[bool] = None):
        """
        :param str fqdn: The fully qualified domain name of the host.
        :param str replication_source: Host replication source (fqdn), case when replication_source is empty then host in HA group.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param str zone: The availability zone where the MySQL host will be created.
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "replication_source", replication_source)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> str:
        """
        Host replication source (fqdn), case when replication_source is empty then host in HA group.
        """
        return pulumi.get(self, "replication_source")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the MySQL host will be created.
        """
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        """
        return pulumi.get(self, "assign_public_ip")


@pulumi.output_type
class GetMdbMysqlClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 hour: int,
                 type: str):
        """
        :param str day: Day of the week (in `DDD` format). Value is one of: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param int hour: Hour of the day in UTC (in `HH` format). Value is between 1 and 24.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Day of the week (in `DDD` format). Value is one of: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        Hour of the day in UTC (in `HH` format). Value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbMysqlClusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a MySQL host, in gigabytes.
        :param str disk_type_id: Type of the storage for MySQL hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a MySQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage for MySQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMysqlClusterUserResult(dict):
    def __init__(__self__, *,
                 authentication_plugin: str,
                 connection_limits: Sequence['outputs.GetMdbMysqlClusterUserConnectionLimitResult'],
                 global_permissions: Sequence[str],
                 name: str,
                 password: str,
                 permissions: Sequence['outputs.GetMdbMysqlClusterUserPermissionResult']):
        """
        :param str authentication_plugin: Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD`
        :param Sequence['GetMdbMysqlClusterUserConnectionLimitArgs'] connection_limits: User's connection limits. The structure is documented below.
        :param Sequence[str] global_permissions: List user's global permissions. Allowed values: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS` or empty list.
        :param str name: The name of the MySQL cluster.
        :param str password: The password of the user.
        :param Sequence['GetMdbMysqlClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "authentication_plugin", authentication_plugin)
        pulumi.set(__self__, "connection_limits", connection_limits)
        pulumi.set(__self__, "global_permissions", global_permissions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter(name="authenticationPlugin")
    def authentication_plugin(self) -> str:
        """
        Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD`
        """
        return pulumi.get(self, "authentication_plugin")

    @property
    @pulumi.getter(name="connectionLimits")
    def connection_limits(self) -> Sequence['outputs.GetMdbMysqlClusterUserConnectionLimitResult']:
        """
        User's connection limits. The structure is documented below.
        """
        return pulumi.get(self, "connection_limits")

    @property
    @pulumi.getter(name="globalPermissions")
    def global_permissions(self) -> Sequence[str]:
        """
        List user's global permissions. Allowed values: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS` or empty list.
        """
        return pulumi.get(self, "global_permissions")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the MySQL cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbMysqlClusterUserPermissionResult']:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetMdbMysqlClusterUserConnectionLimitResult(dict):
    def __init__(__self__, *,
                 max_connections_per_hour: int,
                 max_questions_per_hour: int,
                 max_updates_per_hour: int,
                 max_user_connections: int):
        """
        :param int max_connections_per_hour: Max connections per hour.
        :param int max_questions_per_hour: Max questions per hour.
        :param int max_updates_per_hour: Max updates per hour.
        :param int max_user_connections: Max user connections.
        """
        pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        pulumi.set(__self__, "max_user_connections", max_user_connections)

    @property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> int:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> int:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> int:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> int:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")


@pulumi.output_type
class GetMdbMysqlClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str database_name: The name of the database that the permission grants access to.
        :param Sequence[str] roles: List user's roles in the database.
               Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`,
               `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        List user's roles in the database.
        Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`,
        `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigResult(dict):
    def __init__(__self__, *,
                 accesses: Sequence['outputs.GetMdbPostgresqlClusterConfigAccessResult'],
                 autofailover: bool,
                 backup_retain_period_days: int,
                 backup_window_starts: Sequence['outputs.GetMdbPostgresqlClusterConfigBackupWindowStartResult'],
                 performance_diagnostics: Sequence['outputs.GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult'],
                 pooler_configs: Sequence['outputs.GetMdbPostgresqlClusterConfigPoolerConfigResult'],
                 postgresql_config: Mapping[str, str],
                 resources: Sequence['outputs.GetMdbPostgresqlClusterConfigResourceResult'],
                 version: str):
        """
        :param Sequence['GetMdbPostgresqlClusterConfigAccessArgs'] accesses: Access policy to the PostgreSQL cluster. The structure is documented below.
        :param bool autofailover: Configuration setting which enables/disables autofailover in cluster.
        :param int backup_retain_period_days: The period in days during which backups are stored.
        :param Sequence['GetMdbPostgresqlClusterConfigBackupWindowStartArgs'] backup_window_starts: Time to start the daily backup, in the UTC timezone. The structure is documented below.
        :param Sequence['GetMdbPostgresqlClusterConfigPerformanceDiagnosticArgs'] performance_diagnostics: Cluster performance diagnostics settings. The structure is documented below. [YC Documentation](https://cloud.yandex.com/docs/managed-postgresql/grpc/cluster_service#PerformanceDiagnostics)
        :param Sequence['GetMdbPostgresqlClusterConfigPoolerConfigArgs'] pooler_configs: Configuration of the connection pooler. The structure is documented below.
        :param Mapping[str, str] postgresql_config: PostgreSQL cluster config.
        :param Sequence['GetMdbPostgresqlClusterConfigResourceArgs'] resources: Resources allocated to hosts of the PostgreSQL cluster. The structure is documented below.
        :param str version: Version of the extension.
        """
        pulumi.set(__self__, "accesses", accesses)
        pulumi.set(__self__, "autofailover", autofailover)
        pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        pulumi.set(__self__, "backup_window_starts", backup_window_starts)
        pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)
        pulumi.set(__self__, "pooler_configs", pooler_configs)
        pulumi.set(__self__, "postgresql_config", postgresql_config)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def accesses(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigAccessResult']:
        """
        Access policy to the PostgreSQL cluster. The structure is documented below.
        """
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter
    def autofailover(self) -> bool:
        """
        Configuration setting which enables/disables autofailover in cluster.
        """
        return pulumi.get(self, "autofailover")

    @property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> int:
        """
        The period in days during which backups are stored.
        """
        return pulumi.get(self, "backup_retain_period_days")

    @property
    @pulumi.getter(name="backupWindowStarts")
    def backup_window_starts(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigBackupWindowStartResult']:
        """
        Time to start the daily backup, in the UTC timezone. The structure is documented below.
        """
        return pulumi.get(self, "backup_window_starts")

    @property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult']:
        """
        Cluster performance diagnostics settings. The structure is documented below. [YC Documentation](https://cloud.yandex.com/docs/managed-postgresql/grpc/cluster_service#PerformanceDiagnostics)
        """
        return pulumi.get(self, "performance_diagnostics")

    @property
    @pulumi.getter(name="poolerConfigs")
    def pooler_configs(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigPoolerConfigResult']:
        """
        Configuration of the connection pooler. The structure is documented below.
        """
        return pulumi.get(self, "pooler_configs")

    @property
    @pulumi.getter(name="postgresqlConfig")
    def postgresql_config(self) -> Mapping[str, str]:
        """
        PostgreSQL cluster config.
        """
        return pulumi.get(self, "postgresql_config")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigResourceResult']:
        """
        Resources allocated to hosts of the PostgreSQL cluster. The structure is documented below.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the extension.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: bool,
                 web_sql: bool):
        """
        :param bool data_lens: Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        :param bool web_sql: Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-postgresql/operations/web-sql-query)
        """
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "web_sql", web_sql)

    @property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> bool:
        """
        Allow access for [Yandex DataLens](https://cloud.yandex.com/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> bool:
        """
        Allows access for [SQL queries in the management console](https://cloud.yandex.com/docs/managed-postgresql/operations/web-sql-query)
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: int,
                 minutes: int):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 sessions_sampling_interval: int,
                 statements_sampling_interval: int):
        """
        :param bool enabled: Flag, when true, performance diagnostics is enabled
        :param int sessions_sampling_interval: Interval (in seconds) for pg_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        :param int statements_sampling_interval: Interval (in seconds) for pg_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sessions_sampling_interval", sessions_sampling_interval)
        pulumi.set(__self__, "statements_sampling_interval", statements_sampling_interval)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Flag, when true, performance diagnostics is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="sessionsSamplingInterval")
    def sessions_sampling_interval(self) -> int:
        """
        Interval (in seconds) for pg_stat_activity sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "sessions_sampling_interval")

    @property
    @pulumi.getter(name="statementsSamplingInterval")
    def statements_sampling_interval(self) -> int:
        """
        Interval (in seconds) for pg_stat_statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "statements_sampling_interval")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigPoolerConfigResult(dict):
    def __init__(__self__, *,
                 pool_discard: bool,
                 pooling_mode: str):
        """
        :param bool pool_discard: Value for `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        :param str pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        pulumi.set(__self__, "pool_discard", pool_discard)
        pulumi.set(__self__, "pooling_mode", pooling_mode)

    @property
    @pulumi.getter(name="poolDiscard")
    def pool_discard(self) -> bool:
        """
        Value for `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        """
        return pulumi.get(self, "pool_discard")

    @property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> str:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a PostgreSQL host, in gigabytes.
        :param str disk_type_id: Type of the storage for PostgreSQL hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a PostgreSQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage for PostgreSQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbPostgresqlClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 extensions: Sequence['outputs.GetMdbPostgresqlClusterDatabaseExtensionResult'],
                 lc_collate: str,
                 lc_type: str,
                 name: str,
                 owner: str):
        """
        :param Sequence['GetMdbPostgresqlClusterDatabaseExtensionArgs'] extensions: Set of database extensions. The structure is documented below
        :param str lc_collate: POSIX locale for string sorting order. Forbidden to change in an existing database.
        :param str lc_type: POSIX locale for character classification. Forbidden to change in an existing database.
        :param str name: The name of the PostgreSQL cluster.
        :param str owner: Name of the user assigned as the owner of the database.
        """
        pulumi.set(__self__, "extensions", extensions)
        pulumi.set(__self__, "lc_collate", lc_collate)
        pulumi.set(__self__, "lc_type", lc_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)

    @property
    @pulumi.getter
    def extensions(self) -> Sequence['outputs.GetMdbPostgresqlClusterDatabaseExtensionResult']:
        """
        Set of database extensions. The structure is documented below
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="lcCollate")
    def lc_collate(self) -> str:
        """
        POSIX locale for string sorting order. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "lc_collate")

    @property
    @pulumi.getter(name="lcType")
    def lc_type(self) -> str:
        """
        POSIX locale for character classification. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "lc_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the PostgreSQL cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Name of the user assigned as the owner of the database.
        """
        return pulumi.get(self, "owner")


@pulumi.output_type
class GetMdbPostgresqlClusterDatabaseExtensionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 version: str):
        """
        :param str name: The name of the PostgreSQL cluster.
        :param str version: Version of the extension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the PostgreSQL cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the extension.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbPostgresqlClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: bool,
                 fqdn: str,
                 priority: int,
                 replication_source: str,
                 role: str,
                 subnet_id: str,
                 zone: str):
        """
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        :param str fqdn: The fully qualified domain name of the host.
        :param int priority: Host priority in HA group.
        :param str replication_source: Host replication source (fqdn), case when replication_source is empty then host in HA group.
        :param str role: Role of the host in the cluster.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param str zone: The availability zone where the PostgreSQL host will be created.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "replication_source", replication_source)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Host priority in HA group.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> str:
        """
        Host replication source (fqdn), case when replication_source is empty then host in HA group.
        """
        return pulumi.get(self, "replication_source")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role of the host in the cluster.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the PostgreSQL host will be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbPostgresqlClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 hour: int,
                 type: str):
        """
        :param str day: Day of the week (in `DDD` format). Value is one of: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        :param int hour: Hour of the day in UTC (in `HH` format). Value is between 1 and 24.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Day of the week (in `DDD` format). Value is one of: "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        Hour of the day in UTC (in `HH` format). Value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbPostgresqlClusterUserResult(dict):
    def __init__(__self__, *,
                 grants: Sequence[str],
                 name: str,
                 password: str,
                 permissions: Sequence['outputs.GetMdbPostgresqlClusterUserPermissionResult'],
                 settings: Mapping[str, str],
                 conn_limit: Optional[int] = None,
                 login: Optional[bool] = None):
        """
        :param Sequence[str] grants: List of the user's grants.
        :param str name: The name of the PostgreSQL cluster.
        :param str password: The password of the user.
        :param Sequence['GetMdbPostgresqlClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        :param Mapping[str, str] settings: Map of user settings.
        :param int conn_limit: The maximum number of connections per user.
        :param bool login: User's ability to login.
        """
        pulumi.set(__self__, "grants", grants)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "settings", settings)
        if conn_limit is not None:
            pulumi.set(__self__, "conn_limit", conn_limit)
        if login is not None:
            pulumi.set(__self__, "login", login)

    @property
    @pulumi.getter
    def grants(self) -> Sequence[str]:
        """
        List of the user's grants.
        """
        return pulumi.get(self, "grants")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the PostgreSQL cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbPostgresqlClusterUserPermissionResult']:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def settings(self) -> Mapping[str, str]:
        """
        Map of user settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter(name="connLimit")
    def conn_limit(self) -> Optional[int]:
        """
        The maximum number of connections per user.
        """
        return pulumi.get(self, "conn_limit")

    @property
    @pulumi.getter
    def login(self) -> Optional[bool]:
        """
        User's ability to login.
        """
        return pulumi.get(self, "login")


@pulumi.output_type
class GetMdbPostgresqlClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: str):
        """
        :param str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetMdbRedisClusterConfigResult(dict):
    def __init__(__self__, *,
                 databases: int,
                 maxmemory_policy: str,
                 notify_keyspace_events: str,
                 slowlog_log_slower_than: int,
                 slowlog_max_len: int,
                 timeout: int,
                 version: str):
        """
        :param int databases: Number of databases (changing requires redis-server restart).
        :param str maxmemory_policy: Redis key eviction policy for a dataset that reaches maximum memory.
        :param str notify_keyspace_events: Select the events that Redis will notify among a set of classes.
        :param int slowlog_log_slower_than: Log slow queries below this number in microseconds.
        :param int slowlog_max_len: Slow queries log length.
        :param int timeout: Close the connection after a client is idle for N seconds.
        :param str version: Version of Redis (5.0, 6.0 or 6.2).
        """
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "maxmemory_policy", maxmemory_policy)
        pulumi.set(__self__, "notify_keyspace_events", notify_keyspace_events)
        pulumi.set(__self__, "slowlog_log_slower_than", slowlog_log_slower_than)
        pulumi.set(__self__, "slowlog_max_len", slowlog_max_len)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def databases(self) -> int:
        """
        Number of databases (changing requires redis-server restart).
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="maxmemoryPolicy")
    def maxmemory_policy(self) -> str:
        """
        Redis key eviction policy for a dataset that reaches maximum memory.
        """
        return pulumi.get(self, "maxmemory_policy")

    @property
    @pulumi.getter(name="notifyKeyspaceEvents")
    def notify_keyspace_events(self) -> str:
        """
        Select the events that Redis will notify among a set of classes.
        """
        return pulumi.get(self, "notify_keyspace_events")

    @property
    @pulumi.getter(name="slowlogLogSlowerThan")
    def slowlog_log_slower_than(self) -> int:
        """
        Log slow queries below this number in microseconds.
        """
        return pulumi.get(self, "slowlog_log_slower_than")

    @property
    @pulumi.getter(name="slowlogMaxLen")
    def slowlog_max_len(self) -> int:
        """
        Slow queries log length.
        """
        return pulumi.get(self, "slowlog_max_len")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        Close the connection after a client is idle for N seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of Redis (5.0, 6.0 or 6.2).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbRedisClusterHostResult(dict):
    def __init__(__self__, *,
                 fqdn: str,
                 shard_name: str,
                 subnet_id: str,
                 zone: str):
        """
        :param str fqdn: The fully qualified domain name of the host.
        :param str shard_name: The name of the shard to which the host belongs.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must
               be a part of the network to which the cluster belongs.
        :param str zone: The availability zone where the Redis host will be created.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "shard_name", shard_name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> str:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must
        be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the Redis host will be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbRedisClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: str,
                 hour: int,
                 type: str):
        """
        :param str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbRedisClusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a host, in gigabytes.
        :param str disk_type_id: Type of the storage of a host.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage of a host.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbSqlserverClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: int,
                 minutes: int):
        """
        :param int hours: The hour at which backup will be started.
        :param int minutes: The minute at which backup will be started.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbSqlserverClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the SQLServer cluster.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SQLServer cluster.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbSqlserverClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: bool,
                 fqdn: str,
                 subnet_id: str,
                 zone: str):
        """
        :param bool assign_public_ip: Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        :param str fqdn: The fully qualified domain name of the host.
        :param str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param str zone: The availability zone where the SQLServer host will be created.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The availability zone where the SQLServer host will be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbSqlserverClusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: int,
                 disk_type_id: str,
                 resource_preset_id: str):
        """
        :param int disk_size: Volume of the storage available to a SQLServer host, in gigabytes.
        :param str disk_type_id: Type of the storage for SQLServer hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        Volume of the storage available to a SQLServer host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> str:
        """
        Type of the storage for SQLServer hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> str:
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbSqlserverClusterUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permissions: Sequence['outputs.GetMdbSqlserverClusterUserPermissionResult']):
        """
        :param str name: The name of the SQLServer cluster.
        :param str password: The password of the user.
        :param Sequence['GetMdbSqlserverClusterUserPermissionArgs'] permissions: Set of permissions granted to the user. The structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SQLServer cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbSqlserverClusterUserPermissionResult']:
        """
        Set of permissions granted to the user. The structure is documented below.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetMdbSqlserverClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 roles: Sequence[str]):
        """
        :param str database_name: The name of the database that the permission grants access to.
        :param Sequence[str] roles: List user's roles in the database.
               Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        List user's roles in the database.
        Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetServerlessContainerImageResult(dict):
    def __init__(__self__, *,
                 args: Sequence[str],
                 commands: Sequence[str],
                 digest: str,
                 environment: Mapping[str, str],
                 url: str,
                 work_dir: str):
        """
        :param str url: Invoke URL of the Yandex Cloud Serverless Container
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "work_dir", work_dir)

    @property
    @pulumi.getter
    def args(self) -> Sequence[str]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def digest(self) -> str:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def environment(self) -> Mapping[str, str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Invoke URL of the Yandex Cloud Serverless Container
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="workDir")
    def work_dir(self) -> str:
        return pulumi.get(self, "work_dir")


@pulumi.output_type
class GetVpcAddressExternalIpv4AddressResult(dict):
    def __init__(__self__, *,
                 address: str,
                 ddos_protection_provider: str,
                 outgoing_smtp_capability: str,
                 zone_id: str):
        """
        :param str address: IP address.
        :param str ddos_protection_provider: DDOS protection provider.
        :param str outgoing_smtp_capability: Outgoing smtp capability.
        :param str zone_id: Zone for allocating address.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ddos_protection_provider", ddos_protection_provider)
        pulumi.set(__self__, "outgoing_smtp_capability", outgoing_smtp_capability)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="ddosProtectionProvider")
    def ddos_protection_provider(self) -> str:
        """
        DDOS protection provider.
        """
        return pulumi.get(self, "ddos_protection_provider")

    @property
    @pulumi.getter(name="outgoingSmtpCapability")
    def outgoing_smtp_capability(self) -> str:
        """
        Outgoing smtp capability.
        """
        return pulumi.get(self, "outgoing_smtp_capability")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Zone for allocating address.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetVpcRouteTableStaticRouteResult(dict):
    def __init__(__self__, *,
                 destination_prefix: str,
                 next_hop_address: str):
        """
        :param str destination_prefix: Route prefix in CIDR notation.
        :param str next_hop_address: Address of the next hop.
        """
        pulumi.set(__self__, "destination_prefix", destination_prefix)
        pulumi.set(__self__, "next_hop_address", next_hop_address)

    @property
    @pulumi.getter(name="destinationPrefix")
    def destination_prefix(self) -> str:
        """
        Route prefix in CIDR notation.
        """
        return pulumi.get(self, "destination_prefix")

    @property
    @pulumi.getter(name="nextHopAddress")
    def next_hop_address(self) -> str:
        """
        Address of the next hop.
        """
        return pulumi.get(self, "next_hop_address")


@pulumi.output_type
class GetVpcSecurityGroupEgressResult(dict):
    def __init__(__self__, *,
                 description: str,
                 from_port: int,
                 id: str,
                 labels: Mapping[str, str],
                 port: int,
                 predefined_target: str,
                 protocol: str,
                 security_group_id: str,
                 to_port: int,
                 v4_cidr_blocks: Sequence[str],
                 v6_cidr_blocks: Sequence[str]):
        """
        :param str description: Description of the rule.
        :param int from_port: Minimum port number.
        :param str id: Id of the rule.
        :param Mapping[str, str] labels: Labels to assign to this rule.
        :param int port: Port number (if applied to a single port).
        :param str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        :param str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param str security_group_id: Security Group ID.
        :param int to_port: Maximum port number.
        :param Sequence[str] v4_cidr_blocks: The blocks of  IPv4 addresses for this rule.
        :param Sequence[str] v6_cidr_blocks: The blocks of  IPv6 addresses for this rule.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "predefined_target", predefined_target)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "to_port", to_port)
        pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> str:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        Security Group ID.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Sequence[str]:
        """
        The blocks of  IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Sequence[str]:
        """
        The blocks of  IPv6 addresses for this rule.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class GetVpcSecurityGroupIngressResult(dict):
    def __init__(__self__, *,
                 description: str,
                 from_port: int,
                 id: str,
                 labels: Mapping[str, str],
                 port: int,
                 predefined_target: str,
                 protocol: str,
                 security_group_id: str,
                 to_port: int,
                 v4_cidr_blocks: Sequence[str],
                 v6_cidr_blocks: Sequence[str]):
        """
        :param str description: Description of the rule.
        :param int from_port: Minimum port number.
        :param str id: Id of the rule.
        :param Mapping[str, str] labels: Labels to assign to this rule.
        :param int port: Port number (if applied to a single port).
        :param str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        :param str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param str security_group_id: Security Group ID.
        :param int to_port: Maximum port number.
        :param Sequence[str] v4_cidr_blocks: The blocks of  IPv4 addresses for this rule.
        :param Sequence[str] v6_cidr_blocks: The blocks of  IPv6 addresses for this rule.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "predefined_target", predefined_target)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "to_port", to_port)
        pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> str:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://cloud.yandex.com/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        Security Group ID.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Sequence[str]:
        """
        The blocks of  IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Sequence[str]:
        """
        The blocks of  IPv6 addresses for this rule.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class GetVpcSubnetDhcpOptionResult(dict):
    def __init__(__self__, *,
                 domain_name: str,
                 domain_name_servers: Sequence[str],
                 ntp_servers: Sequence[str]):
        """
        :param str domain_name: Domain name.
        :param Sequence[str] domain_name_servers: Domain name server IP addresses.
        :param Sequence[str] ntp_servers: NTP server IP addresses.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "domain_name_servers", domain_name_servers)
        pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        Domain name.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Sequence[str]:
        """
        Domain name server IP addresses.
        """
        return pulumi.get(self, "domain_name_servers")

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Sequence[str]:
        """
        NTP server IP addresses.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class GetYdbDatabaseDedicatedLocationResult(dict):
    def __init__(__self__, *,
                 regions: Sequence['outputs.GetYdbDatabaseDedicatedLocationRegionResult'],
                 zones: Sequence['outputs.GetYdbDatabaseDedicatedLocationZoneResult']):
        """
        :param Sequence['GetYdbDatabaseDedicatedLocationRegionArgs'] regions: Region of the Yandex Database cluster.
               The structure is documented below.
        """
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def regions(self) -> Sequence['outputs.GetYdbDatabaseDedicatedLocationRegionResult']:
        """
        Region of the Yandex Database cluster.
        The structure is documented below.
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter
    def zones(self) -> Sequence['outputs.GetYdbDatabaseDedicatedLocationZoneResult']:
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetYdbDatabaseDedicatedLocationRegionResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Region ID of the Yandex Database cluster.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Region ID of the Yandex Database cluster.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetYdbDatabaseDedicatedLocationZoneResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Region ID of the Yandex Database cluster.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Region ID of the Yandex Database cluster.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetYdbDatabaseDedicatedScalePolicyResult(dict):
    def __init__(__self__, *,
                 fixed_scales: Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyFixedScaleResult']):
        """
        :param Sequence['GetYdbDatabaseDedicatedScalePolicyFixedScaleArgs'] fixed_scales: Fixed scaling policy of the Yandex Database cluster.
               The structure is documented below.
        """
        pulumi.set(__self__, "fixed_scales", fixed_scales)

    @property
    @pulumi.getter(name="fixedScales")
    def fixed_scales(self) -> Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyFixedScaleResult']:
        """
        Fixed scaling policy of the Yandex Database cluster.
        The structure is documented below.
        """
        return pulumi.get(self, "fixed_scales")


@pulumi.output_type
class GetYdbDatabaseDedicatedScalePolicyFixedScaleResult(dict):
    def __init__(__self__, *,
                 size: int):
        """
        :param int size: Number of instances in the Yandex Database cluster.
        """
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Number of instances in the Yandex Database cluster.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetYdbDatabaseDedicatedStorageConfigResult(dict):
    def __init__(__self__, *,
                 group_count: int,
                 storage_type_id: str):
        """
        :param int group_count: Amount of storage groups of selected type in the Yandex Database cluster.
        :param str storage_type_id: Storage type ID of the Yandex Database cluster.
        """
        pulumi.set(__self__, "group_count", group_count)
        pulumi.set(__self__, "storage_type_id", storage_type_id)

    @property
    @pulumi.getter(name="groupCount")
    def group_count(self) -> int:
        """
        Amount of storage groups of selected type in the Yandex Database cluster.
        """
        return pulumi.get(self, "group_count")

    @property
    @pulumi.getter(name="storageTypeId")
    def storage_type_id(self) -> str:
        """
        Storage type ID of the Yandex Database cluster.
        """
        return pulumi.get(self, "storage_type_id")


